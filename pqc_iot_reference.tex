%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% POST-QUANTUM CRYPTOGRAPHY FOR LIGHTWEIGHT IoT DEVICES
% A Comprehensive Reference for Academic Researchers
% 
% Author: Abdessamad JAOUAD
% Supervisor: Prof. Ibrahim GUELZIM
% Institution: ENSAM Casablanca
% Date: December 2024
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[12pt,a4paper,twoside]{report}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% PACKAGES
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Encoding and fonts
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{microtype}

% Page layout
\usepackage[
    top=2.5cm,
    bottom=2.5cm,
    left=3cm,
    right=2.5cm,
    headheight=15pt
]{geometry}

% Language
\usepackage[english]{babel}

% Mathematics
\usepackage{amsmath,amssymb,amsthm}
\usepackage{mathtools}
\usepackage{bm}

% Graphics and figures
\usepackage{graphicx}
\usepackage{float}
\usepackage{wrapfig}
\usepackage{subfig}
\usepackage{tikz}
\usetikzlibrary{shapes,arrows,positioning,calc,fit,backgrounds}

% Tables
\usepackage{booktabs}
\usepackage{longtable}
\usepackage{multirow}
\usepackage{array}
\usepackage{tabularx}
\usepackage{colortbl}

% Colors
\usepackage[table,xcdraw]{xcolor}
\definecolor{ensam-blue}{RGB}{0,84,147}
\definecolor{ensam-gold}{RGB}{196,154,55}
\definecolor{light-gray}{RGB}{245,245,245}
\definecolor{code-bg}{RGB}{248,248,248}
\definecolor{nist-green}{RGB}{0,128,0}
\definecolor{warning-orange}{RGB}{255,140,0}

% Code listings
\usepackage{listings}
\lstset{
    basicstyle=\ttfamily\small,
    backgroundcolor=\color{code-bg},
    breaklines=true,
    breakatwhitespace=true,
    captionpos=b,
    commentstyle=\color{gray},
    keywordstyle=\color{ensam-blue}\bfseries,
    stringstyle=\color{nist-green},
    numbers=left,
    numberstyle=\tiny\color{gray},
    numbersep=8pt,
    frame=single,
    framerule=0.5pt,
    rulecolor=\color{gray},
    showstringspaces=false,
    tabsize=4,
    xleftmargin=15pt,
    framexleftmargin=15pt
}

% Algorithms
\usepackage{algorithm}
\usepackage{algpseudocode}

% Hyperlinks and references
\usepackage[
    colorlinks=true,
    linkcolor=ensam-blue,
    citecolor=ensam-blue,
    urlcolor=ensam-blue,
    bookmarks=true,
    bookmarksnumbered=true
]{hyperref}
\usepackage{bookmark}

% Headers and footers
\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}
\fancyhead[LE]{\leftmark}
\fancyhead[RO]{\rightmark}
\fancyfoot[C]{\thepage}
\renewcommand{\headrulewidth}{0.4pt}

% Bibliography
\usepackage[numbers,sort&compress]{natbib}

% Glossary and acronyms
\usepackage[acronym,toc]{glossaries}
\makeglossaries

% Appendices
\usepackage[toc,page]{appendix}

% Captions
\usepackage{caption}
\captionsetup{font=small,labelfont=bf}

% Spacing
\usepackage{setspace}
\onehalfspacing

% Notes and todos (for development)
\usepackage{todonotes}

% Quotes
\usepackage{csquotes}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% THEOREM ENVIRONMENTS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\theoremstyle{definition}
\newtheorem{definition}{Definition}[chapter]
\newtheorem{example}{Example}[chapter]

\theoremstyle{plain}
\newtheorem{theorem}{Theorem}[chapter]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}

\theoremstyle{remark}
\newtheorem{remark}{Remark}[chapter]
\newtheorem{note}{Note}[chapter]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% CUSTOM COMMANDS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Mathematical notation
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\Zq}{\mathbb{Z}_q}
\newcommand{\R}{\mathbb{R}}
\newcommand{\Rq}{R_q}
\newcommand{\poly}{\text{poly}}
\newcommand{\negl}{\text{negl}}
\newcommand{\getsr}{\stackrel{\$}{\gets}}
\newcommand{\norm}[1]{\left\|#1\right\|}

% Cryptographic notation
\newcommand{\KeyGen}{\mathsf{KeyGen}}
\newcommand{\Enc}{\mathsf{Enc}}
\newcommand{\Dec}{\mathsf{Dec}}
\newcommand{\Sign}{\mathsf{Sign}}
\newcommand{\Verify}{\mathsf{Verify}}
\newcommand{\Encaps}{\mathsf{Encaps}}
\newcommand{\Decaps}{\mathsf{Decaps}}

% Algorithm names
\newcommand{\MLKEM}{\textsf{ML-KEM}}
\newcommand{\MLDSA}{\textsf{ML-DSA}}
\newcommand{\SLHDSA}{\textsf{SLH-DSA}}
\newcommand{\Kyber}{\textsf{Kyber}}
\newcommand{\Dilithium}{\textsf{Dilithium}}
\newcommand{\Falcon}{\textsf{Falcon}}
\newcommand{\SPHINCS}{\textsf{SPHINCS+}}

% Units
\newcommand{\KB}{\,\text{KB}}
\newcommand{\MB}{\,\text{MB}}
\newcommand{\kB}{\,\text{kB}}
\newcommand{\bytes}{\,\text{B}}
\newcommand{\cycles}{\,\text{cycles}}
\newcommand{\kcycles}{\,\text{k cycles}}
\newcommand{\mcycles}{\,\text{M cycles}}

% Highlight boxes
\newcommand{\warningbox}[1]{%
    \begin{center}
    \fcolorbox{warning-orange}{yellow!10}{%
        \parbox{0.9\textwidth}{\textbf{⚠ Warning:} #1}%
    }
    \end{center}
}

\newcommand{\infobox}[1]{%
    \begin{center}
    \fcolorbox{ensam-blue}{blue!5}{%
        \parbox{0.9\textwidth}{\textbf{ℹ Note:} #1}%
    }
    \end{center}
}

\newcommand{\placeholder}[2]{%
    \begin{figure}[H]
    \centering
    \fbox{\parbox{#1}{%
        \centering
        \vspace{2cm}
        \textit{[Placeholder: #2]}
        \vspace{2cm}
    }}
    \end{figure}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ACRONYMS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newacronym{pqc}{PQC}{Post-Quantum Cryptography}
\newacronym{iot}{IoT}{Internet of Things}
\newacronym{nist}{NIST}{National Institute of Standards and Technology}
\newacronym{lwe}{LWE}{Learning With Errors}
\newacronym{mlwe}{MLWE}{Module Learning With Errors}
\newacronym{sis}{SIS}{Short Integer Solution}
\newacronym{msis}{MSIS}{Module Short Integer Solution}
\newacronym{kem}{KEM}{Key Encapsulation Mechanism}
\newacronym{dsa}{DSA}{Digital Signature Algorithm}
\newacronym{ntt}{NTT}{Number Theoretic Transform}
\newacronym{fft}{FFT}{Fast Fourier Transform}
\newacronym{rsa}{RSA}{Rivest-Shamir-Adleman}
\newacronym{ecc}{ECC}{Elliptic Curve Cryptography}
\newacronym{aes}{AES}{Advanced Encryption Standard}
\newacronym{sha}{SHA}{Secure Hash Algorithm}
\newacronym{tls}{TLS}{Transport Layer Security}
\newacronym{dtls}{DTLS}{Datagram Transport Layer Security}
\newacronym{mqtt}{MQTT}{Message Queuing Telemetry Transport}
\newacronym{coap}{CoAP}{Constrained Application Protocol}
\newacronym{mcu}{MCU}{Microcontroller Unit}
\newacronym{ram}{RAM}{Random Access Memory}
\newacronym{rom}{ROM}{Read-Only Memory}
\newacronym{fips}{FIPS}{Federal Information Processing Standards}
\newacronym{qcmdpc}{QC-MDPC}{Quasi-Cyclic Moderate Density Parity-Check}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% DOCUMENT
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% TITLE PAGE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{titlepage}
    \centering
    
    % ENSAM Logo
    \includegraphics[width=4cm]{ensam_logo.png}
    
    \vspace{0.5cm}
    
    {\large\textbf{École Nationale Supérieure d'Arts et Métiers}}\\
    {\large Casablanca}
    
    \vspace{0.5cm}
    
    {\large Master Big Data \& Internet of Things}
    
    \vspace{1.5cm}
    
    \rule{\textwidth}{1.5pt}
    
    \vspace{0.5cm}
    
    {\Huge\bfseries\color{ensam-blue} Post-Quantum Cryptography\\[0.3cm]
    for Lightweight IoT Devices}
    
    \vspace{0.3cm}
    
    {\Large\itshape A Comprehensive Reference for Academic Researchers}
    
    \vspace{0.5cm}
    
    \rule{\textwidth}{1.5pt}
    
    \vspace{1cm}
    
    % PQC illustration
    \includegraphics[width=6cm]{pqc.png}
    
    \vspace{1cm}
    
    \begin{minipage}{0.45\textwidth}
        \begin{flushleft}
            \textbf{Author:}\\
            Abdessamad JAOUAD\\
            \textit{M2 Big Data \& IoT}
        \end{flushleft}
    \end{minipage}
    \hfill
    \begin{minipage}{0.45\textwidth}
        \begin{flushright}
            \textbf{Supervisor:}\\
            Prof. Ibrahim GUELZIM\\
            \textit{ENSAM Casablanca}
        \end{flushright}
    \end{minipage}
    
    \vfill
    
    {\large Academic Year 2024--2025}
    
    \vspace{0.5cm}
    
    {\small Version 1.0 -- December 2024}
    
\end{titlepage}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% FRONT MATTER
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\frontmatter

% Abstract
\chapter*{Abstract}
\addcontentsline{toc}{chapter}{Abstract}

The advent of large-scale quantum computers poses an existential threat to the cryptographic foundations of modern digital infrastructure. Current public-key cryptographic systems---including RSA and Elliptic Curve Cryptography---rely on mathematical problems that quantum computers can solve efficiently using Shor's algorithm. This vulnerability extends to the billions of Internet of Things (IoT) devices that form the backbone of smart cities, industrial systems, and critical infrastructure.

This comprehensive reference document surveys the emerging field of Post-Quantum Cryptography (PQC) with a specific focus on implementations suitable for resource-constrained IoT devices. We provide an in-depth analysis of the algorithms standardized by the National Institute of Standards and Technology (NIST) in August 2024: ML-KEM (Kyber) for key encapsulation, ML-DSA (Dilithium) and SLH-DSA (SPHINCS+) for digital signatures, along with the forthcoming Falcon signature scheme.

The document offers detailed benchmark data from real hardware implementations, particularly on ARM Cortex-M series microcontrollers commonly found in IoT applications. We catalog available software libraries, analyze memory and computational requirements across different IoT device categories, and provide practical guidance for migration from classical to post-quantum cryptographic systems.

This work serves as a definitive reference for academic researchers, graduate students, and practitioners seeking to understand and implement post-quantum cryptography in constrained environments.

\vspace{1cm}

\noindent\textbf{Keywords:} Post-Quantum Cryptography, Internet of Things, Lattice-Based Cryptography, Key Encapsulation, Digital Signatures, ARM Cortex-M, Embedded Systems, NIST Standards, ML-KEM, ML-DSA

% Acknowledgments
\chapter*{Acknowledgments}
\addcontentsline{toc}{chapter}{Acknowledgments}

I would like to express my sincere gratitude to my supervisor, Professor Ibrahim GUELZIM, for his invaluable guidance, continuous support, and expert insights throughout this research project. His deep knowledge of cryptography and IoT systems has been instrumental in shaping this work.

I am grateful to the faculty and staff of ENSAM Casablanca, particularly the Big Data \& IoT program, for providing an excellent academic environment and the resources necessary to conduct this research.

Special thanks to the open-source community, particularly the developers of liboqs, PQClean, and pqm4 projects, whose implementations and benchmark data have been invaluable resources for this survey.

Finally, I thank my family and friends for their unwavering support and encouragement throughout my academic journey.

\vspace{2cm}

\begin{flushright}
    \textit{Abdessamad JAOUAD}\\
    \textit{Casablanca, December 2024}
\end{flushright}

% Table of Contents
\tableofcontents

% List of Figures
\listoffigures
\addcontentsline{toc}{chapter}{List of Figures}

% List of Tables
\listoftables
\addcontentsline{toc}{chapter}{List of Tables}

% List of Algorithms
\listofalgorithms
\addcontentsline{toc}{chapter}{List of Algorithms}

% Acronyms
\printglossary[type=\acronymtype,title={List of Acronyms}]
\addcontentsline{toc}{chapter}{List of Acronyms}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% MAIN MATTER
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\mainmatter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% CHAPTER 1: INTRODUCTION
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Introduction}
\label{ch:introduction}

\section{The Quantum Threat to Modern Cryptography}
\label{sec:quantum-threat}

Modern digital security rests upon the presumed computational difficulty of certain mathematical problems. The \gls{rsa} cryptosystem, introduced in 1977, derives its security from the hardness of factoring large integers. \gls{ecc}, which has largely supplanted RSA in many applications due to its efficiency, relies on the discrete logarithm problem over elliptic curves. For decades, these mathematical foundations have provided robust security guarantees, with the best-known classical algorithms requiring exponential time to break properly-sized keys.

\begin{definition}[Integer Factorization Problem]
Given a composite integer $N = p \cdot q$ where $p$ and $q$ are large primes, find the factors $p$ and $q$.
\end{definition}

\begin{definition}[Elliptic Curve Discrete Logarithm Problem]
Given points $P$ and $Q = kP$ on an elliptic curve $E$ over a finite field $\mathbb{F}_q$, find the scalar $k$.
\end{definition}

The security landscape changed fundamentally in 1994 when Peter Shor demonstrated that a sufficiently powerful quantum computer could solve both integer factorization and discrete logarithm problems in polynomial time \cite{shor1994}. Shor's algorithm achieves exponential speedup over the best-known classical algorithms:

\begin{table}[H]
\centering
\caption{Complexity comparison: Classical vs. Quantum algorithms}
\label{tab:complexity-comparison}
\begin{tabular}{lccc}
\toprule
\textbf{Problem} & \textbf{Classical} & \textbf{Quantum (Shor)} & \textbf{Speedup} \\
\midrule
Integer Factorization & $O\left(e^{1.9 \cdot n^{1/3} \cdot (\ln n)^{2/3}}\right)$ & $O(n^3)$ & Exponential \\
Discrete Logarithm & $O(\sqrt{q})$ & $O((\log q)^3)$ & Exponential \\
ECDLP (ECC) & $O(\sqrt{q})$ & $O((\log q)^3)$ & Exponential \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Current State of Quantum Computing}
\label{subsec:quantum-state}

As of December 2024, quantum computers have made remarkable progress but have not yet achieved the scale necessary to threaten current cryptographic systems. Breaking RSA-2048 would require approximately 4,000 logical qubits with full error correction, translating to millions of physical qubits with current error rates. The largest quantum computers today operate with hundreds to low thousands of physical qubits, with limited coherence times and high error rates.

\placeholder{0.8\textwidth}{Timeline showing quantum computing milestones and projected cryptographic threat timeline (2024-2035)}

However, the cryptographic community operates under the assumption that cryptographically-relevant quantum computers (CRQCs) will eventually be built. This assumption is motivated by several factors:

\begin{enumerate}
    \item \textbf{Continuous Progress}: Qubit counts and error correction capabilities improve yearly
    \item \textbf{Major Investment}: Governments and corporations invest billions in quantum computing research
    \item \textbf{Harvest Now, Decrypt Later}: Adversaries can store encrypted data today to decrypt when quantum computers become available
    \item \textbf{Migration Time}: Transitioning cryptographic infrastructure takes 10--20 years
\end{enumerate}

\warningbox{The ``harvest now, decrypt later'' threat means that data encrypted today with classical cryptography may be compromised in the future. This is particularly concerning for data with long-term confidentiality requirements.}

\subsection{Impact on IoT Security}
\label{subsec:iot-impact}

The Internet of Things encompasses billions of connected devices, from industrial sensors and smart meters to medical implants and autonomous vehicles. These devices face unique challenges in the post-quantum transition:

\begin{itemize}
    \item \textbf{Resource Constraints}: Many IoT devices have limited computational power (MHz-class processors), memory (kilobytes of RAM), and energy budgets
    \item \textbf{Long Deployment Lifetimes}: Industrial IoT devices may remain operational for 15--20 years, spanning the pre- and post-quantum eras
    \item \textbf{Difficult Updates}: Many deployed devices lack secure update mechanisms or may be physically inaccessible
    \item \textbf{Real-Time Requirements}: Safety-critical applications demand predictable latency
    \item \textbf{Bandwidth Limitations}: Low-power wide-area networks (LPWAN) have severe bandwidth constraints
\end{itemize}

\begin{table}[H]
\centering
\caption{IoT device categories and their characteristics}
\label{tab:iot-categories}
\begin{tabular}{lcccc}
\toprule
\textbf{Category} & \textbf{Processor} & \textbf{RAM} & \textbf{Flash} & \textbf{Example} \\
\midrule
Class 0 (Constrained) & 8-bit MCU & $<$10 KB & $<$100 KB & Sensor nodes \\
Class 1 (Limited) & 16-bit MCU & $\sim$10 KB & $\sim$100 KB & Smart meters \\
Class 2 (Capable) & 32-bit ARM & $\sim$50 KB & $\sim$250 KB & Wearables \\
Class 3 (Advanced) & ARM Cortex-M4/M7 & $>$256 KB & $>$1 MB & Gateways \\
\bottomrule
\end{tabular}
\end{table}

\section{Post-Quantum Cryptography: An Overview}
\label{sec:pqc-overview}

\Gls{pqc} refers to cryptographic algorithms designed to resist attacks by both classical and quantum computers. Unlike quantum cryptography (which uses quantum mechanical phenomena for key distribution), PQC algorithms run on conventional hardware using classical computation.

\subsection{Mathematical Foundations}
\label{subsec:math-foundations}

Post-quantum cryptographic schemes are built upon mathematical problems believed to be resistant to quantum attacks. The main families include:

\subsubsection{Lattice-Based Cryptography}

Lattice-based schemes derive security from the hardness of problems involving high-dimensional geometric structures called lattices.

\begin{definition}[Lattice]
A \emph{lattice} $\Lambda$ in $\R^n$ is the set of all integer linear combinations of a set of linearly independent vectors $\mathbf{b}_1, \ldots, \mathbf{b}_n \in \R^n$:
\[
\Lambda = \mathcal{L}(\mathbf{B}) = \left\{ \sum_{i=1}^{n} x_i \mathbf{b}_i : x_i \in \Z \right\}
\]
where $\mathbf{B} = [\mathbf{b}_1 | \cdots | \mathbf{b}_n]$ is the \emph{basis} of the lattice.
\end{definition}

\placeholder{0.6\textwidth}{2D illustration of a lattice with basis vectors and the closest vector problem}

The security of lattice-based cryptography relies on two fundamental problems:

\begin{definition}[Learning With Errors (LWE)]
\label{def:lwe}
Given a matrix $\mathbf{A} \in \Zq^{m \times n}$, a secret vector $\mathbf{s} \in \Zq^n$, and a noise vector $\mathbf{e}$ sampled from an error distribution $\chi$, the LWE problem asks to find $\mathbf{s}$ given $(\mathbf{A}, \mathbf{b} = \mathbf{A}\mathbf{s} + \mathbf{e} \mod q)$.
\end{definition}

\begin{definition}[Short Integer Solution (SIS)]
\label{def:sis}
Given a matrix $\mathbf{A} \in \Zq^{n \times m}$ and a bound $\beta$, find a non-zero vector $\mathbf{z} \in \Z^m$ such that $\mathbf{A}\mathbf{z} = \mathbf{0} \mod q$ and $\|\mathbf{z}\| \leq \beta$.
\end{definition}

Modern schemes use \emph{structured} variants of these problems (Ring-LWE, Module-LWE) that operate over polynomial rings, enabling more efficient implementations:

\begin{definition}[Module-LWE]
The Module-LWE problem is defined over the ring $\Rq = \Zq[x]/(x^n + 1)$ where operations involve matrices and vectors of polynomials. For rank $k$, given $\mathbf{A} \in \Rq^{k \times k}$ and $\mathbf{b} = \mathbf{A}\mathbf{s} + \mathbf{e}$, find $\mathbf{s}$.
\end{definition}

\subsubsection{Hash-Based Signatures}

Hash-based signature schemes derive security solely from the properties of cryptographic hash functions, making them the most conservative choice from a security perspective.

\begin{definition}[Hash Function Security Properties]
A cryptographic hash function $H: \{0,1\}^* \rightarrow \{0,1\}^n$ should satisfy:
\begin{itemize}
    \item \textbf{Preimage Resistance}: Given $h$, hard to find $m$ such that $H(m) = h$
    \item \textbf{Second Preimage Resistance}: Given $m_1$, hard to find $m_2 \neq m_1$ with $H(m_1) = H(m_2)$
    \item \textbf{Collision Resistance}: Hard to find any $m_1 \neq m_2$ with $H(m_1) = H(m_2)$
\end{itemize}
\end{definition}

Hash-based signatures use Merkle tree constructions to authenticate many one-time signature keys under a single public key.

\subsubsection{Code-Based Cryptography}

Code-based schemes rely on the difficulty of decoding random linear codes.

\begin{definition}[Syndrome Decoding Problem]
Given a parity-check matrix $\mathbf{H} \in \mathbb{F}_2^{(n-k) \times n}$, a syndrome $\mathbf{s} \in \mathbb{F}_2^{n-k}$, and a weight bound $t$, find an error vector $\mathbf{e} \in \mathbb{F}_2^n$ with Hamming weight at most $t$ such that $\mathbf{H}\mathbf{e}^T = \mathbf{s}$.
\end{definition}

\subsubsection{Multivariate Cryptography}

Multivariate schemes are based on the difficulty of solving systems of multivariate polynomial equations over finite fields.

\begin{definition}[MQ Problem]
Given a system of $m$ quadratic polynomials $p_1, \ldots, p_m$ in $n$ variables over a finite field $\mathbb{F}_q$, find a solution $(x_1, \ldots, x_n) \in \mathbb{F}_q^n$ such that $p_i(x_1, \ldots, x_n) = 0$ for all $i$.
\end{definition}

\subsubsection{Isogeny-Based Cryptography}

Isogeny-based schemes use the mathematical structure of elliptic curve isogenies.

\begin{definition}[Isogeny]
An isogeny between elliptic curves $E_1$ and $E_2$ is a non-constant rational map $\phi: E_1 \rightarrow E_2$ that is also a group homomorphism.
\end{definition}

\infobox{The SIDH/SIKE scheme was broken in 2022 by Castryck and Decru, demonstrating the importance of cryptanalytic scrutiny before standardization.}

\subsection{Comparison of PQC Families}
\label{subsec:pqc-comparison}

\begin{table}[H]
\centering
\caption{Comparison of post-quantum cryptography families}
\label{tab:pqc-families}
\begin{tabular}{lcccccc}
\toprule
\textbf{Family} & \textbf{Key Size} & \textbf{Sig/CT Size} & \textbf{Speed} & \textbf{Maturity} & \textbf{IoT Suitability} \\
\midrule
Lattice-based & Medium & Medium & Fast & High & \textcolor{nist-green}{Good} \\
Hash-based & Small/Large & Large & Medium & Very High & \textcolor{warning-orange}{Limited} \\
Code-based & Large & Small & Fast & High & \textcolor{warning-orange}{Limited} \\
Multivariate & Large & Small & Variable & Medium & \textcolor{red}{Poor} \\
Isogeny-based & Small & Small & Slow & Low* & \textcolor{red}{Poor} \\
\bottomrule
\end{tabular}
\begin{tablenotes}
\small
\item *Isogeny-based schemes have suffered significant cryptanalytic setbacks.
\end{tablenotes}
\end{table}

\section{NIST Post-Quantum Standardization}
\label{sec:nist-standardization}

The National Institute of Standards and Technology initiated its Post-Quantum Cryptography Standardization project in 2016, recognizing the urgent need to prepare for the quantum computing era. The process followed NIST's established approach for cryptographic standards, emphasizing open competition, public analysis, and iterative refinement.

\subsection{Timeline and Process}
\label{subsec:nist-timeline}

\begin{table}[H]
\centering
\caption{NIST PQC Standardization timeline}
\label{tab:nist-timeline}
\begin{tabular}{ll}
\toprule
\textbf{Date} & \textbf{Milestone} \\
\midrule
December 2016 & Call for proposals issued \\
November 2017 & 69 submissions received (Round 1) \\
January 2019 & 26 candidates advance to Round 2 \\
July 2020 & 7 finalists + 8 alternates (Round 3) \\
July 2022 & Selection of first algorithms for standardization \\
August 2024 & \textbf{FIPS 203, 204, 205 published (ML-KEM, ML-DSA, SLH-DSA)} \\
2024--2025 & Round 4 (additional signatures) and HQC standardization \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Standardized Algorithms (August 2024)}
\label{subsec:standardized-algorithms}

On August 13, 2024, NIST published three Federal Information Processing Standards:

\begin{enumerate}
    \item \textbf{FIPS 203: Module-Lattice-Based Key-Encapsulation Mechanism (\MLKEM)}
    \begin{itemize}
        \item Based on the CRYSTALS-Kyber submission
        \item Security from Module-LWE problem
        \item Three parameter sets: ML-KEM-512, ML-KEM-768, ML-KEM-1024
    \end{itemize}
    
    \item \textbf{FIPS 204: Module-Lattice-Based Digital Signature Algorithm (\MLDSA)}
    \begin{itemize}
        \item Based on the CRYSTALS-Dilithium submission
        \item Security from Module-LWE and Module-SIS problems
        \item Three parameter sets: ML-DSA-44, ML-DSA-65, ML-DSA-87
    \end{itemize}
    
    \item \textbf{FIPS 205: Stateless Hash-Based Digital Signature Algorithm (\SLHDSA)}
    \begin{itemize}
        \item Based on the SPHINCS+ submission
        \item Security from hash function properties only
        \item Multiple parameter sets with size/speed tradeoffs
    \end{itemize}
\end{enumerate}

\subsection{Algorithms Under Standardization}
\label{subsec:upcoming-standards}

Additional algorithms are progressing through standardization:

\begin{itemize}
    \item \textbf{Falcon}: NTRU-lattice-based signature scheme, selected for standardization but requiring additional specification work due to implementation complexity
    \item \textbf{HQC}: Code-based KEM selected for Round 4 standardization as a backup to ML-KEM
    \item \textbf{BIKE}: Code-based KEM under continued evaluation
\end{itemize}

\section{Scope and Organization of This Document}
\label{sec:scope-organization}

This reference document provides a comprehensive survey of post-quantum cryptography for IoT applications, organized as follows:

\begin{description}
    \item[Chapter 2: Mathematical Foundations] Detailed treatment of lattice theory, the LWE/SIS problems, and the mathematical structures underlying PQC schemes.
    
    \item[Chapter 3: Key Encapsulation Mechanisms] In-depth analysis of ML-KEM (Kyber), including algorithms, parameters, security analysis, and implementation considerations.
    
    \item[Chapter 4: Digital Signature Schemes] Comprehensive coverage of ML-DSA (Dilithium), SLH-DSA (SPHINCS+), and Falcon, with comparative analysis.
    
    \item[Chapter 5: Alternative and Emerging Schemes] Survey of code-based (HQC, BIKE, Classic McEliece), multivariate, and other PQC approaches.
    
    \item[Chapter 6: Implementation for IoT] Practical guidance on implementing PQC in resource-constrained environments, with benchmark data and optimization strategies.
    
    \item[Chapter 7: Libraries and Tools] Catalog of available software libraries, with feature comparisons and usage examples.
    
    \item[Chapter 8: Protocol Integration] Integration of PQC into IoT protocols including TLS, DTLS, MQTT, and CoAP.
    
    \item[Chapter 9: Migration Strategies] Roadmaps and best practices for transitioning from classical to post-quantum cryptography.
    
    \item[Chapter 10: Future Directions] Emerging research areas, open problems, and the evolving PQC landscape.
\end{description}

\section{How to Use This Reference}
\label{sec:how-to-use}

This document is designed to serve multiple audiences:

\begin{itemize}
    \item \textbf{Graduate Students}: Start with Chapter 1--2 for foundational understanding, then proceed to specific algorithm chapters based on research interests.
    
    \item \textbf{Researchers}: Use the benchmark tables and comparative analyses to inform experimental design and publication references.
    
    \item \textbf{Practitioners/Engineers}: Focus on Chapters 6--9 for implementation guidance, library selection, and migration planning.
    
    \item \textbf{Security Architects}: Chapters 8--9 provide protocol integration and migration strategies for system design.
\end{itemize}

\infobox{Throughout this document, placeholder images indicate where readers may insert relevant diagrams, charts, or photographs. Image specifications are provided in the placeholder descriptions.}

\section{Chapter Summary}
\label{sec:ch1-summary}

This introductory chapter established the context and motivation for post-quantum cryptography in IoT environments:

\begin{itemize}
    \item Shor's algorithm renders current public-key cryptography vulnerable to quantum attacks
    \item The ``harvest now, decrypt later'' threat creates urgency for immediate action
    \item IoT devices face unique challenges due to resource constraints and long deployment lifetimes
    \item NIST published the first PQC standards (FIPS 203, 204, 205) in August 2024
    \item Lattice-based cryptography offers the best balance of security and efficiency for IoT
    \item This document provides comprehensive coverage for researchers and practitioners
\end{itemize}

% End of Chapter 1

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% CHAPTER 2: MATHEMATICAL FOUNDATIONS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Mathematical Foundations}
\label{ch:mathematical-foundations}

This chapter provides the mathematical background necessary to understand post-quantum cryptographic schemes. We focus on lattice theory and the computational problems that underpin the security of modern PQC algorithms, presented at a level accessible to graduate students with basic knowledge of linear algebra and abstract algebra.

\section{Algebraic Preliminaries}
\label{sec:algebraic-preliminaries}

\subsection{Groups, Rings, and Fields}
\label{subsec:groups-rings-fields}

\begin{definition}[Group]
A \emph{group} $(G, \cdot)$ is a set $G$ equipped with a binary operation $\cdot$ satisfying:
\begin{enumerate}
    \item \textbf{Closure}: For all $a, b \in G$, we have $a \cdot b \in G$
    \item \textbf{Associativity}: For all $a, b, c \in G$, we have $(a \cdot b) \cdot c = a \cdot (b \cdot c)$
    \item \textbf{Identity}: There exists $e \in G$ such that $e \cdot a = a \cdot e = a$ for all $a \in G$
    \item \textbf{Inverse}: For each $a \in G$, there exists $a^{-1} \in G$ such that $a \cdot a^{-1} = a^{-1} \cdot a = e$
\end{enumerate}
If additionally $a \cdot b = b \cdot a$ for all $a, b \in G$, the group is called \emph{abelian}.
\end{definition}

\begin{definition}[Ring]
A \emph{ring} $(R, +, \cdot)$ is a set $R$ equipped with two binary operations such that:
\begin{enumerate}
    \item $(R, +)$ is an abelian group
    \item $\cdot$ is associative
    \item Distributive laws hold: $a \cdot (b + c) = a \cdot b + a \cdot c$ and $(a + b) \cdot c = a \cdot c + b \cdot c$
\end{enumerate}
If $\cdot$ is commutative, $R$ is a \emph{commutative ring}. If $R$ has a multiplicative identity $1$, it is a \emph{ring with unity}.
\end{definition}

\begin{definition}[Field]
A \emph{field} $(F, +, \cdot)$ is a commutative ring with unity where every non-zero element has a multiplicative inverse.
\end{definition}

\begin{example}[Finite Fields]
For a prime $p$, the integers modulo $p$, denoted $\mathbb{F}_p = \Z/p\Z = \{0, 1, \ldots, p-1\}$, form a field with addition and multiplication performed modulo $p$. In PQC, we typically use:
\begin{itemize}
    \item $\mathbb{F}_q$ where $q = 3329$ (Kyber/ML-KEM)
    \item $\mathbb{F}_q$ where $q = 8380417$ (Dilithium/ML-DSA)
\end{itemize}
\end{example}

\subsection{Polynomial Rings}
\label{subsec:polynomial-rings}

Lattice-based cryptography extensively uses polynomial rings for efficiency.

\begin{definition}[Polynomial Ring]
Let $R$ be a ring. The \emph{polynomial ring} $R[x]$ consists of all polynomials in the variable $x$ with coefficients in $R$:
\[
R[x] = \left\{ \sum_{i=0}^{n} a_i x^i : a_i \in R, n \in \mathbb{N} \right\}
\]
\end{definition}

\begin{definition}[Quotient Ring]
For a polynomial $f(x) \in R[x]$, the \emph{quotient ring} $R[x]/(f(x))$ consists of equivalence classes of polynomials modulo $f(x)$. Elements can be represented as polynomials of degree less than $\deg(f)$.
\end{definition}

\begin{definition}[Cyclotomic Ring]
The ring $R_q = \Zq[x]/(x^n + 1)$, where $n$ is a power of 2 and $q$ is prime with $q \equiv 1 \pmod{2n}$, is called a \emph{cyclotomic ring}. This is the algebraic structure underlying Kyber, Dilithium, and many other lattice-based schemes.
\end{definition}

\begin{example}
In ML-KEM (Kyber), we use $R_q = \Z_{3329}[x]/(x^{256} + 1)$. An element $a \in R_q$ is a polynomial:
\[
a(x) = a_0 + a_1 x + a_2 x^2 + \cdots + a_{255} x^{255}
\]
where each coefficient $a_i \in \{0, 1, \ldots, 3328\}$. Multiplication is performed modulo both $q = 3329$ (for coefficients) and $x^{256} + 1$ (for the polynomial degree).
\end{example}

\infobox{The choice of $x^n + 1$ as the modulus polynomial is not arbitrary. For $n$ a power of 2, this polynomial is irreducible over $\mathbb{Q}$ and allows efficient multiplication via the Number Theoretic Transform.}

\subsection{The Number Theoretic Transform (NTT)}
\label{subsec:ntt}

The Number Theoretic Transform is a crucial algorithmic tool that enables efficient polynomial multiplication in $R_q$.

\begin{definition}[Primitive Root of Unity]
An element $\omega \in \Zq$ is a \emph{primitive $n$-th root of unity} if $\omega^n = 1$ and $\omega^k \neq 1$ for all $0 < k < n$.
\end{definition}

\begin{definition}[Number Theoretic Transform]
For a polynomial $a(x) = \sum_{i=0}^{n-1} a_i x^i \in R_q$ and a primitive $n$-th root of unity $\omega$, the NTT is defined as:
\[
\hat{a}_j = \text{NTT}(a)_j = \sum_{i=0}^{n-1} a_i \omega^{ij} \mod q, \quad j = 0, 1, \ldots, n-1
\]
The inverse NTT is:
\[
a_i = \text{NTT}^{-1}(\hat{a})_i = n^{-1} \sum_{j=0}^{n-1} \hat{a}_j \omega^{-ij} \mod q
\]
\end{definition}

The key property is that polynomial multiplication becomes pointwise multiplication in the NTT domain:
\[
\text{NTT}(a \cdot b) = \text{NTT}(a) \circ \text{NTT}(b)
\]
where $\circ$ denotes componentwise multiplication.

\begin{table}[H]
\centering
\caption{Complexity comparison of polynomial multiplication methods}
\label{tab:mult-complexity}
\begin{tabular}{lcc}
\toprule
\textbf{Method} & \textbf{Multiplications} & \textbf{Additions} \\
\midrule
Schoolbook & $O(n^2)$ & $O(n^2)$ \\
Karatsuba & $O(n^{1.585})$ & $O(n^{1.585})$ \\
NTT-based & $O(n \log n)$ & $O(n \log n)$ \\
\bottomrule
\end{tabular}
\end{table}

\begin{algorithm}[H]
\caption{Cooley-Tukey NTT (In-place, Iterative)}
\label{alg:ntt}
\begin{algorithmic}[1]
\Require Polynomial coefficients $a = (a_0, \ldots, a_{n-1})$, primitive root $\omega$, modulus $q$
\Ensure NTT coefficients $\hat{a} = (\hat{a}_0, \ldots, \hat{a}_{n-1})$
\State Bit-reverse the array $a$
\For{$s = 1$ to $\log_2 n$}
    \State $m \gets 2^s$
    \State $\omega_m \gets \omega^{n/m} \mod q$
    \For{$k = 0$ to $n-1$ by $m$}
        \State $w \gets 1$
        \For{$j = 0$ to $m/2 - 1$}
            \State $t \gets w \cdot a[k + j + m/2] \mod q$
            \State $u \gets a[k + j]$
            \State $a[k + j] \gets (u + t) \mod q$
            \State $a[k + j + m/2] \gets (u - t) \mod q$
            \State $w \gets w \cdot \omega_m \mod q$
        \EndFor
    \EndFor
\EndFor
\State \Return $a$
\end{algorithmic}
\end{algorithm}

\section{Lattice Theory}
\label{sec:lattice-theory}

\subsection{Basic Definitions}
\label{subsec:lattice-basics}

\begin{definition}[Lattice]
A \emph{lattice} $\mathcal{L}$ is a discrete additive subgroup of $\R^n$. Equivalently, given linearly independent vectors $\mathbf{b}_1, \ldots, \mathbf{b}_k \in \R^n$ (where $k \leq n$), the lattice generated by these vectors is:
\[
\mathcal{L}(\mathbf{b}_1, \ldots, \mathbf{b}_k) = \left\{ \sum_{i=1}^{k} z_i \mathbf{b}_i : z_i \in \Z \right\}
\]
The vectors $\mathbf{b}_1, \ldots, \mathbf{b}_k$ form a \emph{basis} of the lattice. If $k = n$, the lattice is \emph{full-rank}.
\end{definition}

\placeholder{0.7\textwidth}{3D visualization of a lattice showing basis vectors, lattice points, and the fundamental domain}

\begin{definition}[Fundamental Domain]
The \emph{fundamental domain} (or fundamental parallelepiped) of a lattice $\mathcal{L}$ with basis $\mathbf{B} = [\mathbf{b}_1 | \cdots | \mathbf{b}_n]$ is:
\[
\mathcal{P}(\mathbf{B}) = \left\{ \sum_{i=1}^{n} x_i \mathbf{b}_i : x_i \in [0, 1) \right\}
\]
\end{definition}

\begin{definition}[Determinant of a Lattice]
The \emph{determinant} (or volume) of an $n$-dimensional lattice $\mathcal{L}$ with basis matrix $\mathbf{B}$ is:
\[
\det(\mathcal{L}) = |\det(\mathbf{B})| = \text{vol}(\mathcal{P}(\mathbf{B}))
\]
This value is independent of the choice of basis.
\end{definition}

\begin{definition}[Dual Lattice]
The \emph{dual lattice} of $\mathcal{L}$ is:
\[
\mathcal{L}^* = \{ \mathbf{y} \in \R^n : \langle \mathbf{y}, \mathbf{x} \rangle \in \Z \text{ for all } \mathbf{x} \in \mathcal{L} \}
\]
If $\mathbf{B}$ is a basis for $\mathcal{L}$, then $(\mathbf{B}^{-1})^T$ is a basis for $\mathcal{L}^*$.
\end{definition}

\subsection{Successive Minima and the Gaussian Heuristic}
\label{subsec:minima-gaussian}

\begin{definition}[Successive Minima]
For a lattice $\mathcal{L} \subset \R^n$, the $i$-th successive minimum $\lambda_i(\mathcal{L})$ is the smallest radius $r$ such that $\mathcal{L}$ contains $i$ linearly independent vectors of length at most $r$:
\[
\lambda_i(\mathcal{L}) = \min \{ r : \dim(\text{span}(\mathcal{L} \cap \bar{B}(0, r))) \geq i \}
\]
where $\bar{B}(0, r)$ is the closed ball of radius $r$ centered at the origin.
\end{definition}

\begin{theorem}[Minkowski's First Theorem]
For any $n$-dimensional lattice $\mathcal{L}$:
\[
\lambda_1(\mathcal{L}) \leq \sqrt{n} \cdot \det(\mathcal{L})^{1/n}
\]
\end{theorem}

\begin{definition}[Gaussian Heuristic]
For a ``random'' $n$-dimensional lattice $\mathcal{L}$, the Gaussian heuristic predicts:
\[
\lambda_1(\mathcal{L}) \approx \sqrt{\frac{n}{2\pi e}} \cdot \det(\mathcal{L})^{1/n}
\]
This heuristic is empirically accurate for most lattices encountered in cryptography.
\end{definition}

\subsection{Important Lattice Constructions}
\label{subsec:lattice-constructions}

\subsubsection{$q$-ary Lattices}

Cryptographic lattice problems are typically defined using $q$-ary lattices, which contain $q\Z^n$ as a sublattice.

\begin{definition}[$q$-ary Lattices]
Given a matrix $\mathbf{A} \in \Zq^{n \times m}$ and modulus $q$, define:
\begin{align}
\Lambda_q(\mathbf{A}) &= \{ \mathbf{y} \in \Z^m : \mathbf{y} = \mathbf{A}^T \mathbf{s} \mod q \text{ for some } \mathbf{s} \in \Zq^n \} \\
\Lambda_q^\perp(\mathbf{A}) &= \{ \mathbf{y} \in \Z^m : \mathbf{A} \mathbf{y} = \mathbf{0} \mod q \}
\end{align}
\end{definition}

\subsubsection{Ideal Lattices}

\begin{definition}[Ideal Lattice]
Let $R = \Z[x]/(f(x))$ be a polynomial ring. An \emph{ideal lattice} is a lattice corresponding to an ideal $I \subseteq R$ under the coefficient embedding:
\[
\sigma: R \rightarrow \Z^n, \quad a_0 + a_1 x + \cdots + a_{n-1} x^{n-1} \mapsto (a_0, a_1, \ldots, a_{n-1})
\]
\end{definition}

\subsubsection{Module Lattices}

\begin{definition}[Module Lattice]
A \emph{module lattice} is a lattice corresponding to a module $M \subseteq R^k$ where $R = \Z[x]/(f(x))$. Module lattices generalize both unstructured lattices ($k$ large, $n = 1$) and ideal lattices ($k = 1$).
\end{definition}

\infobox{The NIST standards use module lattices with small rank $k \in \{2, 3, 4\}$ over rings $R$ with $n = 256$. This provides a balance between the efficiency of ideal lattices and the security confidence of less-structured lattices.}

\section{Computational Lattice Problems}
\label{sec:lattice-problems}

\subsection{The Shortest Vector Problem (SVP)}
\label{subsec:svp}

\begin{definition}[Shortest Vector Problem (SVP)]
Given a basis $\mathbf{B}$ of a lattice $\mathcal{L}$, find a non-zero vector $\mathbf{v} \in \mathcal{L}$ such that $\|\mathbf{v}\| = \lambda_1(\mathcal{L})$.
\end{definition}

\begin{definition}[Approximate SVP ($\gamma$-SVP)]
Given a basis $\mathbf{B}$ of a lattice $\mathcal{L}$ and an approximation factor $\gamma \geq 1$, find a non-zero vector $\mathbf{v} \in \mathcal{L}$ such that $\|\mathbf{v}\| \leq \gamma \cdot \lambda_1(\mathcal{L})$.
\end{definition}

The exact SVP is known to be NP-hard under randomized reductions. For $\gamma = \poly(n)$, no polynomial-time quantum algorithms are known.

\subsection{The Closest Vector Problem (CVP)}
\label{subsec:cvp}

\begin{definition}[Closest Vector Problem (CVP)]
Given a basis $\mathbf{B}$ of a lattice $\mathcal{L}$ and a target vector $\mathbf{t} \in \R^n$, find a lattice vector $\mathbf{v} \in \mathcal{L}$ that minimizes $\|\mathbf{t} - \mathbf{v}\|$.
\end{definition}

\begin{definition}[Bounded Distance Decoding (BDD)]
Given a basis $\mathbf{B}$ of a lattice $\mathcal{L}$, a target $\mathbf{t}$, and a bound $d < \lambda_1(\mathcal{L})/2$, find $\mathbf{v} \in \mathcal{L}$ with $\|\mathbf{t} - \mathbf{v}\| \leq d$.
\end{definition}

CVP is at least as hard as SVP, and the BDD variant is the decryption problem in many lattice-based encryption schemes.

\subsection{Learning With Errors (LWE)}
\label{subsec:lwe-detail}

The LWE problem, introduced by Regev in 2005, is the foundation of modern lattice-based cryptography.

\begin{definition}[LWE Distribution]
For security parameter $n$, modulus $q$, and error distribution $\chi$ over $\Z$, the LWE distribution $A_{s,\chi}$ for secret $\mathbf{s} \in \Zq^n$ produces samples $(\mathbf{a}, b) \in \Zq^n \times \Zq$ where:
\begin{itemize}
    \item $\mathbf{a} \getsr \Zq^n$ is uniformly random
    \item $e \gets \chi$
    \item $b = \langle \mathbf{a}, \mathbf{s} \rangle + e \mod q$
\end{itemize}
\end{definition}

\begin{definition}[Search-LWE]
Given $m$ independent samples from $A_{s,\chi}$, find $\mathbf{s}$.
\end{definition}

\begin{definition}[Decision-LWE]
Distinguish between $m$ samples from $A_{s,\chi}$ and $m$ samples from the uniform distribution over $\Zq^n \times \Zq$.
\end{definition}

\begin{theorem}[Regev 2005]
For appropriate parameter choices, solving (Decision-)LWE is at least as hard as solving $\gamma$-SVP on arbitrary $n$-dimensional lattices in the worst case, for $\gamma = \tilde{O}(n \cdot q / \alpha)$ where $\alpha$ parameterizes the error distribution.
\end{theorem}

\subsubsection{Error Distributions}

\begin{definition}[Discrete Gaussian Distribution]
The discrete Gaussian distribution $D_{\Z, \sigma}$ over the integers with parameter $\sigma > 0$ assigns probability proportional to $\exp(-x^2 / (2\sigma^2))$ to each integer $x$.
\end{definition}

\begin{definition}[Centered Binomial Distribution]
The centered binomial distribution $\beta_\eta$ samples $a_1, \ldots, a_\eta, b_1, \ldots, b_\eta \getsr \{0, 1\}$ and outputs $\sum_{i=1}^{\eta} (a_i - b_i)$. The result is in $\{-\eta, \ldots, \eta\}$ with variance $\eta/2$.
\end{definition}

\infobox{Kyber/ML-KEM uses the centered binomial distribution $\beta_\eta$ with $\eta \in \{2, 3\}$ because it is easy to sample (just XOR random bits) and has good security properties, unlike Gaussian sampling which is complex to implement securely.}

\begin{table}[H]
\centering
\caption{LWE parameters in NIST standards}
\label{tab:lwe-params}
\begin{tabular}{lcccccc}
\toprule
\textbf{Scheme} & $n$ & $k$ & $q$ & \textbf{Error Dist.} & $\eta$ & \textbf{Security} \\
\midrule
ML-KEM-512 & 256 & 2 & 3329 & $\beta_3$ & 3 & 128-bit \\
ML-KEM-768 & 256 & 3 & 3329 & $\beta_2$ & 2 & 192-bit \\
ML-KEM-1024 & 256 & 4 & 3329 & $\beta_2$ & 2 & 256-bit \\
ML-DSA-44 & 256 & 4$\times$4 & 8380417 & Uniform & --- & 128-bit \\
ML-DSA-65 & 256 & 6$\times$5 & 8380417 & Uniform & --- & 192-bit \\
ML-DSA-87 & 256 & 8$\times$7 & 8380417 & Uniform & --- & 256-bit \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Ring-LWE and Module-LWE}
\label{subsec:ring-module-lwe}

\begin{definition}[Ring-LWE]
Let $R = \Z[x]/(x^n + 1)$ and $R_q = R/qR$. The Ring-LWE problem is the LWE problem where $\mathbf{a}, \mathbf{s}, e$ are elements of $R_q$ (polynomials) rather than vectors.
\end{definition}

\begin{definition}[Module-LWE]
Let $R_q = \Zq[x]/(x^n + 1)$. The Module-LWE problem uses:
\begin{itemize}
    \item Public matrix $\mathbf{A} \in R_q^{k \times k}$ (matrix of polynomials)
    \item Secret vector $\mathbf{s} \in R_q^k$
    \item Error vector $\mathbf{e} \in R_q^k$
    \item Public value $\mathbf{b} = \mathbf{A} \mathbf{s} + \mathbf{e} \in R_q^k$
\end{itemize}
\end{definition}

The module structure provides a security/efficiency tradeoff:
\begin{itemize}
    \item \textbf{LWE} ($k$ large, $n = 1$): Highest confidence in hardness, least efficient
    \item \textbf{Ring-LWE} ($k = 1$, $n$ large): Most efficient, concerns about ring structure
    \item \textbf{Module-LWE} ($k$ and $n$ both moderate): Balance of efficiency and security confidence
\end{itemize}

\subsection{Short Integer Solution (SIS)}
\label{subsec:sis-detail}

\begin{definition}[SIS Problem]
Given a uniformly random matrix $\mathbf{A} \in \Zq^{n \times m}$ and a bound $\beta$, find a non-zero vector $\mathbf{z} \in \Z^m$ such that:
\[
\mathbf{A} \mathbf{z} = \mathbf{0} \mod q \quad \text{and} \quad \|\mathbf{z}\| \leq \beta
\]
\end{definition}

\begin{definition}[Inhomogeneous SIS (ISIS)]
Given $\mathbf{A} \in \Zq^{n \times m}$, a target $\mathbf{u} \in \Zq^n$, and bound $\beta$, find $\mathbf{z} \in \Z^m$ with $\mathbf{A} \mathbf{z} = \mathbf{u} \mod q$ and $\|\mathbf{z}\| \leq \beta$.
\end{definition}

SIS is dual to LWE and forms the security basis for lattice-based signatures like Dilithium/ML-DSA.

\begin{theorem}[Ajtai 1996]
For appropriate parameters, solving SIS is at least as hard as solving $\gamma$-SVP on worst-case lattices.
\end{theorem}

\section{Algorithms for Lattice Problems}
\label{sec:lattice-algorithms}

\subsection{Lattice Reduction}
\label{subsec:lattice-reduction}

Lattice reduction algorithms find short vectors by transforming a basis into one with shorter, more orthogonal vectors.

\begin{definition}[LLL Reduction]
A basis $\mathbf{B} = [\mathbf{b}_1 | \cdots | \mathbf{b}_n]$ is \emph{LLL-reduced} with parameter $\delta \in (1/4, 1)$ if:
\begin{enumerate}
    \item Size-reduced: $|\mu_{i,j}| \leq 1/2$ for all $i > j$, where $\mu_{i,j} = \frac{\langle \mathbf{b}_i, \mathbf{b}_j^* \rangle}{\|\mathbf{b}_j^*\|^2}$
    \item Lovász condition: $\delta \|\mathbf{b}_i^*\|^2 \leq \|\mathbf{b}_{i+1}^*\|^2 + \mu_{i+1,i}^2 \|\mathbf{b}_i^*\|^2$ for all $i$
\end{enumerate}
where $\mathbf{b}_i^*$ are the Gram-Schmidt orthogonalized vectors.
\end{definition}

\begin{theorem}[LLL Guarantee]
For an LLL-reduced basis with $\delta = 3/4$, the shortest basis vector satisfies:
\[
\|\mathbf{b}_1\| \leq 2^{(n-1)/2} \cdot \lambda_1(\mathcal{L})
\]
\end{theorem}

The LLL algorithm runs in polynomial time $O(n^5 d \log^3 B)$ where $B$ bounds the entries of the input basis.

\begin{definition}[BKZ Reduction]
Block Korkine-Zolotarev (BKZ) with block size $\beta$ generalizes LLL by solving SVP in blocks of dimension $\beta$. Larger block sizes yield shorter vectors but increase runtime exponentially in $\beta$.
\end{definition}

\begin{table}[H]
\centering
\caption{Comparison of lattice reduction algorithms}
\label{tab:reduction-comparison}
\begin{tabular}{lccc}
\toprule
\textbf{Algorithm} & \textbf{Approximation Factor} & \textbf{Time Complexity} & \textbf{Space} \\
\midrule
LLL & $2^{O(n)}$ & $\poly(n)$ & $\poly(n)$ \\
BKZ-$\beta$ & $2^{O(n/\beta)}$ & $2^{O(\beta)} \cdot \poly(n)$ & $2^{O(\beta)}$ \\
BKZ 2.0 & $2^{O(n/\beta)}$ & $2^{O(\beta)} \cdot \poly(n)$ & $2^{O(\beta)}$ \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Sieving Algorithms}
\label{subsec:sieving}

\begin{definition}[Lattice Sieving]
Sieving algorithms maintain a list of lattice vectors and repeatedly combine pairs to create shorter vectors. The asymptotically fastest sieving algorithms achieve time $2^{0.292n + o(n)}$ for solving SVP.
\end{definition}

\subsection{Security Estimation}
\label{subsec:security-estimation}

The security of lattice-based schemes is estimated using the \emph{Core-SVP hardness model}:

\begin{definition}[Core-SVP Hardness]
For parameters $(n, q, \chi)$, the Core-SVP hardness is the cost of running BKZ with sufficient block size $\beta$ to solve the underlying lattice problem. The required $\beta$ is estimated using the Gaussian heuristic and the success condition of BKZ.
\end{definition}

\begin{table}[H]
\centering
\caption{Estimated security levels for NIST PQC standards}
\label{tab:security-estimates}
\begin{tabular}{lcccc}
\toprule
\textbf{Scheme} & \textbf{Classical (bits)} & \textbf{Quantum (bits)} & \textbf{NIST Level} \\
\midrule
ML-KEM-512 & 118 & 107 & 1 (AES-128) \\
ML-KEM-768 & 183 & 166 & 3 (AES-192) \\
ML-KEM-1024 & 256 & 232 & 5 (AES-256) \\
ML-DSA-44 & 128 & 115 & 2 \\
ML-DSA-65 & 192 & 175 & 3 \\
ML-DSA-87 & 256 & 234 & 5 \\
\bottomrule
\end{tabular}
\end{table}

\section{Hash Functions in PQC}
\label{sec:hash-functions}

\subsection{SHA-3 and SHAKE}
\label{subsec:sha3-shake}

The NIST PQC standards rely heavily on the SHA-3 family of hash functions, particularly the extendable-output functions (XOFs).

\begin{definition}[Extendable-Output Function (XOF)]
An XOF is a function $H: \{0,1\}^* \rightarrow \{0,1\}^\infty$ that can produce an arbitrarily long output. SHAKE128 and SHAKE256 are XOFs based on the Keccak permutation.
\end{definition}

\begin{table}[H]
\centering
\caption{Hash functions used in NIST PQC standards}
\label{tab:hash-functions}
\begin{tabular}{lll}
\toprule
\textbf{Function} & \textbf{Security Level} & \textbf{Use in PQC} \\
\midrule
SHA3-256 & 128-bit collision & Key derivation, hashing \\
SHA3-512 & 256-bit collision & High-security applications \\
SHAKE128 & 128-bit security & Matrix expansion, sampling \\
SHAKE256 & 256-bit security & Signatures, high-security sampling \\
\bottomrule
\end{tabular}
\end{table}

In ML-KEM and ML-DSA, SHAKE is used to:
\begin{itemize}
    \item Expand a seed into the public matrix $\mathbf{A}$
    \item Sample secret and error polynomials from seeds
    \item Derive shared secrets from encapsulation outputs
    \item Generate deterministic randomness for signing
\end{itemize}

\subsection{Hashing in Embedded Systems}
\label{subsec:hash-embedded}

SHA-3/SHAKE operations often dominate the runtime of PQC implementations on constrained devices. Optimizations include:

\begin{itemize}
    \item Hardware acceleration (available on some Cortex-M series)
    \item Assembly-optimized Keccak permutation
    \item Lazy evaluation (compute only needed output bytes)
    \item Using AES-based variants where AES acceleration is available
\end{itemize}

\begin{table}[H]
\centering
\caption{Keccak/SHA-3 performance on ARM Cortex-M4 (cycles per byte)}
\label{tab:keccak-performance}
\begin{tabular}{lcc}
\toprule
\textbf{Implementation} & \textbf{Absorb (cpb)} & \textbf{Squeeze (cpb)} \\
\midrule
Reference C & $\sim$45 & $\sim$45 \\
Optimized C & $\sim$25 & $\sim$25 \\
Assembly (ARMv7-M) & $\sim$12 & $\sim$12 \\
\bottomrule
\end{tabular}
\end{table}

\section{Chapter Summary}
\label{sec:ch2-summary}

This chapter established the mathematical foundations for understanding post-quantum cryptography:

\begin{itemize}
    \item \textbf{Algebraic structures}: Polynomial rings $R_q = \Zq[x]/(x^n+1)$ enable efficient operations
    \item \textbf{Number Theoretic Transform}: Reduces polynomial multiplication from $O(n^2)$ to $O(n \log n)$
    \item \textbf{Lattices}: Discrete additive subgroups of $\R^n$ with geometric properties
    \item \textbf{LWE problem}: Finding a secret given noisy linear equations; foundation of Kyber/ML-KEM
    \item \textbf{SIS problem}: Finding short vectors in the kernel of a matrix; foundation of signatures
    \item \textbf{Module structure}: Provides balance between efficiency and security confidence
    \item \textbf{Lattice reduction}: BKZ algorithm determines concrete security levels
    \item \textbf{Hash functions}: SHA-3/SHAKE are critical components, often performance bottlenecks
\end{itemize}

\infobox{The mathematical foundations presented here are essential for understanding security proofs and making informed parameter choices. However, using standardized implementations with vetted parameters is strongly recommended for practical deployments.}

% End of Chapter 2

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% CHAPTER 3: KEY ENCAPSULATION MECHANISMS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Key Encapsulation Mechanisms: ML-KEM (Kyber)}
\label{ch:kem}

Key Encapsulation Mechanisms (KEMs) are fundamental cryptographic primitives that enable secure key exchange between parties. This chapter provides comprehensive coverage of ML-KEM, the NIST-standardized lattice-based KEM derived from the Kyber submission.

\section{Introduction to Key Encapsulation}
\label{sec:kem-intro}

\subsection{From Key Exchange to Key Encapsulation}
\label{subsec:ke-to-kem}

Traditional key exchange protocols like Diffie-Hellman allow two parties to establish a shared secret over an insecure channel. However, these protocols are vulnerable to quantum attacks via Shor's algorithm. KEMs provide an alternative paradigm better suited to the post-quantum setting.

\begin{definition}[Key Encapsulation Mechanism]
A Key Encapsulation Mechanism consists of three algorithms:
\begin{itemize}
    \item $\KeyGen() \rightarrow (pk, sk)$: Generate a public/private key pair
    \item $\Encaps(pk) \rightarrow (ct, K)$: Using the public key, generate a ciphertext $ct$ and shared secret $K$
    \item $\Decaps(sk, ct) \rightarrow K$ or $\bot$: Using the private key, recover $K$ from $ct$, or output failure
\end{itemize}
\end{definition}

\begin{definition}[IND-CCA2 Security]
A KEM is \emph{IND-CCA2 secure} (indistinguishable under adaptive chosen-ciphertext attack) if no efficient adversary with access to a decapsulation oracle can distinguish the encapsulated key from a random key, except with negligible advantage.
\end{definition}

\placeholder{0.8\textwidth}{Diagram showing KEM usage in establishing a secure channel: KeyGen, Encaps, Decaps flow between Alice and Bob}

\subsection{KEMs vs. Public-Key Encryption}
\label{subsec:kem-vs-pke}

While PKE directly encrypts messages, KEMs generate random shared secrets that are then used with symmetric encryption. This separation has several advantages:

\begin{itemize}
    \item \textbf{Simplicity}: KEM security definitions are cleaner than PKE
    \item \textbf{Efficiency}: Symmetric encryption handles bulk data more efficiently
    \item \textbf{Flexibility}: The shared secret can derive multiple keys (encryption, MAC, etc.)
    \item \textbf{Composability}: KEMs compose well in hybrid constructions
\end{itemize}

\section{ML-KEM Overview}
\label{sec:mlkem-overview}

ML-KEM (Module-Lattice-Based Key-Encapsulation Mechanism) is specified in FIPS 203, published August 2024. It is derived from CRYSTALS-Kyber, one of the most extensively analyzed lattice-based schemes.

\subsection{Design Philosophy}
\label{subsec:mlkem-philosophy}

ML-KEM follows a modular design:
\begin{enumerate}
    \item \textbf{K-PKE}: A CPA-secure public-key encryption scheme based on Module-LWE
    \item \textbf{KEM Transform}: The Fujisaki-Okamoto transform converts K-PKE to CCA-secure KEM
\end{enumerate}

\begin{figure}[H]
\centering
\begin{tikzpicture}[
    box/.style={rectangle, draw, minimum width=3cm, minimum height=1cm, align=center},
    arrow/.style={->, thick}
]
    \node[box] (kpke) {K-PKE\\(CPA-secure)};
    \node[box, right=2cm of kpke] (kem) {ML-KEM\\(CCA-secure)};
    \node[above=0.5cm of kpke] {Module-LWE};
    \draw[arrow] (kpke) -- node[above] {FO Transform} (kem);
\end{tikzpicture}
\caption{ML-KEM construction from K-PKE via Fujisaki-Okamoto transform}
\label{fig:mlkem-construction}
\end{figure}

\subsection{Parameter Sets}
\label{subsec:mlkem-params}

ML-KEM defines three parameter sets targeting different security levels:

\begin{table}[H]
\centering
\caption{ML-KEM parameter sets (FIPS 203)}
\label{tab:mlkem-params}
\begin{tabular}{lccccccc}
\toprule
\textbf{Parameter} & \textbf{ML-KEM-512} & \textbf{ML-KEM-768} & \textbf{ML-KEM-1024} \\
\midrule
NIST Security Level & 1 & 3 & 5 \\
Equivalent Classical & AES-128 & AES-192 & AES-256 \\
Module rank $k$ & 2 & 3 & 4 \\
Polynomial degree $n$ & 256 & 256 & 256 \\
Modulus $q$ & 3329 & 3329 & 3329 \\
Error distribution & $\beta_3$ & $\beta_2$ & $\beta_2$ \\
$(d_u, d_v)$ compression & (10, 4) & (10, 4) & (11, 5) \\
\midrule
Public key size & 800 B & 1,184 B & 1,568 B \\
Secret key size & 1,632 B & 2,400 B & 3,168 B \\
Ciphertext size & 768 B & 1,088 B & 1,568 B \\
Shared secret size & 32 B & 32 B & 32 B \\
\bottomrule
\end{tabular}
\end{table}

\infobox{The modulus $q = 3329$ is chosen because: (1) it is prime, (2) $q \equiv 1 \pmod{256}$, enabling NTT with $n = 256$, and (3) it fits in 12 bits, allowing efficient representation.}

\section{ML-KEM Algorithms in Detail}
\label{sec:mlkem-algorithms}

\subsection{Key Generation}
\label{subsec:mlkem-keygen}

\begin{algorithm}[H]
\caption{ML-KEM.KeyGen()}
\label{alg:mlkem-keygen}
\begin{algorithmic}[1]
\Require Security parameter (implicit in parameter set)
\Ensure Public key $pk$, Secret key $sk$
\State $d \getsr \{0,1\}^{256}$ \Comment{Random seed}
\State $(\rho, \sigma) \gets G(d)$ \Comment{$G$: SHA3-512}
\State $\hat{\mathbf{A}} \gets \text{Sam}(\rho)$ \Comment{Generate matrix in NTT domain}
\For{$i = 0$ to $k-1$}
    \State $\mathbf{s}[i] \gets \text{CBD}_\eta(\text{PRF}(\sigma, i))$ \Comment{Sample secret}
    \State $\mathbf{e}[i] \gets \text{CBD}_\eta(\text{PRF}(\sigma, k+i))$ \Comment{Sample error}
\EndFor
\State $\hat{\mathbf{s}} \gets \text{NTT}(\mathbf{s})$
\State $\hat{\mathbf{e}} \gets \text{NTT}(\mathbf{e})$
\State $\hat{\mathbf{t}} \gets \hat{\mathbf{A}} \circ \hat{\mathbf{s}} + \hat{\mathbf{e}}$ \Comment{$\mathbf{t} = \mathbf{A}\mathbf{s} + \mathbf{e}$}
\State $pk \gets (\text{Encode}(\hat{\mathbf{t}}), \rho)$
\State $sk \gets (\text{Encode}(\hat{\mathbf{s}}), pk, H(pk), z)$ \Comment{$z \getsr \{0,1\}^{256}$}
\State \Return $(pk, sk)$
\end{algorithmic}
\end{algorithm}

The key generation algorithm:
\begin{enumerate}
    \item Generates the public matrix $\mathbf{A}$ from seed $\rho$ (saving bandwidth)
    \item Samples secret $\mathbf{s}$ and error $\mathbf{e}$ from centered binomial distribution
    \item Computes public key as $\mathbf{t} = \mathbf{A}\mathbf{s} + \mathbf{e}$
    \item Stores additional data in secret key for CCA security
\end{enumerate}

\subsection{Encapsulation}
\label{subsec:mlkem-encaps}

\begin{algorithm}[H]
\caption{ML-KEM.Encaps($pk$)}
\label{alg:mlkem-encaps}
\begin{algorithmic}[1]
\Require Public key $pk = (\hat{\mathbf{t}}, \rho)$
\Ensure Ciphertext $ct$, Shared secret $K$
\State $m \getsr \{0,1\}^{256}$ \Comment{Random message}
\State $(K', r) \gets G(m \| H(pk))$ \Comment{Derive key and randomness}
\State $\hat{\mathbf{A}} \gets \text{Sam}(\rho)$ \Comment{Regenerate matrix}
\For{$i = 0$ to $k-1$}
    \State $\mathbf{r}[i] \gets \text{CBD}_\eta(\text{PRF}(r, i))$
    \State $\mathbf{e}_1[i] \gets \text{CBD}_{\eta_2}(\text{PRF}(r, k+i))$
\EndFor
\State $e_2 \gets \text{CBD}_{\eta_2}(\text{PRF}(r, 2k))$
\State $\hat{\mathbf{r}} \gets \text{NTT}(\mathbf{r})$
\State $\mathbf{u} \gets \text{NTT}^{-1}(\hat{\mathbf{A}}^T \circ \hat{\mathbf{r}}) + \mathbf{e}_1$
\State $v \gets \text{NTT}^{-1}(\hat{\mathbf{t}}^T \circ \hat{\mathbf{r}}) + e_2 + \text{Decompress}_q(m, 1)$
\State $c_1 \gets \text{Compress}_q(\mathbf{u}, d_u)$
\State $c_2 \gets \text{Compress}_q(v, d_v)$
\State $ct \gets (c_1, c_2)$
\State $K \gets \text{KDF}(K' \| H(ct))$
\State \Return $(ct, K)$
\end{algorithmic}
\end{algorithm}

\subsection{Decapsulation}
\label{subsec:mlkem-decaps}

\begin{algorithm}[H]
\caption{ML-KEM.Decaps($sk$, $ct$)}
\label{alg:mlkem-decaps}
\begin{algorithmic}[1]
\Require Secret key $sk = (\hat{\mathbf{s}}, pk, h, z)$, Ciphertext $ct = (c_1, c_2)$
\Ensure Shared secret $K$
\State $\mathbf{u} \gets \text{Decompress}_q(c_1, d_u)$
\State $v \gets \text{Decompress}_q(c_2, d_v)$
\State $w \gets v - \text{NTT}^{-1}(\hat{\mathbf{s}}^T \circ \text{NTT}(\mathbf{u}))$
\State $m' \gets \text{Compress}_q(w, 1)$ \Comment{Recover message}
\State $(K', r') \gets G(m' \| h)$
\State $ct' \gets \text{ML-KEM.Encaps\_inner}(pk, m', r')$ \Comment{Re-encrypt}
\If{$ct = ct'$} \Comment{Implicit rejection}
    \State $K \gets \text{KDF}(K' \| H(ct))$
\Else
    \State $K \gets \text{KDF}(z \| H(ct))$ \Comment{Return pseudorandom value}
\EndIf
\State \Return $K$
\end{algorithmic}
\end{algorithm}

\warningbox{The implicit rejection mechanism is crucial for CCA security. If ciphertext validation fails, the algorithm returns a pseudorandom value derived from secret $z$ rather than an error, preventing chosen-ciphertext attacks.}

\subsection{Core Operations}
\label{subsec:mlkem-operations}

\subsubsection{Compression and Decompression}

To reduce ciphertext size, ML-KEM compresses polynomial coefficients:

\begin{definition}[Compression]
For $x \in \Zq$ and $d < \lceil \log_2 q \rceil$:
\[
\text{Compress}_q(x, d) = \left\lfloor \frac{2^d}{q} \cdot x \right\rceil \mod 2^d
\]
\[
\text{Decompress}_q(x, d) = \left\lfloor \frac{q}{2^d} \cdot x \right\rceil
\]
\end{definition}

Compression introduces a small additional error bounded by $\lfloor q/2^{d+1} \rfloor$.

\subsubsection{Centered Binomial Distribution Sampling}

\begin{algorithm}[H]
\caption{CBD$_\eta$(bytes)}
\label{alg:cbd}
\begin{algorithmic}[1]
\Require $64\eta$ bytes of randomness
\Ensure Polynomial with coefficients in $\{-\eta, \ldots, \eta\}$
\State Convert bytes to bits $b_0, b_1, \ldots, b_{512\eta - 1}$
\For{$i = 0$ to $255$}
    \State $a \gets \sum_{j=0}^{\eta-1} b_{2i\eta + j}$
    \State $b \gets \sum_{j=0}^{\eta-1} b_{2i\eta + \eta + j}$
    \State $f[i] \gets a - b$
\EndFor
\State \Return $f$
\end{algorithmic}
\end{algorithm}

\subsubsection{Matrix Generation from Seed}

The public matrix $\mathbf{A}$ is generated deterministically from seed $\rho$:

\begin{lstlisting}[language=C, caption={Matrix sampling (conceptual)}, label={lst:matrix-sample}]
void sample_matrix(poly A[K][K], const uint8_t rho[32]) {
    for (int i = 0; i < K; i++) {
        for (int j = 0; j < K; j++) {
            uint8_t seed[34];
            memcpy(seed, rho, 32);
            seed[32] = j;  // Column index
            seed[33] = i;  // Row index
            shake128_absorb_once(seed, 34);
            sample_ntt_poly(&A[i][j]);  // Rejection sampling
        }
    }
}
\end{lstlisting}

\section{Security Analysis}
\label{sec:mlkem-security}

\subsection{Hardness Assumptions}
\label{subsec:mlkem-hardness}

ML-KEM security relies on two computational assumptions:

\begin{theorem}[ML-KEM Security]
If the Module-LWE problem is hard, then ML-KEM is IND-CCA2 secure in the random oracle model.
\end{theorem}

The security reduction proceeds as:
\[
\text{IND-CCA2 (ML-KEM)} \Leftarrow \text{IND-CPA (K-PKE)} \Leftarrow \text{MLWE}_{n,k,q,\eta}
\]

\subsection{Concrete Security Estimates}
\label{subsec:mlkem-concrete}

Security is estimated against the best-known attacks:

\begin{table}[H]
\centering
\caption{ML-KEM security estimates (Core-SVP model)}
\label{tab:mlkem-security}
\begin{tabular}{lcccc}
\toprule
\textbf{Parameter Set} & \textbf{Classical} & \textbf{Quantum} & \textbf{Target} \\
\midrule
ML-KEM-512 & 118 bits & 107 bits & 128 bits \\
ML-KEM-768 & 183 bits & 166 bits & 192 bits \\
ML-KEM-1024 & 256 bits & 232 bits & 256 bits \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Known Attack Vectors}
\label{subsec:mlkem-attacks}

\subsubsection{Lattice Attacks}
The primary attack uses BKZ lattice reduction. The primal attack embeds the LWE instance into a unique-SVP problem; the dual attack targets the SIS structure.

\subsubsection{Side-Channel Attacks}
ML-KEM implementations must protect against:
\begin{itemize}
    \item \textbf{Timing attacks}: All operations must be constant-time
    \item \textbf{Power analysis}: Particularly during NTT and sampling
    \item \textbf{Fault attacks}: The FO transform provides some protection
\end{itemize}

\subsubsection{Multi-Target Attacks}
With many public keys, attackers may gain advantages. ML-KEM's parameters account for multi-target scenarios.

\section{Implementation Considerations}
\label{sec:mlkem-implementation}

\subsection{Memory Layout}
\label{subsec:mlkem-memory}

Efficient memory management is crucial for constrained devices:

\begin{table}[H]
\centering
\caption{ML-KEM-768 memory requirements}
\label{tab:mlkem-memory}
\begin{tabular}{lcc}
\toprule
\textbf{Data Structure} & \textbf{Size} & \textbf{Notes} \\
\midrule
Single polynomial (coefficients) & 512 B & 256 $\times$ 16-bit \\
Single polynomial (NTT) & 512 B & 256 $\times$ 16-bit \\
Matrix $\mathbf{A}$ (full) & 4,608 B & $3 \times 3 \times 512$ B \\
Matrix $\mathbf{A}$ (on-the-fly) & 512 B & Generate per-column \\
Public key & 1,184 B & Compressed \\
Secret key & 2,400 B & Includes $pk$ \\
Ciphertext & 1,088 B & Compressed \\
\midrule
KeyGen stack (optimized) & $\sim$2,400 B & \\
Encaps stack (optimized) & $\sim$2,400 B & \\
Decaps stack (optimized) & $\sim$2,600 B & \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Optimization Strategies}
\label{subsec:mlkem-optimization}

\subsubsection{NTT Optimization}

The NTT is performance-critical. Key optimizations include:

\begin{itemize}
    \item \textbf{Montgomery multiplication}: Avoid expensive modular reduction
    \item \textbf{Barrett reduction}: For final coefficient reduction
    \item \textbf{Precomputed twiddle factors}: Store $\omega^i$ values
    \item \textbf{In-place computation}: Minimize memory usage
    \item \textbf{Loop unrolling}: Reduce branch overhead
\end{itemize}

\begin{lstlisting}[language=C, caption={Montgomery reduction for $q = 3329$}, label={lst:montgomery}]
// Montgomery reduction: compute a * R^{-1} mod q
// where R = 2^16 and q = 3329
int16_t montgomery_reduce(int32_t a) {
    int16_t t;
    t = (int16_t)a * QINV;  // QINV = -3327 mod 2^16
    t = (a - (int32_t)t * Q) >> 16;
    return t;
}
\end{lstlisting}

\subsubsection{Memory-Time Tradeoffs}

\begin{table}[H]
\centering
\caption{Implementation variants and their tradeoffs}
\label{tab:mlkem-tradeoffs}
\begin{tabular}{lccc}
\toprule
\textbf{Variant} & \textbf{Speed} & \textbf{Stack} & \textbf{Code Size} \\
\midrule
Reference (clean) & Baseline & High & Small \\
Speed-optimized (m4fspeed) & $\sim$2$\times$ faster & High & Large \\
Stack-optimized (m4fstack) & $\sim$1.5$\times$ faster & Low & Medium \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Constant-Time Implementation}
\label{subsec:mlkem-constant-time}

All operations must execute in constant time to prevent timing side-channels:

\begin{lstlisting}[language=C, caption={Constant-time conditional move}, label={lst:cmov}]
// Constant-time conditional move: r = (b ? a : r)
void cmov(uint8_t *r, const uint8_t *a, size_t len, uint8_t b) {
    b = -b;  // 0x00 or 0xFF
    for (size_t i = 0; i < len; i++) {
        r[i] ^= b & (r[i] ^ a[i]);
    }
}

// Constant-time comparison: returns 0 if equal
int verify(const uint8_t *a, const uint8_t *b, size_t len) {
    uint8_t r = 0;
    for (size_t i = 0; i < len; i++) {
        r |= a[i] ^ b[i];
    }
    return (-(int)r) >> 31;  // 0 or -1
}
\end{lstlisting}

\section{Performance Benchmarks}
\label{sec:mlkem-benchmarks}

\subsection{ARM Cortex-M4 Benchmarks}
\label{subsec:mlkem-m4-bench}

The following benchmarks are from the pqm4 project on the NUCLEO-L4R5ZI board (STM32L4R5ZI, Cortex-M4 @ 80 MHz):

\begin{table}[H]
\centering
\caption{ML-KEM performance on ARM Cortex-M4 (cycles)}
\label{tab:mlkem-m4-cycles}
\begin{tabular}{llrrr}
\toprule
\textbf{Scheme} & \textbf{Variant} & \textbf{KeyGen} & \textbf{Encaps} & \textbf{Decaps} \\
\midrule
\multirow{3}{*}{ML-KEM-512} 
    & clean & 519,853 & 666,050 & 715,491 \\
    & m4fspeed & 392,295 & 391,355 & 428,037 \\
    & m4fstack & 415,631 & 532,478 & 575,227 \\
\midrule
\multirow{3}{*}{ML-KEM-768}
    & clean & 867,222 & 1,085,400 & 1,159,285 \\
    & m4fspeed & 642,163 & 659,069 & 708,044 \\
    & m4fstack & 676,896 & 854,339 & 912,308 \\
\midrule
\multirow{3}{*}{ML-KEM-1024}
    & clean & 1,302,069 & 1,578,656 & 1,686,574 \\
    & m4fspeed & 1,019,877 & 1,031,009 & 1,094,181 \\
    & m4fstack & 1,076,065 & 1,299,949 & 1,380,086 \\
\bottomrule
\end{tabular}
\end{table}

\begin{table}[H]
\centering
\caption{ML-KEM stack usage on ARM Cortex-M4 (bytes)}
\label{tab:mlkem-m4-stack}
\begin{tabular}{llrrr}
\toprule
\textbf{Scheme} & \textbf{Variant} & \textbf{KeyGen} & \textbf{Encaps} & \textbf{Decaps} \\
\midrule
\multirow{3}{*}{ML-KEM-512}
    & clean & 2,896 & 3,936 & 4,288 \\
    & m4fspeed & 2,632 & 2,720 & 3,080 \\
    & m4fstack & 2,300 & 2,348 & 2,332 \\
\midrule
\multirow{3}{*}{ML-KEM-768}
    & clean & 3,920 & 4,448 & 4,800 \\
    & m4fspeed & 3,144 & 3,232 & 3,592 \\
    & m4fstack & 2,556 & 2,604 & 2,588 \\
\midrule
\multirow{3}{*}{ML-KEM-1024}
    & clean & 4,944 & 5,472 & 5,824 \\
    & m4fspeed & 3,656 & 3,744 & 4,104 \\
    & m4fstack & 2,812 & 2,860 & 2,844 \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Comparison with Classical Algorithms}
\label{subsec:mlkem-comparison}

\begin{table}[H]
\centering
\caption{ML-KEM vs. classical algorithms on Cortex-M4}
\label{tab:mlkem-vs-classical}
\begin{tabular}{lrrrr}
\toprule
\textbf{Algorithm} & \textbf{Security} & \textbf{KeyGen} & \textbf{Operation} & \textbf{Sizes (pk+ct)} \\
\midrule
ECDH P-256 & 128-bit & 1.4M & 1.4M & 64 + 64 B \\
X25519 & 128-bit & 0.8M & 0.8M & 32 + 32 B \\
RSA-2048 & 112-bit & 300M+ & 0.3M/30M & 256 + 256 B \\
\midrule
ML-KEM-512 & 128-bit (PQ) & 392K & 391K/428K & 800 + 768 B \\
ML-KEM-768 & 192-bit (PQ) & 642K & 659K/708K & 1,184 + 1,088 B \\
\bottomrule
\end{tabular}
\end{table}

\infobox{ML-KEM is \textbf{faster} than ECDH on Cortex-M4 while providing post-quantum security. The main cost is larger key and ciphertext sizes, which impacts bandwidth-constrained applications.}

\subsection{Desktop/Server Benchmarks}
\label{subsec:mlkem-desktop}

For comparison, here are benchmarks on an Intel Core i7-6600U (Skylake) with AVX2:

\begin{table}[H]
\centering
\caption{ML-KEM performance on x86-64 with AVX2 (cycles)}
\label{tab:mlkem-x86}
\begin{tabular}{lrrr}
\toprule
\textbf{Scheme} & \textbf{KeyGen} & \textbf{Encaps} & \textbf{Decaps} \\
\midrule
ML-KEM-512 & 29,000 & 37,000 & 32,000 \\
ML-KEM-768 & 48,000 & 58,000 & 52,000 \\
ML-KEM-1024 & 69,000 & 84,000 & 76,000 \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Hashing Overhead}
\label{subsec:mlkem-hashing}

A significant portion of ML-KEM runtime is spent in hash functions:

\begin{table}[H]
\centering
\caption{Percentage of cycles spent in SHA-3/SHAKE (Cortex-M4)}
\label{tab:mlkem-hash-overhead}
\begin{tabular}{lrrr}
\toprule
\textbf{Scheme} & \textbf{KeyGen} & \textbf{Encaps} & \textbf{Decaps} \\
\midrule
ML-KEM-512 & 42\% & 54\% & 51\% \\
ML-KEM-768 & 48\% & 57\% & 55\% \\
ML-KEM-1024 & 52\% & 60\% & 57\% \\
\bottomrule
\end{tabular}
\end{table}

\section{Code Examples}
\label{sec:mlkem-code}

\subsection{Using liboqs (C)}
\label{subsec:mlkem-liboqs}

\begin{lstlisting}[language=C, caption={ML-KEM key exchange using liboqs}, label={lst:mlkem-liboqs}]
#include <oqs/oqs.h>
#include <stdio.h>
#include <string.h>

int main() {
    OQS_KEM *kem = OQS_KEM_new(OQS_KEM_alg_ml_kem_768);
    if (kem == NULL) {
        printf("ML-KEM-768 not available\n");
        return 1;
    }
    
    // Allocate memory
    uint8_t *public_key = malloc(kem->length_public_key);
    uint8_t *secret_key = malloc(kem->length_secret_key);
    uint8_t *ciphertext = malloc(kem->length_ciphertext);
    uint8_t *shared_secret_e = malloc(kem->length_shared_secret);
    uint8_t *shared_secret_d = malloc(kem->length_shared_secret);
    
    // Key generation (performed by receiver)
    OQS_KEM_keypair(kem, public_key, secret_key);
    printf("Generated keypair: pk=%zu bytes, sk=%zu bytes\n",
           kem->length_public_key, kem->length_secret_key);
    
    // Encapsulation (performed by sender)
    OQS_KEM_encaps(kem, ciphertext, shared_secret_e, public_key);
    printf("Encapsulated: ct=%zu bytes, K=%zu bytes\n",
           kem->length_ciphertext, kem->length_shared_secret);
    
    // Decapsulation (performed by receiver)
    OQS_KEM_decaps(kem, shared_secret_d, ciphertext, secret_key);
    
    // Verify shared secrets match
    if (memcmp(shared_secret_e, shared_secret_d, 
               kem->length_shared_secret) == 0) {
        printf("Key exchange successful!\n");
    }
    
    // Cleanup
    OQS_MEM_secure_free(secret_key, kem->length_secret_key);
    OQS_MEM_secure_free(shared_secret_e, kem->length_shared_secret);
    OQS_MEM_secure_free(shared_secret_d, kem->length_shared_secret);
    free(public_key);
    free(ciphertext);
    OQS_KEM_free(kem);
    
    return 0;
}
\end{lstlisting}

\subsection{Using pqcrypto (Rust)}
\label{subsec:mlkem-rust}

\begin{lstlisting}[language=Rust, caption={ML-KEM key exchange in Rust}, label={lst:mlkem-rust}]
use pqcrypto_kyber::kyber768;
use pqcrypto_traits::kem::{PublicKey, SecretKey, Ciphertext, SharedSecret};

fn main() {
    // Key generation
    let (pk, sk) = kyber768::keypair();
    println!("Public key: {} bytes", pk.as_bytes().len());
    println!("Secret key: {} bytes", sk.as_bytes().len());
    
    // Encapsulation
    let (ss_sender, ct) = kyber768::encapsulate(&pk);
    println!("Ciphertext: {} bytes", ct.as_bytes().len());
    
    // Decapsulation
    let ss_receiver = kyber768::decapsulate(&ct, &sk);
    
    // Verify
    assert_eq!(ss_sender.as_bytes(), ss_receiver.as_bytes());
    println!("Shared secret established: {} bytes", 
             ss_sender.as_bytes().len());
}
\end{lstlisting}

\subsection{Using liboqs-python}
\label{subsec:mlkem-python}

\begin{lstlisting}[language=Python, caption={ML-KEM key exchange in Python}, label={lst:mlkem-python}]
import oqs

def ml_kem_key_exchange():
    """Demonstrate ML-KEM key exchange."""
    
    # Create KEM instance
    kem = oqs.KeyEncapsulation("ML-KEM-768")
    
    # Receiver generates keypair
    public_key = kem.generate_keypair()
    print(f"Public key: {len(public_key)} bytes")
    print(f"Secret key: {len(kem.export_secret_key())} bytes")
    
    # Sender encapsulates
    ciphertext, shared_secret_sender = kem.encap_secret(public_key)
    print(f"Ciphertext: {len(ciphertext)} bytes")
    print(f"Shared secret: {len(shared_secret_sender)} bytes")
    
    # Receiver decapsulates
    shared_secret_receiver = kem.decap_secret(ciphertext)
    
    # Verify
    assert shared_secret_sender == shared_secret_receiver
    print("Key exchange successful!")
    
    return shared_secret_sender

if __name__ == "__main__":
    shared_key = ml_kem_key_exchange()
    print(f"Established key: {shared_key.hex()[:32]}...")
\end{lstlisting}

\section{Hybrid Key Exchange}
\label{sec:mlkem-hybrid}

During the transition period, hybrid schemes combine classical and post-quantum algorithms to hedge against potential weaknesses in either.

\subsection{X25519-ML-KEM Hybrid}
\label{subsec:x25519-mlkem}

The recommended hybrid approach combines X25519 and ML-KEM:

\begin{algorithm}[H]
\caption{Hybrid X25519-ML-KEM Key Exchange}
\label{alg:hybrid-kem}
\begin{algorithmic}[1]
\State \textbf{// Key Generation}
\State $(pk_{x25519}, sk_{x25519}) \gets \text{X25519.KeyGen}()$
\State $(pk_{mlkem}, sk_{mlkem}) \gets \text{ML-KEM.KeyGen}()$
\State $pk \gets pk_{x25519} \| pk_{mlkem}$
\State $sk \gets sk_{x25519} \| sk_{mlkem}$
\State
\State \textbf{// Encapsulation}
\State $(ss_{x25519}, ct_{x25519}) \gets \text{X25519.DH}(pk_{x25519})$
\State $(ss_{mlkem}, ct_{mlkem}) \gets \text{ML-KEM.Encaps}(pk_{mlkem})$
\State $ct \gets ct_{x25519} \| ct_{mlkem}$
\State $K \gets \text{KDF}(ss_{x25519} \| ss_{mlkem})$
\State
\State \textbf{// Decapsulation}
\State $ss_{x25519} \gets \text{X25519.DH}(sk_{x25519}, ct_{x25519})$
\State $ss_{mlkem} \gets \text{ML-KEM.Decaps}(sk_{mlkem}, ct_{mlkem})$
\State $K \gets \text{KDF}(ss_{x25519} \| ss_{mlkem})$
\end{algorithmic}
\end{algorithm}

\begin{table}[H]
\centering
\caption{Hybrid scheme sizes}
\label{tab:hybrid-sizes}
\begin{tabular}{lccc}
\toprule
\textbf{Scheme} & \textbf{Public Key} & \textbf{Ciphertext} & \textbf{Security} \\
\midrule
X25519 only & 32 B & 32 B & Classical 128-bit \\
ML-KEM-768 only & 1,184 B & 1,088 B & PQ 192-bit \\
X25519 + ML-KEM-768 & 1,216 B & 1,120 B & Both \\
\bottomrule
\end{tabular}
\end{table}

\section{IoT Deployment Considerations}
\label{sec:mlkem-iot}

\subsection{Device Class Recommendations}
\label{subsec:mlkem-device-class}

\begin{table}[H]
\centering
\caption{ML-KEM suitability by IoT device class}
\label{tab:mlkem-iot-class}
\begin{tabular}{lcccc}
\toprule
\textbf{Device Class} & \textbf{RAM} & \textbf{ML-KEM-512} & \textbf{ML-KEM-768} & \textbf{ML-KEM-1024} \\
\midrule
Class 0 ($<$10 KB) & $<$10 KB & \textcolor{red}{No} & \textcolor{red}{No} & \textcolor{red}{No} \\
Class 1 ($\sim$10 KB) & $\sim$10 KB & \textcolor{warning-orange}{Limited} & \textcolor{red}{No} & \textcolor{red}{No} \\
Class 2 ($\sim$50 KB) & $\sim$50 KB & \textcolor{nist-green}{Yes} & \textcolor{nist-green}{Yes} & \textcolor{warning-orange}{Limited} \\
Class 3 ($>$256 KB) & $>$256 KB & \textcolor{nist-green}{Yes} & \textcolor{nist-green}{Yes} & \textcolor{nist-green}{Yes} \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Bandwidth Impact}
\label{subsec:mlkem-bandwidth}

For bandwidth-constrained networks (LoRaWAN, NB-IoT), ML-KEM's larger sizes are significant:

\begin{table}[H]
\centering
\caption{Transmission time comparison (LoRaWAN SF7, 125 kHz)}
\label{tab:mlkem-lora}
\begin{tabular}{lccc}
\toprule
\textbf{Operation} & \textbf{ECDH P-256} & \textbf{ML-KEM-512} & \textbf{ML-KEM-768} \\
\midrule
Public key TX & 12 ms & 154 ms & 228 ms \\
Response TX & 12 ms & 148 ms & 210 ms \\
Total exchange & 24 ms & 302 ms & 438 ms \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Energy Consumption}
\label{subsec:mlkem-energy}

\begin{table}[H]
\centering
\caption{Estimated energy consumption on Cortex-M4 @ 3.3V, 80 MHz}
\label{tab:mlkem-energy}
\begin{tabular}{lrrr}
\toprule
\textbf{Operation} & \textbf{ML-KEM-512} & \textbf{ML-KEM-768} & \textbf{ML-KEM-1024} \\
\midrule
KeyGen & 48 µJ & 79 µJ & 126 µJ \\
Encaps & 48 µJ & 81 µJ & 127 µJ \\
Decaps & 53 µJ & 87 µJ & 135 µJ \\
Full exchange & 149 µJ & 247 µJ & 388 µJ \\
\bottomrule
\end{tabular}
\end{table}

\section{Chapter Summary}
\label{sec:ch3-summary}

This chapter provided comprehensive coverage of ML-KEM, the NIST-standardized post-quantum key encapsulation mechanism:

\begin{itemize}
    \item \textbf{Design}: ML-KEM uses Module-LWE with Fujisaki-Okamoto transform for CCA security
    \item \textbf{Parameters}: Three variants (512/768/1024) for security levels 1/3/5
    \item \textbf{Algorithms}: Detailed KeyGen, Encaps, Decaps with compression and NTT
    \item \textbf{Security}: Based on Module-LWE hardness; implicit rejection prevents CCA attacks
    \item \textbf{Performance}: Faster than ECDH on Cortex-M4; 2--3 KB stack usage
    \item \textbf{Sizes}: Public keys 800--1,568 B; ciphertexts 768--1,568 B
    \item \textbf{IoT}: Suitable for Class 2+ devices; bandwidth is main constraint
    \item \textbf{Hybrid}: Combine with X25519 during transition period
\end{itemize}

\infobox{For most IoT applications requiring post-quantum key exchange, \textbf{ML-KEM-768} offers the best balance of security (192-bit post-quantum) and efficiency. Use ML-KEM-512 for extremely constrained devices where 128-bit security suffices.}

% End of Chapter 3

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% CHAPTER 4: DIGITAL SIGNATURE SCHEMES
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Digital Signature Schemes}
\label{ch:signatures}

Digital signatures provide authentication, integrity, and non-repudiation---essential security properties for IoT systems. This chapter covers the three post-quantum signature schemes selected by NIST: ML-DSA (Dilithium), SLH-DSA (SPHINCS+), and Falcon.

\section{Introduction to Digital Signatures}
\label{sec:sig-intro}

\begin{definition}[Digital Signature Scheme]
A digital signature scheme consists of three algorithms:
\begin{itemize}
    \item $\KeyGen() \rightarrow (pk, sk)$: Generate a public/private key pair
    \item $\Sign(sk, m) \rightarrow \sigma$: Create a signature $\sigma$ on message $m$
    \item $\Verify(pk, m, \sigma) \rightarrow \{0, 1\}$: Verify signature validity
\end{itemize}
\end{definition}

\begin{definition}[EUF-CMA Security]
A signature scheme is \emph{existentially unforgeable under chosen message attack} (EUF-CMA) if no efficient adversary with access to a signing oracle can produce a valid signature on a new message.
\end{definition}

\subsection{Signatures in IoT}
\label{subsec:sig-iot}

Digital signatures serve critical functions in IoT:
\begin{itemize}
    \item \textbf{Firmware updates}: Authenticate software from legitimate vendors
    \item \textbf{Device attestation}: Prove device identity and configuration
    \item \textbf{Data integrity}: Sign sensor readings for audit trails
    \item \textbf{Certificate authentication}: TLS/DTLS handshakes
    \item \textbf{Secure boot}: Verify bootloader and kernel integrity
\end{itemize}

\placeholder{0.8\textwidth}{Diagram showing signature usage in IoT: firmware signing, secure boot chain, and certificate verification}

\subsection{Comparison Overview}
\label{subsec:sig-comparison}

NIST selected three signature schemes with complementary characteristics:

\begin{table}[H]
\centering
\caption{NIST post-quantum signature schemes comparison}
\label{tab:sig-overview}
\begin{tabular}{lccccc}
\toprule
\textbf{Scheme} & \textbf{Basis} & \textbf{pk Size} & \textbf{sig Size} & \textbf{Sign} & \textbf{Verify} \\
\midrule
ML-DSA-65 & Lattice & 1,952 B & 3,293 B & Fast & Fast \\
Falcon-512 & Lattice & 897 B & 666 B & Medium & Very Fast \\
SLH-DSA-128s & Hash & 32 B & 7,856 B & Slow & Medium \\
\bottomrule
\end{tabular}
\end{table}

%==============================================================================
\section{ML-DSA (Dilithium)}
\label{sec:mldsa}
%==============================================================================

ML-DSA (Module-Lattice-Based Digital Signature Algorithm), specified in FIPS 204, is based on the CRYSTALS-Dilithium submission. It offers balanced performance and is the recommended general-purpose post-quantum signature scheme.

\subsection{Design Overview}
\label{subsec:mldsa-design}

ML-DSA is a Fiat-Shamir signature scheme based on the ``Fiat-Shamir with Aborts'' paradigm:

\begin{enumerate}
    \item Generate a commitment from random masking vector
    \item Hash message and commitment to produce challenge
    \item Compute response using secret key
    \item \textbf{Reject and restart} if response would leak secret information
\end{enumerate}

The rejection sampling ensures signatures don't reveal the secret key, but introduces variable signing time.

\begin{figure}[H]
\centering
\begin{tikzpicture}[node distance=2cm, auto]
    \node[draw, rectangle, minimum width=2.5cm] (keygen) {KeyGen};
    \node[draw, rectangle, minimum width=2.5cm, right=3cm of keygen] (sign) {Sign};
    \node[draw, rectangle, minimum width=2.5cm, right=3cm of sign] (verify) {Verify};
    
    \node[above=0.3cm of keygen] {MLWE};
    \node[above=0.3cm of sign] {Fiat-Shamir};
    \node[above=0.3cm of verify] {MSIS};
    
    \draw[->] (keygen) -- node[above] {$pk, sk$} (sign);
    \draw[->] (sign) -- node[above] {$\sigma$} (verify);
\end{tikzpicture}
\caption{ML-DSA construction: security from MLWE and MSIS}
\label{fig:mldsa-construction}
\end{figure}

\subsection{Parameters}
\label{subsec:mldsa-params}

\begin{table}[H]
\centering
\caption{ML-DSA parameter sets (FIPS 204)}
\label{tab:mldsa-params}
\begin{tabular}{lccc}
\toprule
\textbf{Parameter} & \textbf{ML-DSA-44} & \textbf{ML-DSA-65} & \textbf{ML-DSA-87} \\
\midrule
NIST Security Level & 2 & 3 & 5 \\
Module dimensions $(k, \ell)$ & $(4, 4)$ & $(6, 5)$ & $(8, 7)$ \\
Polynomial degree $n$ & 256 & 256 & 256 \\
Modulus $q$ & 8,380,417 & 8,380,417 & 8,380,417 \\
Challenge weight $\tau$ & 39 & 49 & 60 \\
Coefficient bound $\gamma_1$ & $2^{17}$ & $2^{19}$ & $2^{19}$ \\
Coefficient bound $\gamma_2$ & 95,232 & 261,888 & 261,888 \\
Secret key range $\eta$ & 2 & 4 & 2 \\
Hint bits $\omega$ & 80 & 55 & 75 \\
\midrule
Public key size & 1,312 B & 1,952 B & 2,592 B \\
Secret key size & 2,560 B & 4,032 B & 4,896 B \\
Signature size & 2,420 B & 3,293 B & 4,595 B \\
\bottomrule
\end{tabular}
\end{table}

\infobox{The modulus $q = 8380417 = 2^{23} - 2^{13} + 1$ is chosen for efficient NTT: it is prime, $q \equiv 1 \pmod{512}$, and allows fast reduction using the special form.}

\subsection{Algorithms}
\label{subsec:mldsa-algorithms}

\subsubsection{Key Generation}

\begin{algorithm}[H]
\caption{ML-DSA.KeyGen()}
\label{alg:mldsa-keygen}
\begin{algorithmic}[1]
\Require Security parameter (implicit)
\Ensure Public key $pk$, Secret key $sk$
\State $\zeta \getsr \{0,1\}^{256}$
\State $(\rho, \rho', K) \gets H(\zeta)$ \Comment{Expand seed}
\State $\hat{\mathbf{A}} \gets \text{ExpandA}(\rho)$ \Comment{Public matrix in NTT domain}
\State $(\mathbf{s}_1, \mathbf{s}_2) \gets \text{ExpandS}(\rho')$ \Comment{Secret vectors, coeffs in $[-\eta, \eta]$}
\State $\hat{\mathbf{s}}_1 \gets \text{NTT}(\mathbf{s}_1)$
\State $\mathbf{t} \gets \text{NTT}^{-1}(\hat{\mathbf{A}} \circ \hat{\mathbf{s}}_1) + \mathbf{s}_2$ \Comment{$\mathbf{t} = \mathbf{A}\mathbf{s}_1 + \mathbf{s}_2$}
\State $(\mathbf{t}_1, \mathbf{t}_0) \gets \text{Power2Round}(\mathbf{t})$ \Comment{Split for compression}
\State $pk \gets (\rho, \mathbf{t}_1)$
\State $tr \gets H(pk)$
\State $sk \gets (\rho, K, tr, \mathbf{s}_1, \mathbf{s}_2, \mathbf{t}_0)$
\State \Return $(pk, sk)$
\end{algorithmic}
\end{algorithm}

\subsubsection{Signing}

\begin{algorithm}[H]
\caption{ML-DSA.Sign($sk$, $M$)}
\label{alg:mldsa-sign}
\begin{algorithmic}[1]
\Require Secret key $sk = (\rho, K, tr, \mathbf{s}_1, \mathbf{s}_2, \mathbf{t}_0)$, Message $M$
\Ensure Signature $\sigma$
\State $\hat{\mathbf{A}} \gets \text{ExpandA}(\rho)$
\State $\mu \gets H(tr \| M)$ \Comment{Message representative}
\State $\kappa \gets 0$; $(\mathbf{z}, \mathbf{h}) \gets \bot$
\State $\rho' \gets H(K \| \mu)$ \Comment{Deterministic or random}
\While{$(\mathbf{z}, \mathbf{h}) = \bot$} \Comment{Rejection sampling loop}
    \State $\mathbf{y} \gets \text{ExpandMask}(\rho', \kappa)$ \Comment{Masking vector}
    \State $\hat{\mathbf{y}} \gets \text{NTT}(\mathbf{y})$
    \State $\mathbf{w} \gets \text{NTT}^{-1}(\hat{\mathbf{A}} \circ \hat{\mathbf{y}})$
    \State $\mathbf{w}_1 \gets \text{HighBits}(\mathbf{w})$
    \State $\tilde{c} \gets H(\mu \| \mathbf{w}_1)$ \Comment{Challenge hash}
    \State $c \gets \text{SampleInBall}(\tilde{c})$ \Comment{Challenge polynomial}
    \State $\hat{c} \gets \text{NTT}(c)$
    \State $\mathbf{z} \gets \mathbf{y} + \text{NTT}^{-1}(\hat{c} \circ \hat{\mathbf{s}}_1)$
    \State $\mathbf{r}_0 \gets \text{LowBits}(\mathbf{w} - \text{NTT}^{-1}(\hat{c} \circ \hat{\mathbf{s}}_2))$
    \If{$\|\mathbf{z}\|_\infty \geq \gamma_1 - \beta$ \textbf{or} $\|\mathbf{r}_0\|_\infty \geq \gamma_2 - \beta$}
        \State $(\mathbf{z}, \mathbf{h}) \gets \bot$ \Comment{Reject: would leak secret}
    \Else
        \State $\mathbf{h} \gets \text{MakeHint}(\mathbf{w} - c\mathbf{s}_2 + c\mathbf{t}_0, \mathbf{w} - c\mathbf{s}_2)$
        \If{$\|\mathbf{h}\|_1 > \omega$}
            \State $(\mathbf{z}, \mathbf{h}) \gets \bot$
        \EndIf
    \EndIf
    \State $\kappa \gets \kappa + 1$
\EndWhile
\State \Return $\sigma \gets (\tilde{c}, \mathbf{z}, \mathbf{h})$
\end{algorithmic}
\end{algorithm}

\warningbox{The rejection sampling loop typically iterates 4--7 times on average. This makes signing time variable, which may be a concern for real-time systems. Implementations should account for worst-case timing.}

\subsubsection{Verification}

\begin{algorithm}[H]
\caption{ML-DSA.Verify($pk$, $M$, $\sigma$)}
\label{alg:mldsa-verify}
\begin{algorithmic}[1]
\Require Public key $pk = (\rho, \mathbf{t}_1)$, Message $M$, Signature $\sigma = (\tilde{c}, \mathbf{z}, \mathbf{h})$
\Ensure Accept (1) or Reject (0)
\If{$\|\mathbf{z}\|_\infty \geq \gamma_1 - \beta$}
    \State \Return 0
\EndIf
\State $\hat{\mathbf{A}} \gets \text{ExpandA}(\rho)$
\State $\mu \gets H(H(pk) \| M)$
\State $c \gets \text{SampleInBall}(\tilde{c})$
\State $\hat{c} \gets \text{NTT}(c)$; $\hat{\mathbf{z}} \gets \text{NTT}(\mathbf{z})$
\State $\mathbf{w}' \gets \text{NTT}^{-1}(\hat{\mathbf{A}} \circ \hat{\mathbf{z}} - \hat{c} \circ \text{NTT}(\mathbf{t}_1 \cdot 2^d))$
\State $\mathbf{w}'_1 \gets \text{UseHint}(\mathbf{h}, \mathbf{w}')$
\State $\tilde{c}' \gets H(\mu \| \mathbf{w}'_1)$
\State \Return $[\tilde{c} = \tilde{c}']$ \textbf{and} $[\|\mathbf{h}\|_1 \leq \omega]$
\end{algorithmic}
\end{algorithm}

\subsection{Performance}
\label{subsec:mldsa-performance}

\begin{table}[H]
\centering
\caption{ML-DSA performance on ARM Cortex-M4 (cycles)}
\label{tab:mldsa-m4-cycles}
\begin{tabular}{llrrr}
\toprule
\textbf{Scheme} & \textbf{Variant} & \textbf{KeyGen} & \textbf{Sign (avg)} & \textbf{Verify} \\
\midrule
\multirow{2}{*}{ML-DSA-44}
    & clean & 1,202,964 & 4,428,842 & 1,208,160 \\
    & m4f & 800,974 & 2,292,188 & 786,486 \\
\midrule
\multirow{2}{*}{ML-DSA-65}
    & clean & 2,009,972 & 6,659,854 & 1,973,700 \\
    & m4f & 1,406,298 & 3,948,962 & 1,380,582 \\
\midrule
\multirow{2}{*}{ML-DSA-87}
    & clean & 3,043,684 & 8,509,260 & 3,019,802 \\
    & m4f & 2,222,174 & 5,383,044 & 2,148,702 \\
\bottomrule
\end{tabular}
\end{table}

\begin{table}[H]
\centering
\caption{ML-DSA stack usage on ARM Cortex-M4 (bytes)}
\label{tab:mldsa-m4-stack}
\begin{tabular}{llrrr}
\toprule
\textbf{Scheme} & \textbf{Variant} & \textbf{KeyGen} & \textbf{Sign} & \textbf{Verify} \\
\midrule
ML-DSA-44 & m4f & 10,328 & 24,512 & 10,680 \\
ML-DSA-65 & m4f & 14,472 & 34,752 & 15,336 \\
ML-DSA-87 & m4f & 18,104 & 43,968 & 19,992 \\
\bottomrule
\end{tabular}
\end{table}

\infobox{ML-DSA requires significantly more stack space than ML-KEM due to the larger matrices and the need to store intermediate values during rejection sampling. Ensure adequate stack allocation in embedded systems.}

%==============================================================================
\section{SLH-DSA (SPHINCS+)}
\label{sec:slhdsa}
%==============================================================================

SLH-DSA (Stateless Hash-Based Digital Signature Algorithm), specified in FIPS 205, provides an alternative to lattice-based signatures with security based solely on hash function properties.

\subsection{Design Philosophy}
\label{subsec:slhdsa-design}

SLH-DSA is conservative by design:
\begin{itemize}
    \item \textbf{Minimal assumptions}: Security relies only on hash function properties (not lattice problems)
    \item \textbf{Well-understood}: Hash-based signatures have decades of cryptanalysis
    \item \textbf{Stateless}: No state management required (unlike XMSS/LMS)
    \item \textbf{Tradeoff flexibility}: Multiple parameter sets for size/speed balance
\end{itemize}

\subsubsection{Hypertree Structure}

SLH-DSA uses a hierarchical structure:
\begin{enumerate}
    \item \textbf{FORS}: Few-time signature scheme for signing message digest
    \item \textbf{WOTS+}: One-time signatures to authenticate FORS keys
    \item \textbf{Hypertree}: Multiple layers of Merkle trees to reduce public key size
\end{enumerate}

\placeholder{0.85\textwidth}{Diagram showing SPHINCS+ hypertree structure: FORS at leaves, multiple XMSS trees in layers, single root public key}

\subsection{Parameters}
\label{subsec:slhdsa-params}

SLH-DSA offers many parameter sets with different tradeoffs:

\begin{table}[H]
\centering
\caption{Selected SLH-DSA parameter sets (FIPS 205)}
\label{tab:slhdsa-params}
\begin{tabular}{lcccccc}
\toprule
\textbf{Parameter Set} & \textbf{Security} & \textbf{pk} & \textbf{sk} & \textbf{sig} & \textbf{Sign} & \textbf{Verify} \\
\midrule
\multicolumn{7}{c}{\textit{Small signatures (``s'' suffix)}} \\
\midrule
SLH-DSA-SHA2-128s & Level 1 & 32 B & 64 B & 7,856 B & Slow & Medium \\
SLH-DSA-SHA2-192s & Level 3 & 48 B & 96 B & 16,224 B & Slow & Medium \\
SLH-DSA-SHA2-256s & Level 5 & 64 B & 128 B & 29,792 B & Slow & Medium \\
\midrule
\multicolumn{7}{c}{\textit{Fast signing (``f'' suffix)}} \\
\midrule
SLH-DSA-SHA2-128f & Level 1 & 32 B & 64 B & 17,088 B & Fast & Fast \\
SLH-DSA-SHA2-192f & Level 3 & 48 B & 96 B & 35,664 B & Fast & Fast \\
SLH-DSA-SHA2-256f & Level 5 & 64 B & 128 B & 49,856 B & Fast & Fast \\
\midrule
\multicolumn{7}{c}{\textit{SHAKE-based variants}} \\
\midrule
SLH-DSA-SHAKE-128s & Level 1 & 32 B & 64 B & 7,856 B & Slow & Medium \\
SLH-DSA-SHAKE-128f & Level 1 & 32 B & 64 B & 17,088 B & Fast & Fast \\
\bottomrule
\end{tabular}
\end{table}

\warningbox{SLH-DSA signatures are significantly larger than ML-DSA or Falcon signatures. The ``f'' (fast) variants are even larger but sign/verify faster. Choose based on your bandwidth vs. computation constraints.}

\subsection{Algorithm Sketch}
\label{subsec:slhdsa-algorithms}

\subsubsection{Key Generation}
\begin{enumerate}
    \item Generate random seeds: $\text{SK.seed}$, $\text{SK.prf}$, $\text{PK.seed}$
    \item Compute hypertree root as public key
    \item Store seeds as secret key
\end{enumerate}

\subsubsection{Signing}
\begin{enumerate}
    \item Compute randomized message digest
    \item Select FORS keypair based on digest
    \item Sign digest with FORS
    \item Authenticate FORS public key through hypertree
    \item Signature = FORS signature + authentication path
\end{enumerate}

\subsubsection{Verification}
\begin{enumerate}
    \item Recompute message digest
    \item Verify FORS signature
    \item Verify authentication path up to root
    \item Compare computed root with public key
\end{enumerate}

\subsection{Performance}
\label{subsec:slhdsa-performance}

\begin{table}[H]
\centering
\caption{SLH-DSA performance on ARM Cortex-M4 (cycles, millions)}
\label{tab:slhdsa-m4}
\begin{tabular}{lrrr}
\toprule
\textbf{Parameter Set} & \textbf{KeyGen} & \textbf{Sign} & \textbf{Verify} \\
\midrule
SLH-DSA-SHAKE-128s & 36.8 M & 978 M & 37.8 M \\
SLH-DSA-SHAKE-128f & 2.9 M & 51.7 M & 3.5 M \\
SLH-DSA-SHAKE-192s & 61.9 M & 1,271 M & 42.4 M \\
SLH-DSA-SHAKE-192f & 4.2 M & 94.9 M & 5.9 M \\
SLH-DSA-SHAKE-256s & 225 M & 3,817 M & 103 M \\
SLH-DSA-SHAKE-256f & 5.9 M & 151 M & 9.9 M \\
\bottomrule
\end{tabular}
\end{table}

\begin{table}[H]
\centering
\caption{SLH-DSA vs. ML-DSA: Size and speed tradeoffs (Level 1)}
\label{tab:slhdsa-vs-mldsa}
\begin{tabular}{lrrrr}
\toprule
\textbf{Scheme} & \textbf{pk + sig} & \textbf{Sign (M4)} & \textbf{Verify (M4)} & \textbf{Confidence} \\
\midrule
ML-DSA-44 & 3,732 B & 2.3 M & 0.8 M & High \\
SLH-DSA-SHAKE-128s & 7,888 B & 978 M & 37.8 M & Very High \\
SLH-DSA-SHAKE-128f & 17,120 B & 51.7 M & 3.5 M & Very High \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Use Cases}
\label{subsec:slhdsa-usecases}

SLH-DSA is best suited for:
\begin{itemize}
    \item \textbf{Root certificates}: Long-lived trust anchors where signing is rare
    \item \textbf{Firmware signing}: Server-side signing, device-side verification
    \item \textbf{Conservative deployments}: When lattice assumptions are considered risky
    \item \textbf{Compliance}: When hash-based signatures are mandated
\end{itemize}

\infobox{For IoT devices that primarily \textbf{verify} signatures (e.g., firmware updates), the ``f'' variants offer reasonable verification times. Signing is typically done on more powerful servers.}

%==============================================================================
\section{Falcon}
\label{sec:falcon}
%==============================================================================

Falcon is an NTRU-lattice-based signature scheme offering the smallest combined public key and signature sizes among NIST selections. It is selected for standardization but requires additional specification work.

\subsection{Design Overview}
\label{subsec:falcon-design}

Falcon uses the GPV framework (Gentry-Peikert-Vaikuntanathan) with:
\begin{itemize}
    \item \textbf{NTRU lattices}: Structured lattices with compact representation
    \item \textbf{Fast Fourier Sampling}: Efficient trapdoor sampling using FFT
    \item \textbf{Gaussian sampling}: True discrete Gaussian (unlike Dilithium's rejection)
\end{itemize}

\begin{definition}[NTRU Problem]
Given $h = g \cdot f^{-1} \mod q$ in $R_q = \Zq[x]/(x^n + 1)$ where $f, g$ have small coefficients, find $f$ and $g$.
\end{definition}

\subsection{Parameters}
\label{subsec:falcon-params}

\begin{table}[H]
\centering
\caption{Falcon parameter sets}
\label{tab:falcon-params}
\begin{tabular}{lcc}
\toprule
\textbf{Parameter} & \textbf{Falcon-512} & \textbf{Falcon-1024} \\
\midrule
NIST Security Level & 1 & 5 \\
Ring degree $n$ & 512 & 1024 \\
Modulus $q$ & 12,289 & 12,289 \\
Gaussian std. dev. $\sigma$ & 165.74 & 168.39 \\
\midrule
Public key size & 897 B & 1,793 B \\
Secret key size & 1,281 B & 2,305 B \\
Signature size (avg) & 666 B & 1,280 B \\
\midrule
Signature size (max) & 809 B & 1,577 B \\
\bottomrule
\end{tabular}
\end{table}

\infobox{Falcon signatures have variable size due to compression. The table shows average and maximum sizes. Implementations must handle the maximum to avoid buffer overflows.}

\subsection{Algorithm Highlights}
\label{subsec:falcon-algorithms}

\subsubsection{Key Generation}
\begin{enumerate}
    \item Generate NTRU key pair: small polynomials $f, g, F, G$ with $fG - gF = q$
    \item Public key: $h = g \cdot f^{-1} \mod q$
    \item Secret key: Precomputed FFT tree for fast sampling
\end{enumerate}

\subsubsection{Signing (Simplified)}
\begin{enumerate}
    \item Hash message to point $c$ in lattice
    \item Use trapdoor to sample short vector $(s_1, s_2)$ with $s_1 + s_2 \cdot h = c$
    \item Signature: compressed $s_2$ (or $(s_1, s_2)$)
\end{enumerate}

\subsubsection{Verification}
\begin{enumerate}
    \item Decompress signature to get $s_2$
    \item Compute $s_1 = c - s_2 \cdot h$
    \item Accept if $(s_1, s_2)$ is sufficiently short
\end{enumerate}

\subsection{Performance}
\label{subsec:falcon-performance}

\begin{table}[H]
\centering
\caption{Falcon performance on ARM Cortex-M4 (cycles)}
\label{tab:falcon-m4}
\begin{tabular}{llrrr}
\toprule
\textbf{Scheme} & \textbf{Variant} & \textbf{KeyGen} & \textbf{Sign} & \textbf{Verify} \\
\midrule
\multirow{2}{*}{Falcon-512}
    & clean & 90.1 M & 14.9 M & 0.41 M \\
    & opt & 53.3 M & 7.0 M & 0.34 M \\
\midrule
\multirow{2}{*}{Falcon-1024}
    & clean & 265 M & 32.0 M & 0.84 M \\
    & opt & 134 M & 14.9 M & 0.69 M \\
\bottomrule
\end{tabular}
\end{table}

\begin{table}[H]
\centering
\caption{Falcon RAM requirements}
\label{tab:falcon-ram}
\begin{tabular}{lrr}
\toprule
\textbf{Operation} & \textbf{Falcon-512} & \textbf{Falcon-1024} \\
\midrule
Key generation & 14 KB & 28 KB \\
Signing & 39 KB & 79 KB \\
Verification & 2 KB & 3 KB \\
\bottomrule
\end{tabular}
\end{table}

\warningbox{Falcon's Gaussian sampling is notoriously difficult to implement securely. Side-channel resistant implementations require careful attention to constant-time floating-point operations or integer-only approximations.}

\subsection{Falcon vs. ML-DSA}
\label{subsec:falcon-vs-mldsa}

\begin{table}[H]
\centering
\caption{Falcon vs. ML-DSA comparison}
\label{tab:falcon-vs-mldsa}
\begin{tabular}{lcc}
\toprule
\textbf{Aspect} & \textbf{Falcon-512} & \textbf{ML-DSA-44} \\
\midrule
Public key & 897 B & 1,312 B \\
Signature & 666 B & 2,420 B \\
Combined (pk + sig) & 1,563 B & 3,732 B \\
Sign cycles (M4) & 7.0 M & 2.3 M \\
Verify cycles (M4) & 0.34 M & 0.79 M \\
Implementation complexity & High & Medium \\
Side-channel hardening & Difficult & Easier \\
\bottomrule
\end{tabular}
\end{table}

\textbf{Recommendation}:
\begin{itemize}
    \item Use \textbf{Falcon} when bandwidth is critical and implementation resources are available
    \item Use \textbf{ML-DSA} for general purposes, especially when simpler implementation is preferred
\end{itemize}

%==============================================================================
\section{Comparative Analysis}
\label{sec:sig-comparative}
%==============================================================================

\subsection{Size Comparison}
\label{subsec:sig-sizes}

\begin{table}[H]
\centering
\caption{Complete size comparison of PQ signature schemes}
\label{tab:sig-all-sizes}
\begin{tabular}{lrrrr}
\toprule
\textbf{Scheme} & \textbf{pk} & \textbf{sk} & \textbf{sig} & \textbf{pk + sig} \\
\midrule
\multicolumn{5}{c}{\textit{Security Level 1 (128-bit)}} \\
\midrule
ECDSA P-256 (classical) & 64 B & 32 B & 64 B & 128 B \\
ML-DSA-44 & 1,312 B & 2,560 B & 2,420 B & 3,732 B \\
Falcon-512 & 897 B & 1,281 B & 666 B & 1,563 B \\
SLH-DSA-SHA2-128s & 32 B & 64 B & 7,856 B & 7,888 B \\
SLH-DSA-SHA2-128f & 32 B & 64 B & 17,088 B & 17,120 B \\
\midrule
\multicolumn{5}{c}{\textit{Security Level 3 (192-bit)}} \\
\midrule
ECDSA P-384 (classical) & 96 B & 48 B & 96 B & 192 B \\
ML-DSA-65 & 1,952 B & 4,032 B & 3,293 B & 5,245 B \\
SLH-DSA-SHA2-192s & 48 B & 96 B & 16,224 B & 16,272 B \\
\midrule
\multicolumn{5}{c}{\textit{Security Level 5 (256-bit)}} \\
\midrule
ML-DSA-87 & 2,592 B & 4,896 B & 4,595 B & 7,187 B \\
Falcon-1024 & 1,793 B & 2,305 B & 1,280 B & 3,073 B \\
SLH-DSA-SHA2-256s & 64 B & 128 B & 29,792 B & 29,856 B \\
\bottomrule
\end{tabular}
\end{table}

\placeholder{0.9\textwidth}{Bar chart comparing pk+sig sizes for ECDSA, ML-DSA, Falcon, and SLH-DSA at each security level}

\subsection{Performance Comparison}
\label{subsec:sig-perf}

\begin{table}[H]
\centering
\caption{Signature scheme performance summary (Cortex-M4, Level 1)}
\label{tab:sig-perf-summary}
\begin{tabular}{lrrrl}
\toprule
\textbf{Scheme} & \textbf{KeyGen} & \textbf{Sign} & \textbf{Verify} & \textbf{Notes} \\
\midrule
ECDSA P-256 & 1.4 M & 1.8 M & 2.1 M & Classical only \\
ML-DSA-44 & 0.8 M & 2.3 M & 0.8 M & Best general choice \\
Falcon-512 & 53.3 M & 7.0 M & 0.34 M & Smallest sizes \\
SLH-DSA-128f & 2.9 M & 51.7 M & 3.5 M & Conservative \\
SLH-DSA-128s & 36.8 M & 978 M & 37.8 M & Smallest sig \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Selection Guidelines}
\label{subsec:sig-selection}

\begin{table}[H]
\centering
\caption{Signature scheme selection by use case}
\label{tab:sig-selection}
\begin{tabular}{lcccc}
\toprule
\textbf{Use Case} & \textbf{ML-DSA} & \textbf{Falcon} & \textbf{SLH-DSA-f} & \textbf{SLH-DSA-s} \\
\midrule
TLS certificates & \checkmark & \checkmark & & \\
Firmware signing & \checkmark & \checkmark & \checkmark & \checkmark \\
Real-time signing & \checkmark & & & \\
Bandwidth critical & & \checkmark & & \\
Code signing & \checkmark & \checkmark & \checkmark & \\
Root CA certificates & & & & \checkmark \\
General purpose & \checkmark & & & \\
Conservative choice & & & \checkmark & \checkmark \\
\bottomrule
\end{tabular}
\end{table}

\section{Code Examples}
\label{sec:sig-code}

\subsection{ML-DSA with liboqs}
\label{subsec:mldsa-code}

\begin{lstlisting}[language=C, caption={ML-DSA signing and verification}, label={lst:mldsa-code}]
#include <oqs/oqs.h>
#include <string.h>

int sign_verify_example(void) {
    OQS_SIG *sig = OQS_SIG_new(OQS_SIG_alg_ml_dsa_65);
    if (sig == NULL) return -1;
    
    uint8_t *public_key = malloc(sig->length_public_key);
    uint8_t *secret_key = malloc(sig->length_secret_key);
    uint8_t *signature = malloc(sig->length_signature);
    size_t signature_len;
    
    // Key generation
    OQS_SIG_keypair(sig, public_key, secret_key);
    
    // Sign message
    const uint8_t message[] = "Hello, Post-Quantum World!";
    OQS_SIG_sign(sig, signature, &signature_len,
                 message, sizeof(message), secret_key);
    
    printf("Signature: %zu bytes\n", signature_len);
    
    // Verify signature
    OQS_STATUS result = OQS_SIG_verify(sig, message, sizeof(message),
                                        signature, signature_len, public_key);
    
    if (result == OQS_SUCCESS) {
        printf("Signature valid!\n");
    }
    
    // Cleanup
    OQS_MEM_secure_free(secret_key, sig->length_secret_key);
    free(public_key);
    free(signature);
    OQS_SIG_free(sig);
    
    return (result == OQS_SUCCESS) ? 0 : -1;
}
\end{lstlisting}

\subsection{SPHINCS+ with PQClean}
\label{subsec:sphincs-code}

\begin{lstlisting}[language=C, caption={SLH-DSA using PQClean}, label={lst:sphincs-code}]
#include "api.h"  // PQClean SPHINCS+ API
#include <string.h>

int sphincs_example(void) {
    uint8_t pk[CRYPTO_PUBLICKEYBYTES];
    uint8_t sk[CRYPTO_SECRETKEYBYTES];
    uint8_t sig[CRYPTO_BYTES];
    size_t siglen;
    
    const uint8_t msg[] = "Firmware v2.0 - SHA256: abc123...";
    
    // Generate keypair
    crypto_sign_keypair(pk, sk);
    
    // Sign (detached signature)
    crypto_sign_signature(sig, &siglen, msg, sizeof(msg), sk);
    
    printf("SPHINCS+ signature: %zu bytes\n", siglen);
    
    // Verify
    int valid = crypto_sign_verify(sig, siglen, msg, sizeof(msg), pk);
    
    return valid;  // 0 = valid, -1 = invalid
}
\end{lstlisting}

\subsection{Python Example}
\label{subsec:sig-python}

\begin{lstlisting}[language=Python, caption={Digital signatures in Python}, label={lst:sig-python}]
import oqs

def signature_demo():
    """Demonstrate ML-DSA digital signatures."""
    
    # Create signer
    signer = oqs.Signature("ML-DSA-65")
    
    # Generate keys
    public_key = signer.generate_keypair()
    print(f"Public key: {len(public_key)} bytes")
    
    # Sign a message
    message = b"IoT device attestation data: device_id=12345"
    signature = signer.sign(message)
    print(f"Signature: {len(signature)} bytes")
    
    # Verify (typically on another device)
    verifier = oqs.Signature("ML-DSA-65")
    is_valid = verifier.verify(message, signature, public_key)
    print(f"Signature valid: {is_valid}")
    
    # Demonstrate invalid signature detection
    tampered_message = b"IoT device attestation data: device_id=99999"
    is_valid = verifier.verify(tampered_message, signature, public_key)
    print(f"Tampered message valid: {is_valid}")  # False

if __name__ == "__main__":
    signature_demo()
\end{lstlisting}

\section{Implementation Considerations}
\label{sec:sig-impl}

\subsection{Deterministic vs. Randomized Signing}
\label{subsec:det-random}

\begin{table}[H]
\centering
\caption{Deterministic vs. randomized signing}
\label{tab:det-vs-random}
\begin{tabular}{lcc}
\toprule
\textbf{Aspect} & \textbf{Deterministic} & \textbf{Randomized} \\
\midrule
RNG dependency & None & Required \\
Reproducibility & Same sig for same msg & Different each time \\
Fault attack resistance & Lower & Higher \\
Side-channel leakage & Higher risk & Lower risk \\
\bottomrule
\end{tabular}
\end{table}

NIST recommends \textbf{randomized signing} when good randomness is available, but allows deterministic mode for environments with unreliable RNGs.

\subsection{Batch Verification}
\label{subsec:batch-verify}

For applications verifying many signatures (e.g., blockchain), batch verification can improve throughput:

\begin{itemize}
    \item ML-DSA: Limited batch optimization possible through NTT sharing
    \item Falcon: Good batch verification due to shared FFT operations
    \item SLH-DSA: No significant batch optimization
\end{itemize}

\subsection{Side-Channel Considerations}
\label{subsec:sig-sidechannel}

\begin{table}[H]
\centering
\caption{Side-channel vulnerability by scheme}
\label{tab:sig-sidechannel}
\begin{tabular}{lccc}
\toprule
\textbf{Attack Type} & \textbf{ML-DSA} & \textbf{Falcon} & \textbf{SLH-DSA} \\
\midrule
Timing attacks & Medium & High & Low \\
Power analysis & Medium & High & Low \\
EM emanation & Medium & High & Low \\
Fault attacks & Medium & Medium & Low \\
\bottomrule
\end{tabular}
\end{table}

\section{Chapter Summary}
\label{sec:ch4-summary}

This chapter covered the three NIST post-quantum signature schemes:

\textbf{ML-DSA (Dilithium)}:
\begin{itemize}
    \item Lattice-based, Fiat-Shamir with Aborts
    \item Best balance of size and speed
    \item Recommended for general-purpose use
    \item pk: 1.3--2.6 KB, sig: 2.4--4.6 KB
\end{itemize}

\textbf{Falcon}:
\begin{itemize}
    \item NTRU-lattice with Gaussian sampling
    \item Smallest signatures (666 B at Level 1)
    \item Complex implementation, side-channel concerns
    \item Best for bandwidth-critical applications
\end{itemize}

\textbf{SLH-DSA (SPHINCS+)}:
\begin{itemize}
    \item Hash-based, conservative security assumptions
    \item Large signatures (8--50 KB)
    \item Slow signing, moderate verification
    \item Best for high-assurance, infrequent signing
\end{itemize}

\infobox{For most IoT applications, \textbf{ML-DSA-65} is the recommended choice. Use \textbf{Falcon} when bandwidth is critical and you have implementation expertise. Use \textbf{SLH-DSA} for root certificates and when conservative security is paramount.}

% End of Chapter 4

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% CHAPTER 5: ALTERNATIVE AND EMERGING SCHEMES
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Alternative and Emerging Schemes}
\label{ch:alternative}

While lattice-based cryptography dominates the NIST selections, alternative approaches provide important diversity in the post-quantum ecosystem. This chapter surveys code-based, isogeny-based, and multivariate schemes, with emphasis on those relevant to IoT applications.

\section{Code-Based Cryptography}
\label{sec:code-based}

Code-based cryptography derives security from the difficulty of decoding random linear codes. This family has the longest history in post-quantum cryptography, dating to McEliece's 1978 proposal.

\subsection{Theoretical Foundation}
\label{subsec:code-theory}

\begin{definition}[Linear Code]
A \emph{linear code} $\mathcal{C}$ over a finite field $\mathbb{F}_q$ is a $k$-dimensional subspace of $\mathbb{F}_q^n$. It can be specified by:
\begin{itemize}
    \item \textbf{Generator matrix} $\mathbf{G} \in \mathbb{F}_q^{k \times n}$: codewords are $\mathbf{c} = \mathbf{m}\mathbf{G}$
    \item \textbf{Parity-check matrix} $\mathbf{H} \in \mathbb{F}_q^{(n-k) \times n}$: valid codewords satisfy $\mathbf{H}\mathbf{c}^T = \mathbf{0}$
\end{itemize}
The code has parameters $[n, k, d]$ where $d$ is the minimum distance.
\end{definition}

\begin{definition}[Syndrome Decoding Problem]
Given a parity-check matrix $\mathbf{H} \in \mathbb{F}_2^{r \times n}$ and syndrome $\mathbf{s} \in \mathbb{F}_2^r$, find an error vector $\mathbf{e} \in \mathbb{F}_2^n$ of weight $\leq t$ such that $\mathbf{H}\mathbf{e}^T = \mathbf{s}$.
\end{definition}

The syndrome decoding problem for random codes is NP-complete and believed to be hard for quantum computers. The best quantum algorithms provide only a modest speedup (Grover-like $\sqrt{n}$).

\subsection{HQC (Hamming Quasi-Cyclic)}
\label{subsec:hqc}

HQC is a code-based KEM selected by NIST for standardization in Round 4, providing an alternative to lattice-based ML-KEM.

\subsubsection{Design}

HQC uses:
\begin{itemize}
    \item \textbf{Quasi-cyclic codes}: Structured codes with efficient representation
    \item \textbf{Tensor product construction}: Combines a quasi-cyclic code with a BCH code
    \item \textbf{QCSD problem}: Quasi-Cyclic Syndrome Decoding as security basis
\end{itemize}

\begin{definition}[Quasi-Cyclic Code]
A code is quasi-cyclic with index $\ell$ if every cyclic shift of a codeword by $\ell$ positions is also a codeword. QC codes can be represented compactly using circulant matrices.
\end{definition}

\subsubsection{Parameters}

\begin{table}[H]
\centering
\caption{HQC parameter sets}
\label{tab:hqc-params}
\begin{tabular}{lccccc}
\toprule
\textbf{Instance} & \textbf{Security} & \textbf{$n$} & \textbf{pk} & \textbf{ct} & \textbf{ss} \\
\midrule
HQC-128 & Level 1 & 17,669 & 2,249 B & 4,433 B & 64 B \\
HQC-192 & Level 3 & 35,851 & 4,522 B & 8,978 B & 64 B \\
HQC-256 & Level 5 & 57,637 & 7,245 B & 14,421 B & 64 B \\
\bottomrule
\end{tabular}
\end{table}

\subsubsection{Performance}

\begin{table}[H]
\centering
\caption{HQC performance on Intel Core i7-11850H (AVX2)}
\label{tab:hqc-perf}
\begin{tabular}{lrrr}
\toprule
\textbf{Instance} & \textbf{KeyGen (kcycles)} & \textbf{Encaps (kcycles)} & \textbf{Decaps (kcycles)} \\
\midrule
HQC-128 & 76 & 150 & 353 \\
HQC-192 & 181 & 355 & 732 \\
HQC-256 & 363 & 720 & 1,435 \\
\bottomrule
\end{tabular}
\end{table}

\subsubsection{HQC vs. ML-KEM}

\begin{table}[H]
\centering
\caption{HQC vs. ML-KEM comparison (Level 1)}
\label{tab:hqc-vs-mlkem}
\begin{tabular}{lcc}
\toprule
\textbf{Aspect} & \textbf{HQC-128} & \textbf{ML-KEM-512} \\
\midrule
Public key & 2,249 B & 800 B \\
Ciphertext & 4,433 B & 768 B \\
Combined (pk + ct) & 6,682 B & 1,568 B \\
Security basis & QCSD & MLWE \\
Decryption failures & $\sim 2^{-64}$ & 0 \\
Cryptanalytic maturity & High & High \\
\bottomrule
\end{tabular}
\end{table}

\warningbox{HQC has significantly larger public keys and ciphertexts than ML-KEM. It is primarily valuable as cryptographic diversity---a backup in case unexpected weaknesses are found in lattice-based schemes.}

\subsection{BIKE (Bit Flipping Key Encapsulation)}
\label{subsec:bike}

BIKE is another code-based KEM based on QC-MDPC (Quasi-Cyclic Moderate Density Parity-Check) codes.

\subsubsection{Design}

BIKE features:
\begin{itemize}
    \item \textbf{QC-MDPC codes}: Efficient decoding via bit-flipping algorithms
    \item \textbf{Smaller keys than HQC}: More compact representation
    \item \textbf{IND-CPA construction}: Uses implicit rejection for CCA security
\end{itemize}

\subsubsection{Parameters}

\begin{table}[H]
\centering
\caption{BIKE parameter sets}
\label{tab:bike-params}
\begin{tabular}{lcccccc}
\toprule
\textbf{Instance} & \textbf{Security} & \textbf{$r$} & \textbf{$w$} & \textbf{pk} & \textbf{ct} & \textbf{ss} \\
\midrule
BIKE-L1 & Level 1 & 12,323 & 142 & 1,541 B & 1,573 B & 32 B \\
BIKE-L3 & Level 3 & 24,659 & 206 & 3,083 B & 3,115 B & 32 B \\
BIKE-L5 & Level 5 & 40,973 & 274 & 5,122 B & 5,154 B & 32 B \\
\bottomrule
\end{tabular}
\end{table}

\subsubsection{Decoding Failure Rate}

A critical consideration for BIKE is the non-zero decoding failure rate (DFR):

\begin{table}[H]
\centering
\caption{BIKE decoding failure rates}
\label{tab:bike-dfr}
\begin{tabular}{lc}
\toprule
\textbf{Instance} & \textbf{DFR} \\
\midrule
BIKE-L1 & $< 2^{-128}$ \\
BIKE-L3 & $< 2^{-192}$ \\
BIKE-L5 & $< 2^{-256}$ \\
\bottomrule
\end{tabular}
\end{table}

\infobox{While BIKE's DFR is extremely low in theory, implementation bugs or hardware faults could increase it. The decoding algorithm must be carefully implemented to achieve the theoretical DFR.}

\subsection{Classic McEliece}
\label{subsec:mceliece}

Classic McEliece is the most conservative code-based scheme, using binary Goppa codes with nearly 50 years of cryptanalysis.

\subsubsection{Design Philosophy}

\begin{itemize}
    \item \textbf{Minimal assumptions}: Uses well-studied Goppa codes
    \item \textbf{Conservative security}: Large safety margins
    \item \textbf{Very large keys}: Main drawback for practical deployment
    \item \textbf{Fast operations}: Once keys are loaded
\end{itemize}

\subsubsection{Parameters}

\begin{table}[H]
\centering
\caption{Classic McEliece parameter sets}
\label{tab:mceliece-params}
\begin{tabular}{lccccc}
\toprule
\textbf{Instance} & \textbf{Security} & \textbf{pk} & \textbf{sk} & \textbf{ct} & \textbf{ss} \\
\midrule
mceliece348864 & Level 1 & 261,120 B & 6,492 B & 128 B & 32 B \\
mceliece460896 & Level 3 & 524,160 B & 13,608 B & 188 B & 32 B \\
mceliece6688128 & Level 5 & 1,044,992 B & 13,932 B & 240 B & 32 B \\
mceliece6960119 & Level 5 & 1,047,319 B & 13,948 B & 226 B & 32 B \\
mceliece8192128 & Level 5 & 1,357,824 B & 14,120 B & 240 B & 32 B \\
\bottomrule
\end{tabular}
\end{table}

\warningbox{Classic McEliece public keys are 256 KB to 1.3 MB---far too large for most IoT devices. However, ciphertexts are very small (128--240 B), making it suitable for scenarios where the public key can be pre-installed.}

\subsubsection{IoT Applicability}

Classic McEliece may be suitable for specific IoT scenarios:
\begin{itemize}
    \item \textbf{Gateway devices}: With sufficient storage for public keys
    \item \textbf{Pre-provisioned keys}: Factory-installed public keys
    \item \textbf{Asymmetric bandwidth}: Small uplink, large storage
    \item \textbf{Long-term security}: Where conservative choices are mandated
\end{itemize}

\subsection{Code-Based Schemes Summary}
\label{subsec:code-summary}

\begin{table}[H]
\centering
\caption{Code-based schemes comparison (Level 1)}
\label{tab:code-comparison}
\begin{tabular}{lccccc}
\toprule
\textbf{Scheme} & \textbf{pk} & \textbf{ct} & \textbf{Security Basis} & \textbf{DFR} & \textbf{IoT} \\
\midrule
HQC-128 & 2,249 B & 4,433 B & QCSD & $2^{-64}$ & Limited \\
BIKE-L1 & 1,541 B & 1,573 B & QC-MDPC & $2^{-128}$ & Limited \\
McEliece348864 & 261 KB & 128 B & Goppa & 0 & No* \\
\midrule
ML-KEM-512 & 800 B & 768 B & MLWE & 0 & Yes \\
\bottomrule
\end{tabular}
\begin{tablenotes}
\small
\item *Except for pre-provisioned key scenarios
\end{tablenotes}
\end{table}

\section{Isogeny-Based Cryptography}
\label{sec:isogeny}

Isogeny-based cryptography uses the mathematical structure of elliptic curve isogenies. While promising for compact keys, the field has experienced significant setbacks.

\subsection{Mathematical Background}
\label{subsec:isogeny-math}

\begin{definition}[Isogeny]
An \emph{isogeny} $\phi: E_1 \rightarrow E_2$ between elliptic curves is a non-constant morphism that preserves the group structure: $\phi(P + Q) = \phi(P) + \phi(Q)$.
\end{definition}

\begin{definition}[Supersingular Isogeny Problem]
Given two supersingular elliptic curves $E_1$ and $E_2$ over $\mathbb{F}_{p^2}$, find an isogeny $\phi: E_1 \rightarrow E_2$.
\end{definition}

\placeholder{0.7\textwidth}{Illustration of isogeny graph: nodes are elliptic curves, edges are isogenies of fixed degree}

\subsection{SIDH/SIKE: A Cautionary Tale}
\label{subsec:sidh-broken}

SIKE (Supersingular Isogeny Key Encapsulation) was a NIST Round 4 candidate with remarkably compact parameters:

\begin{table}[H]
\centering
\caption{SIKE parameters (before break)}
\label{tab:sike-params}
\begin{tabular}{lccc}
\toprule
\textbf{Instance} & \textbf{pk} & \textbf{ct} & \textbf{ss} \\
\midrule
SIKEp434 & 330 B & 346 B & 16 B \\
SIKEp503 & 378 B & 402 B & 24 B \\
SIKEp751 & 564 B & 596 B & 32 B \\
\bottomrule
\end{tabular}
\end{table}

\warningbox{\textbf{SIKE was completely broken in 2022.} Castryck and Decru demonstrated a polynomial-time attack exploiting the auxiliary torsion point information provided in SIDH. The attack recovers the secret key in minutes on a laptop.}

\subsubsection{Lessons Learned}

The SIKE break provides important lessons:
\begin{enumerate}
    \item \textbf{Cryptanalysis continues}: Even schemes with years of analysis can fall
    \item \textbf{Diversity matters}: Multiple algorithm families provide insurance
    \item \textbf{Conservative choices}: Hash-based and code-based schemes have longer track records
    \item \textbf{Auxiliary data}: Extra information for efficiency can enable attacks
\end{enumerate}

\subsection{Post-SIKE Isogeny Research}
\label{subsec:post-sike}

Research continues on isogeny variants not affected by the SIDH attack:

\begin{itemize}
    \item \textbf{CSIDH}: Commutative SIDH using supersingular curves over $\mathbb{F}_p$
    \item \textbf{SQIsign}: Signature scheme based on quaternion isogenies
    \item \textbf{OSIDH}: Oriented SIDH with different auxiliary information
\end{itemize}

However, these schemes are currently slower and less mature than lattice alternatives.

\section{Multivariate Cryptography}
\label{sec:multivariate}

Multivariate cryptography bases security on the difficulty of solving systems of multivariate polynomial equations.

\subsection{Theoretical Foundation}
\label{subsec:mv-theory}

\begin{definition}[MQ Problem]
Given a system of $m$ quadratic polynomials $p_1, \ldots, p_m$ in $n$ variables over $\mathbb{F}_q$:
\[
p_i(x_1, \ldots, x_n) = \sum_{j \leq k} a_{i,j,k} x_j x_k + \sum_j b_{i,j} x_j + c_i
\]
find $(x_1, \ldots, x_n) \in \mathbb{F}_q^n$ such that $p_i(x_1, \ldots, x_n) = 0$ for all $i$.
\end{definition}

The MQ problem is NP-hard, and no efficient quantum algorithm is known.

\subsection{Signature Schemes}
\label{subsec:mv-signatures}

Multivariate schemes excel at signatures (small signatures) but struggle with encryption (large public keys).

\subsubsection{Rainbow (Broken)}

Rainbow was a NIST Round 3 finalist with very small signatures:

\begin{table}[H]
\centering
\caption{Rainbow parameters (before break)}
\label{tab:rainbow-params}
\begin{tabular}{lcccc}
\toprule
\textbf{Instance} & \textbf{Security} & \textbf{pk} & \textbf{sk} & \textbf{sig} \\
\midrule
Rainbow-I & Level 1 & 161 KB & 103 KB & 66 B \\
Rainbow-III & Level 3 & 882 KB & 626 KB & 164 B \\
Rainbow-V & Level 5 & 1.9 MB & 1.4 MB & 212 B \\
\bottomrule
\end{tabular}
\end{table}

\warningbox{\textbf{Rainbow was broken in 2022.} Ward Beullens demonstrated an attack recovering the secret key in about a weekend of computation. This eliminated Rainbow from NIST consideration.}

\subsubsection{Surviving Multivariate Schemes}

Some multivariate schemes remain unbroken:
\begin{itemize}
    \item \textbf{GeMSS}: Based on HFEv- with large public keys
    \item \textbf{MAYO}: Recent design with smaller parameters
    \item \textbf{UOV}: Unbalanced Oil and Vinegar (Rainbow's predecessor)
\end{itemize}

However, public key sizes remain prohibitive for IoT (hundreds of KB to MB).

\subsection{Multivariate for IoT}
\label{subsec:mv-iot}

\begin{table}[H]
\centering
\caption{Multivariate schemes IoT assessment}
\label{tab:mv-iot}
\begin{tabular}{lccc}
\toprule
\textbf{Aspect} & \textbf{Rating} & \textbf{Notes} \\
\midrule
Public key size & \textcolor{red}{Poor} & 100s KB to MBs \\
Signature size & \textcolor{nist-green}{Excellent} & 10s to 100s bytes \\
Signing speed & \textcolor{nist-green}{Good} & Fast operations \\
Verification speed & \textcolor{nist-green}{Good} & Fast operations \\
Security confidence & \textcolor{warning-orange}{Medium} & Recent breaks \\
\bottomrule
\end{tabular}
\end{table}

\textbf{Conclusion}: Multivariate schemes are not recommended for general IoT use due to large public keys and recent cryptanalytic advances.

\section{Stateful Hash-Based Signatures}
\label{sec:stateful-hbs}

Unlike SLH-DSA (stateless), stateful hash-based signatures like XMSS and LMS offer smaller signatures but require careful state management.

\subsection{LMS (Leighton-Micali Signatures)}
\label{subsec:lms}

LMS is standardized in RFC 8554 and NIST SP 800-208.

\subsubsection{Design}

\begin{itemize}
    \item \textbf{Merkle tree}: Binary tree of one-time signature (OTS) public keys
    \item \textbf{Winternitz OTS}: Efficient one-time signatures at leaves
    \item \textbf{State management}: Must track which OTS keys are used
\end{itemize}

\subsubsection{Parameters}

\begin{table}[H]
\centering
\caption{LMS parameter examples}
\label{tab:lms-params}
\begin{tabular}{lcccc}
\toprule
\textbf{Tree Height} & \textbf{Signatures} & \textbf{pk} & \textbf{sig} & \textbf{Security} \\
\midrule
$h = 5$ & $2^5 = 32$ & 56 B & 1,616 B & 128-bit \\
$h = 10$ & $2^{10} = 1,024$ & 56 B & 1,776 B & 128-bit \\
$h = 15$ & $2^{15} = 32,768$ & 56 B & 1,936 B & 128-bit \\
$h = 20$ & $2^{20} \approx 1$M & 56 B & 2,096 B & 128-bit \\
$h = 25$ & $2^{25} \approx 33$M & 56 B & 2,256 B & 128-bit \\
\bottomrule
\end{tabular}
\end{table}

\subsubsection{HSS (Hierarchical Signature System)}

HSS extends LMS with multiple tree levels:
\begin{itemize}
    \item Each tree authenticates the next level's public key
    \item Total signatures: $2^{h_1 + h_2 + \cdots + h_L}$
    \item Larger signatures but more signing capacity
\end{itemize}

\subsection{XMSS (eXtended Merkle Signature Scheme)}
\label{subsec:xmss}

XMSS is standardized in RFC 8391 and offers similar functionality to LMS with different design choices.

\begin{table}[H]
\centering
\caption{XMSS vs. LMS comparison}
\label{tab:xmss-vs-lms}
\begin{tabular}{lcc}
\toprule
\textbf{Aspect} & \textbf{XMSS} & \textbf{LMS} \\
\midrule
Standardization & RFC 8391, SP 800-208 & RFC 8554, SP 800-208 \\
OTS scheme & WOTS+ & LM-OTS \\
Signature size & Slightly larger & Slightly smaller \\
Flexibility & More options & Simpler \\
Adoption & Research focus & Industry focus \\
\bottomrule
\end{tabular}
\end{table}

\subsection{State Management Challenges}
\label{subsec:state-management}

\warningbox{\textbf{Critical}: Reusing a one-time signature key in stateful HBS completely breaks security. State must be reliably persisted after every signature operation.}

State management requirements:
\begin{enumerate}
    \item \textbf{Atomic updates}: State must be updated before signature release
    \item \textbf{Persistent storage}: Non-volatile memory required
    \item \textbf{Crash recovery}: Handle interrupted operations
    \item \textbf{No rollback}: State must never decrease
    \item \textbf{Backup coordination}: State replication is dangerous
\end{enumerate}

\subsubsection{IoT State Management Approaches}

\begin{table}[H]
\centering
\caption{State management strategies for IoT}
\label{tab:state-strategies}
\begin{tabular}{lcc}
\toprule
\textbf{Strategy} & \textbf{Reliability} & \textbf{Overhead} \\
\midrule
EEPROM/Flash counter & Medium & Low \\
Wear-leveled NVM & High & Medium \\
Monotonic hardware counter & High & Low \\
Remote state server & High & High latency \\
Reserved key ranges & Medium & Wastes keys \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Stateful vs. Stateless Comparison}
\label{subsec:stateful-vs-stateless}

\begin{table}[H]
\centering
\caption{Stateful (LMS) vs. Stateless (SLH-DSA) signatures}
\label{tab:stateful-vs-stateless}
\begin{tabular}{lcc}
\toprule
\textbf{Aspect} & \textbf{LMS/XMSS} & \textbf{SLH-DSA} \\
\midrule
Signature size & 1.6--2.3 KB & 7.8--50 KB \\
Public key & 56--64 B & 32--64 B \\
Signing speed & Fast & Slow \\
State required & Yes (critical) & No \\
Key lifetime & Limited signatures & Unlimited \\
Implementation risk & State corruption & None \\
IoT suitability & Limited & Better \\
\bottomrule
\end{tabular}
\end{table}

\infobox{For IoT devices, \textbf{SLH-DSA is generally preferred} over stateful schemes despite larger signatures. The risk of state corruption leading to complete security failure is often unacceptable in deployed IoT systems.}

\section{Hybrid Schemes}
\label{sec:hybrid-schemes}

Hybrid cryptography combines classical and post-quantum algorithms to provide security against both current and future threats.

\subsection{Motivation}
\label{subsec:hybrid-motivation}

Reasons for hybrid deployment:
\begin{enumerate}
    \item \textbf{Hedging}: Protect against weaknesses in either algorithm
    \item \textbf{Compliance}: Meet current standards while preparing for PQ
    \item \textbf{Gradual migration}: Maintain compatibility during transition
    \item \textbf{Defense in depth}: Multiple security layers
\end{enumerate}

\subsection{Hybrid KEM Construction}
\label{subsec:hybrid-kem-construction}

\begin{algorithm}[H]
\caption{Generic Hybrid KEM}
\label{alg:hybrid-kem-generic}
\begin{algorithmic}[1]
\State \textbf{// Key Generation}
\State $(pk_1, sk_1) \gets \text{Classical.KeyGen}()$ \Comment{e.g., X25519}
\State $(pk_2, sk_2) \gets \text{PQ.KeyGen}()$ \Comment{e.g., ML-KEM}
\State $pk \gets pk_1 \| pk_2$; $sk \gets sk_1 \| sk_2$
\State
\State \textbf{// Encapsulation}
\State $(ss_1, ct_1) \gets \text{Classical.Encaps}(pk_1)$
\State $(ss_2, ct_2) \gets \text{PQ.Encaps}(pk_2)$
\State $ct \gets ct_1 \| ct_2$
\State $K \gets \text{KDF}(ss_1 \| ss_2 \| ct)$ \Comment{Bind to ciphertext}
\State
\State \textbf{// Decapsulation}
\State $ss_1 \gets \text{Classical.Decaps}(sk_1, ct_1)$
\State $ss_2 \gets \text{PQ.Decaps}(sk_2, ct_2)$
\State $K \gets \text{KDF}(ss_1 \| ss_2 \| ct)$
\end{algorithmic}
\end{algorithm}

\subsection{Deployed Hybrid Schemes}
\label{subsec:deployed-hybrids}

\begin{table}[H]
\centering
\caption{Hybrid schemes in deployment}
\label{tab:hybrid-deployed}
\begin{tabular}{llcc}
\toprule
\textbf{Name} & \textbf{Components} & \textbf{pk + ct} & \textbf{User} \\
\midrule
X25519Kyber768 & X25519 + ML-KEM-768 & 1,248 B & Cloudflare, Google \\
P256Kyber768 & ECDH P-256 + ML-KEM-768 & 1,280 B & Various \\
X25519Kyber512 & X25519 + ML-KEM-512 & 896 B & Signal (PQXDH) \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Hybrid Signatures}
\label{subsec:hybrid-signatures}

Hybrid signatures are more complex due to binding requirements:

\begin{lstlisting}[language=C, caption={Hybrid signature construction}, label={lst:hybrid-sig}]
// Hybrid signature: both must verify for acceptance
typedef struct {
    uint8_t classical_sig[ECDSA_SIG_SIZE];
    uint8_t pq_sig[MLDSA_SIG_SIZE];
} hybrid_signature_t;

int hybrid_sign(hybrid_signature_t *sig, 
                const uint8_t *msg, size_t msg_len,
                const classical_sk_t *classical_sk,
                const pq_sk_t *pq_sk) {
    // Sign with both algorithms
    ecdsa_sign(sig->classical_sig, msg, msg_len, classical_sk);
    ml_dsa_sign(sig->pq_sig, msg, msg_len, pq_sk);
    return 0;
}

int hybrid_verify(const hybrid_signature_t *sig,
                  const uint8_t *msg, size_t msg_len,
                  const classical_pk_t *classical_pk,
                  const pq_pk_t *pq_pk) {
    // Both must verify
    int r1 = ecdsa_verify(sig->classical_sig, msg, msg_len, classical_pk);
    int r2 = ml_dsa_verify(sig->pq_sig, msg, msg_len, pq_pk);
    return (r1 == 0 && r2 == 0) ? 0 : -1;
}
\end{lstlisting}

\section{Comparative Analysis}
\label{sec:alt-comparison}

\subsection{Algorithm Family Summary}
\label{subsec:family-summary}

\begin{table}[H]
\centering
\caption{PQC algorithm families comparison}
\label{tab:family-comparison}
\begin{tabular}{lccccc}
\toprule
\textbf{Family} & \textbf{Key Size} & \textbf{Speed} & \textbf{Maturity} & \textbf{IoT} & \textbf{Status} \\
\midrule
Lattice & Medium & Fast & High & \textcolor{nist-green}{Good} & NIST Std \\
Hash-based & Small/Large & Slow/Med & Very High & \textcolor{warning-orange}{Limited} & NIST Std \\
Code-based & Large & Medium & High & \textcolor{warning-orange}{Limited} & Round 4 \\
Isogeny & Small & Slow & Low & \textcolor{red}{No} & Broken* \\
Multivariate & Very Large & Fast & Medium & \textcolor{red}{No} & Broken* \\
\bottomrule
\end{tabular}
\begin{tablenotes}
\small
\item *Major schemes broken; research continues on variants
\end{tablenotes}
\end{table}

\subsection{IoT Suitability Matrix}
\label{subsec:iot-matrix}

\begin{table}[H]
\centering
\caption{Scheme suitability by IoT device class}
\label{tab:iot-suitability}
\begin{tabular}{lcccc}
\toprule
\textbf{Scheme} & \textbf{Class 1} & \textbf{Class 2} & \textbf{Class 3} & \textbf{Gateway} \\
 & ($<$10KB) & ($\sim$50KB) & ($>$256KB) & (Linux) \\
\midrule
ML-KEM-512 & \textcolor{warning-orange}{○} & \textcolor{nist-green}{●} & \textcolor{nist-green}{●} & \textcolor{nist-green}{●} \\
ML-KEM-768 & \textcolor{red}{✗} & \textcolor{nist-green}{●} & \textcolor{nist-green}{●} & \textcolor{nist-green}{●} \\
ML-DSA-44 & \textcolor{red}{✗} & \textcolor{warning-orange}{○} & \textcolor{nist-green}{●} & \textcolor{nist-green}{●} \\
Falcon-512 & \textcolor{red}{✗} & \textcolor{warning-orange}{○} & \textcolor{nist-green}{●} & \textcolor{nist-green}{●} \\
SLH-DSA-128f & \textcolor{red}{✗} & \textcolor{warning-orange}{○} & \textcolor{nist-green}{●} & \textcolor{nist-green}{●} \\
HQC-128 & \textcolor{red}{✗} & \textcolor{red}{✗} & \textcolor{warning-orange}{○} & \textcolor{nist-green}{●} \\
BIKE-L1 & \textcolor{red}{✗} & \textcolor{red}{✗} & \textcolor{warning-orange}{○} & \textcolor{nist-green}{●} \\
McEliece & \textcolor{red}{✗} & \textcolor{red}{✗} & \textcolor{red}{✗} & \textcolor{warning-orange}{○} \\
\bottomrule
\end{tabular}
\begin{tablenotes}
\small
\item ● Suitable \quad ○ Limited/Possible \quad ✗ Not recommended
\end{tablenotes}
\end{table}

\section{Chapter Summary}
\label{sec:ch5-summary}

This chapter surveyed alternative and emerging post-quantum schemes:

\textbf{Code-Based (HQC, BIKE, McEliece)}:
\begin{itemize}
    \item Long cryptanalytic history, conservative security
    \item Larger keys/ciphertexts than lattice schemes
    \item HQC selected for NIST Round 4 standardization
    \item Limited IoT applicability due to sizes
\end{itemize}

\textbf{Isogeny-Based (SIDH/SIKE)}:
\begin{itemize}
    \item Compact parameters were attractive
    \item \textbf{Completely broken in 2022}
    \item Research continues on variants
    \item Not recommended for deployment
\end{itemize}

\textbf{Multivariate (Rainbow, etc.)}:
\begin{itemize}
    \item Small signatures but huge public keys
    \item Rainbow broken in 2022
    \item Not suitable for IoT
\end{itemize}

\textbf{Stateful Hash-Based (LMS, XMSS)}:
\begin{itemize}
    \item Smaller signatures than SLH-DSA
    \item Critical state management requirements
    \item Risk of catastrophic failure from state corruption
    \item Generally not recommended for IoT
\end{itemize}

\textbf{Hybrid Schemes}:
\begin{itemize}
    \item Combine classical and PQ algorithms
    \item Recommended during transition period
    \item Already deployed by major providers
\end{itemize}

\infobox{For IoT applications, \textbf{lattice-based schemes (ML-KEM, ML-DSA)} remain the primary recommendation. Code-based schemes provide valuable diversity but are secondary choices due to larger sizes. Avoid isogeny and multivariate schemes.}

% End of Chapter 5

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% CHAPTER 6: IMPLEMENTATION FOR IOT
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Implementation for IoT Devices}
\label{ch:implementation}

This chapter provides practical guidance for implementing post-quantum cryptography on resource-constrained IoT devices. We cover hardware platforms, optimization techniques, memory management, and real-world deployment considerations.

\section{IoT Hardware Landscape}
\label{sec:iot-hardware}

\subsection{Processor Architectures}
\label{subsec:processors}

IoT devices span a wide range of computational capabilities:

\begin{table}[H]
\centering
\caption{Common IoT processor families}
\label{tab:iot-processors}
\begin{tabular}{lcccc}
\toprule
\textbf{Family} & \textbf{Bits} & \textbf{Speed} & \textbf{RAM} & \textbf{Use Case} \\
\midrule
ATmega (AVR) & 8 & 8--20 MHz & 2--8 KB & Simple sensors \\
MSP430 & 16 & 8--25 MHz & 2--16 KB & Low-power sensors \\
ARM Cortex-M0/M0+ & 32 & 24--48 MHz & 8--32 KB & Wearables \\
ARM Cortex-M3 & 32 & 48--120 MHz & 32--128 KB & Industrial IoT \\
ARM Cortex-M4/M4F & 32 & 80--180 MHz & 128--512 KB & Advanced IoT \\
ARM Cortex-M7 & 32 & 200--600 MHz & 512 KB--1 MB & IoT gateways \\
ARM Cortex-M33 & 32 & 100--200 MHz & 256--512 KB & Secure IoT \\
RISC-V (various) & 32 & 50--400 MHz & 64 KB--1 MB & Emerging IoT \\
ESP32 (Xtensa) & 32 & 160--240 MHz & 520 KB & WiFi/BLE IoT \\
\bottomrule
\end{tabular}
\end{table}

\subsection{ARM Cortex-M Series Deep Dive}
\label{subsec:cortex-m}

The ARM Cortex-M series dominates IoT applications. Understanding their features is essential for PQC optimization.

\begin{table}[H]
\centering
\caption{ARM Cortex-M feature comparison for cryptography}
\label{tab:cortex-m-features}
\begin{tabular}{lccccc}
\toprule
\textbf{Feature} & \textbf{M0+} & \textbf{M3} & \textbf{M4} & \textbf{M7} & \textbf{M33} \\
\midrule
Pipeline stages & 2 & 3 & 3 & 6 & 3 \\
Hardware multiply & 1 or 32 cyc & 1 cyc & 1 cyc & 1 cyc & 1 cyc \\
Hardware divide & No & Yes & Yes & Yes & Yes \\
DSP instructions & No & No & Yes & Yes & Yes \\
FPU & No & No & Optional & Yes & Optional \\
SIMD & No & No & Yes & Yes & Yes \\
Cache & No & No & No & Yes & Optional \\
TrustZone & No & No & No & No & Yes \\
Crypto accelerator & Rare & Rare & Common & Common & Common \\
\bottomrule
\end{tabular}
\end{table}

\subsubsection{DSP Instructions for PQC}

The Cortex-M4/M7 DSP extensions provide significant speedups for PQC:

\begin{lstlisting}[language=C, caption={Using DSP instructions for coefficient operations}, label={lst:dsp-coeff}]
// SMUAD: Dual 16-bit multiply with 32-bit accumulate
// Useful for NTT butterfly operations
static inline int32_t dual_multiply_add(int32_t a, int32_t b) {
    int32_t result;
    __asm__ volatile (
        "smuad %0, %1, %2"
        : "=r" (result)
        : "r" (a), "r" (b)
    );
    return result;
}

// SMLADX: Dual multiply-accumulate with exchange
// a[15:0]*b[31:16] + a[31:16]*b[15:0] + acc
static inline int32_t butterfly_mac(int32_t a, int32_t b, int32_t acc) {
    int32_t result;
    __asm__ volatile (
        "smladx %0, %1, %2, %3"
        : "=r" (result)
        : "r" (a), "r" (b), "r" (acc)
    );
    return result;
}
\end{lstlisting}

\subsection{Memory Hierarchy}
\label{subsec:memory-hierarchy}

IoT devices have constrained memory organized in distinct regions:

\begin{table}[H]
\centering
\caption{Typical memory organization in IoT MCUs}
\label{tab:memory-organization}
\begin{tabular}{lccc}
\toprule
\textbf{Memory Type} & \textbf{Size Range} & \textbf{Speed} & \textbf{Purpose} \\
\midrule
SRAM (main) & 32--512 KB & Fast & Stack, heap, variables \\
SRAM (TCM) & 0--64 KB & Fastest & Critical code/data \\
Flash (internal) & 256 KB--2 MB & Medium & Program code \\
Flash (external) & 1--16 MB & Slow & Large data, OTA \\
EEPROM & 0--64 KB & Slow & Persistent config \\
\bottomrule
\end{tabular}
\end{table}

\placeholder{0.8\textwidth}{Memory map diagram showing typical STM32 layout with Flash, SRAM, CCM-SRAM, peripherals}

\section{Memory Optimization}
\label{sec:memory-optimization}

\subsection{Stack Usage Analysis}
\label{subsec:stack-usage}

PQC algorithms require careful stack management. Here is the detailed stack analysis for the pqm4 implementations:

\begin{table}[H]
\centering
\caption{Detailed stack usage on ARM Cortex-M4 (bytes)}
\label{tab:stack-detailed}
\begin{tabular}{llrrr}
\toprule
\textbf{Algorithm} & \textbf{Variant} & \textbf{KeyGen} & \textbf{Enc/Sign} & \textbf{Dec/Verify} \\
\midrule
\multicolumn{5}{c}{\textit{Key Encapsulation}} \\
\midrule
ML-KEM-512 & m4fstack & 2,300 & 2,348 & 2,332 \\
ML-KEM-768 & m4fstack & 2,556 & 2,604 & 2,588 \\
ML-KEM-1024 & m4fstack & 2,812 & 2,860 & 2,844 \\
ML-KEM-512 & m4fspeed & 2,632 & 2,720 & 3,080 \\
ML-KEM-768 & m4fspeed & 3,144 & 3,232 & 3,592 \\
ML-KEM-1024 & m4fspeed & 3,656 & 3,744 & 4,104 \\
\midrule
\multicolumn{5}{c}{\textit{Digital Signatures}} \\
\midrule
ML-DSA-44 & m4f & 10,328 & 24,512 & 10,680 \\
ML-DSA-65 & m4f & 14,472 & 34,752 & 15,336 \\
ML-DSA-87 & m4f & 18,104 & 43,968 & 19,992 \\
Falcon-512 & opt & 2,096 & 39,000 & 2,024 \\
Falcon-1024 & opt & 2,472 & 79,000 & 3,048 \\
\bottomrule
\end{tabular}
\end{table}

\warningbox{ML-DSA signing requires up to 44 KB of stack space. Ensure your IoT device has adequate SRAM and that the stack is sized appropriately. Stack overflow causes hard-to-diagnose failures.}

\subsection{Stack Reduction Techniques}
\label{subsec:stack-reduction}

\subsubsection{On-the-Fly Matrix Generation}

Instead of storing the full public matrix $\mathbf{A}$, regenerate columns as needed:

\begin{lstlisting}[language=C, caption={On-the-fly matrix generation}, label={lst:otf-matrix}]
// Memory-efficient: generate matrix column by column
void matrix_vector_mul_otf(poly *result, const uint8_t seed[32],
                           const polyvec *vec, int k) {
    poly a_col;
    
    for (int i = 0; i < k; i++) {
        result[i] = 0;
        for (int j = 0; j < k; j++) {
            // Generate A[i][j] on-the-fly
            gen_matrix_entry(&a_col, seed, i, j);
            // Multiply and accumulate
            poly_basemul_acc(&result[i], &a_col, &vec->vec[j]);
        }
    }
}

// Contrast: Full matrix storage (not recommended for constrained devices)
// poly A[K][K];  // Would require K*K*512 bytes = 18KB for K=3
\end{lstlisting}

\subsubsection{Streaming Hash Computation}

Process data incrementally instead of buffering:

\begin{lstlisting}[language=C, caption={Streaming SHAKE for large inputs}, label={lst:streaming-shake}]
// Memory-efficient message hashing
void hash_message_streaming(uint8_t *output, size_t outlen,
                            const uint8_t *prefix, size_t prefix_len,
                            const uint8_t *msg, size_t msg_len) {
    shake256_ctx ctx;
    shake256_init(&ctx);
    
    // Process prefix (e.g., domain separator)
    shake256_absorb(&ctx, prefix, prefix_len);
    
    // Process message in chunks (for very large messages)
    const size_t CHUNK_SIZE = 1024;
    while (msg_len > CHUNK_SIZE) {
        shake256_absorb(&ctx, msg, CHUNK_SIZE);
        msg += CHUNK_SIZE;
        msg_len -= CHUNK_SIZE;
    }
    shake256_absorb(&ctx, msg, msg_len);
    
    // Finalize and squeeze output
    shake256_finalize(&ctx);
    shake256_squeeze(&ctx, output, outlen);
}
\end{lstlisting}

\subsection{Code Size Optimization}
\label{subsec:code-size}

\begin{table}[H]
\centering
\caption{Code size (.text section) on ARM Cortex-M4 (bytes)}
\label{tab:code-size}
\begin{tabular}{llr}
\toprule
\textbf{Algorithm} & \textbf{Variant} & \textbf{Code Size} \\
\midrule
ML-KEM-512 & clean & 6,036 \\
ML-KEM-512 & m4fspeed & 12,044 \\
ML-KEM-512 & m4fstack & 10,644 \\
ML-KEM-768 & m4fspeed & 12,044 \\
ML-KEM-1024 & m4fspeed & 12,044 \\
\midrule
ML-DSA-44 & clean & 14,824 \\
ML-DSA-44 & m4f & 21,316 \\
ML-DSA-65 & m4f & 21,892 \\
ML-DSA-87 & m4f & 22,372 \\
\midrule
Falcon-512 & clean & 82,340 \\
Falcon-512 & opt & 86,180 \\
\bottomrule
\end{tabular}
\end{table}

\subsubsection{Code Size Reduction Strategies}

\begin{enumerate}
    \item \textbf{Algorithm selection}: Choose reference implementations for size over speed
    \item \textbf{Compiler flags}: Use \texttt{-Os} (optimize for size) instead of \texttt{-O3}
    \item \textbf{Link-time optimization}: \texttt{-flto} eliminates unused code
    \item \textbf{Shared functions}: Common operations (NTT, hashing) shared across algorithms
    \item \textbf{Parameter specialization}: Compile only for needed parameter sets
\end{enumerate}

\begin{lstlisting}[language=make, caption={Compiler flags for size optimization}, label={lst:size-flags}]
# Makefile flags for minimal code size
CFLAGS_SIZE = -Os \
              -ffunction-sections \
              -fdata-sections \
              -fno-exceptions \
              -fno-rtti \
              -fno-unwind-tables

LDFLAGS_SIZE = -Wl,--gc-sections \
               -flto \
               -specs=nano.specs
\end{lstlisting}

\section{Performance Optimization}
\label{sec:performance-opt}

\subsection{NTT Optimization}
\label{subsec:ntt-opt}

The Number Theoretic Transform is the performance-critical operation in lattice-based PQC.

\subsubsection{Montgomery Arithmetic}

Montgomery reduction avoids expensive division:

\begin{lstlisting}[language=C, caption={Montgomery multiplication for ML-KEM}, label={lst:mont-mul}]
// Constants for q = 3329
#define KYBER_Q 3329
#define MONT_R 2285      // R mod q where R = 2^16
#define QINV (-3327)     // q^{-1} mod 2^16

// Montgomery reduction: compute a * R^{-1} mod q
// Input: a in [-q*2^15, q*2^15]
// Output: result in [-q, q]
int16_t montgomery_reduce(int32_t a) {
    int16_t t;
    t = (int16_t)a * QINV;
    t = (a - (int32_t)t * KYBER_Q) >> 16;
    return t;
}

// Barrett reduction for final reduction to [0, q)
int16_t barrett_reduce(int16_t a) {
    int16_t t;
    const int16_t v = ((1 << 26) + KYBER_Q / 2) / KYBER_Q;
    t = ((int32_t)v * a + (1 << 25)) >> 26;
    t *= KYBER_Q;
    return a - t;
}
\end{lstlisting}

\subsubsection{Optimized NTT Butterfly}

\begin{lstlisting}[language=C, caption={Optimized NTT butterfly for Cortex-M4}, label={lst:ntt-butterfly}]
// NTT butterfly with Montgomery multiplication
// Computes: a = a + w*b, b = a - w*b (mod q)
static inline void butterfly(int16_t *a, int16_t *b, int16_t w) {
    int16_t t = montgomery_reduce((int32_t)w * *b);
    *b = *a - t;
    *a = *a + t;
}

// Full NTT using Cooley-Tukey, in-place
void ntt(int16_t r[256]) {
    unsigned int len, start, j, k;
    int16_t t, zeta;
    
    k = 1;
    for (len = 128; len >= 2; len >>= 1) {
        for (start = 0; start < 256; start = j + len) {
            zeta = zetas[k++];
            for (j = start; j < start + len; j++) {
                t = montgomery_reduce((int32_t)zeta * r[j + len]);
                r[j + len] = r[j] - t;
                r[j] = r[j] + t;
            }
        }
    }
}
\end{lstlisting}

\subsubsection{Assembly Optimization}

For maximum performance, critical loops are written in assembly:

\begin{lstlisting}[language={[ARM]Assembler}, caption={ARM assembly NTT butterfly (simplified)}, label={lst:asm-butterfly}]
// ARM Cortex-M4 assembly for butterfly operation
// Uses SMULBB, SMLABB for efficient 16x16->32 multiplication
.syntax unified
.thumb

.global butterfly_asm
.type butterfly_asm, %function
butterfly_asm:
    // r0 = pointer to a, r1 = pointer to b, r2 = zeta
    ldrsh r3, [r0]        // Load a
    ldrsh r4, [r1]        // Load b
    
    // t = zeta * b (Montgomery domain)
    smulbb r5, r2, r4     // r5 = zeta * b
    
    // Montgomery reduction
    mul r6, r5, r7        // r6 = t * QINV (low 16 bits)
    sxth r6, r6
    mls r5, r6, r8, r5    // r5 = t - r6 * Q
    asr r5, r5, #16       // r5 = result >> 16
    
    // Butterfly
    add r6, r3, r5        // a' = a + t
    sub r7, r3, r5        // b' = a - t
    
    strh r6, [r0]         // Store a'
    strh r7, [r1]         // Store b'
    bx lr
\end{lstlisting}

\subsection{Hash Function Optimization}
\label{subsec:hash-opt}

SHA-3/SHAKE often dominates runtime in PQC implementations.

\begin{table}[H]
\centering
\caption{SHA-3 Keccak-f[1600] performance on various platforms}
\label{tab:keccak-perf}
\begin{tabular}{lcc}
\toprule
\textbf{Platform} & \textbf{Cycles/permutation} & \textbf{Implementation} \\
\midrule
Cortex-M0+ & $\sim$50,000 & Reference C \\
Cortex-M3 & $\sim$12,000 & Optimized C \\
Cortex-M4 & $\sim$6,000 & Optimized C \\
Cortex-M4 & $\sim$4,500 & Assembly \\
Cortex-M7 & $\sim$3,000 & Assembly \\
x86-64 (AVX2) & $\sim$500 & AVX2 intrinsics \\
\bottomrule
\end{tabular}
\end{table}

\subsubsection{Platform-Specific Keccak}

\begin{lstlisting}[language=C, caption={Selecting optimal Keccak implementation}, label={lst:keccak-select}]
// Compile-time selection of Keccak implementation
#if defined(__ARM_ARCH_7EM__)  // Cortex-M4/M7
    #include "keccakf1600_armv7m.h"
    #define KECCAK_IMPL "ARMv7-M assembly"
#elif defined(__ARM_ARCH_6M__)  // Cortex-M0/M0+
    #include "keccakf1600_armv6m.h"
    #define KECCAK_IMPL "ARMv6-M optimized"
#elif defined(__AVX2__)
    #include "keccakf1600_avx2.h"
    #define KECCAK_IMPL "AVX2"
#else
    #include "keccakf1600_ref.h"
    #define KECCAK_IMPL "Reference C"
#endif
\end{lstlisting}

\subsection{Parallelism and Pipelining}
\label{subsec:parallelism}

\subsubsection{Instruction-Level Parallelism}

Modern MCUs can execute multiple operations per cycle with proper scheduling:

\begin{lstlisting}[language=C, caption={Loop unrolling for ILP}, label={lst:loop-unroll}]
// Unrolled polynomial addition for better ILP
void poly_add_unrolled(int16_t r[256], const int16_t a[256],
                       const int16_t b[256]) {
    for (int i = 0; i < 256; i += 8) {
        r[i+0] = a[i+0] + b[i+0];
        r[i+1] = a[i+1] + b[i+1];
        r[i+2] = a[i+2] + b[i+2];
        r[i+3] = a[i+3] + b[i+3];
        r[i+4] = a[i+4] + b[i+4];
        r[i+5] = a[i+5] + b[i+5];
        r[i+6] = a[i+6] + b[i+6];
        r[i+7] = a[i+7] + b[i+7];
    }
}
\end{lstlisting}

\subsubsection{SIMD on Cortex-M4}

The Cortex-M4 supports limited SIMD via packed operations:

\begin{lstlisting}[language=C, caption={SIMD polynomial operations}, label={lst:simd-poly}]
#include <arm_acle.h>

// Process two 16-bit coefficients at once
void poly_add_simd(int16_t r[256], const int16_t a[256],
                   const int16_t b[256]) {
    uint32_t *r32 = (uint32_t *)r;
    const uint32_t *a32 = (const uint32_t *)a;
    const uint32_t *b32 = (const uint32_t *)b;
    
    for (int i = 0; i < 128; i++) {
        // QADD16: Parallel saturating add of two 16-bit values
        r32[i] = __qadd16(a32[i], b32[i]);
    }
}
\end{lstlisting}

\section{Side-Channel Countermeasures}
\label{sec:side-channel}

\subsection{Timing Attacks}
\label{subsec:timing-attacks}

All cryptographic operations must execute in constant time regardless of secret values.

\subsubsection{Constant-Time Principles}

\begin{enumerate}
    \item \textbf{No secret-dependent branches}: Avoid \texttt{if (secret) ...}
    \item \textbf{No secret-dependent memory access}: Array indices must not depend on secrets
    \item \textbf{No variable-time instructions}: Avoid division, floating-point on some platforms
    \item \textbf{No early termination}: Complete all iterations regardless of values
\end{enumerate}

\begin{lstlisting}[language=C, caption={Constant-time primitives}, label={lst:ct-primitives}]
// Constant-time conditional select: return a if sel, else b
static inline uint32_t ct_select(uint32_t a, uint32_t b, uint32_t sel) {
    // sel must be 0 or 1
    uint32_t mask = -(uint32_t)sel;  // 0x00000000 or 0xFFFFFFFF
    return (a & mask) | (b & ~mask);
}

// Constant-time comparison: returns 0 if equal, non-zero otherwise
static inline uint32_t ct_compare(const uint8_t *a, const uint8_t *b, 
                                   size_t len) {
    uint32_t diff = 0;
    for (size_t i = 0; i < len; i++) {
        diff |= a[i] ^ b[i];
    }
    return diff;
}

// Constant-time conditional copy
static inline void ct_cmov(uint8_t *dst, const uint8_t *src, 
                           size_t len, uint8_t condition) {
    uint8_t mask = -(uint8_t)(condition != 0);
    for (size_t i = 0; i < len; i++) {
        dst[i] ^= mask & (dst[i] ^ src[i]);
    }
}
\end{lstlisting}

\subsubsection{Verifying Constant-Time Execution}

\begin{lstlisting}[language=bash, caption={Using ctgrind for verification}, label={lst:ctgrind}]
# Compile with debug symbols
gcc -g -O2 -o pqc_test pqc_test.c -lpqc

# Run under ctgrind (Valgrind plugin)
valgrind --tool=ctgrind ./pqc_test

# Alternative: Use timecop
gcc -fsanitize=memory -o pqc_test pqc_test.c -lpqc
./pqc_test
\end{lstlisting}

\subsection{Power Analysis}
\label{subsec:power-analysis}

Power consumption can reveal secret information through:
\begin{itemize}
    \item \textbf{Simple Power Analysis (SPA)}: Direct observation of power traces
    \item \textbf{Differential Power Analysis (DPA)}: Statistical analysis across many traces
    \item \textbf{Correlation Power Analysis (CPA)}: Correlation with hypothetical power models
\end{itemize}

\subsubsection{Countermeasures}

\begin{table}[H]
\centering
\caption{Power analysis countermeasures}
\label{tab:power-countermeasures}
\begin{tabular}{lcc}
\toprule
\textbf{Countermeasure} & \textbf{Overhead} & \textbf{Effectiveness} \\
\midrule
Masking (Boolean) & 2--3$\times$ & High \\
Masking (Arithmetic) & 3--5$\times$ & High \\
Shuffling & 1.5--2$\times$ & Medium \\
Hiding (random delays) & 1.2--1.5$\times$ & Low \\
Dual-rail logic & Hardware & Very High \\
\bottomrule
\end{tabular}
\end{table}

\begin{lstlisting}[language=C, caption={First-order Boolean masking}, label={lst:masking}]
// First-order Boolean masking for sensitive data
typedef struct {
    uint8_t share0[32];  // x0
    uint8_t share1[32];  // x1, where x = x0 XOR x1
} masked_key_t;

void mask_key(masked_key_t *masked, const uint8_t key[32]) {
    // Generate random mask
    randombytes(masked->share1, 32);
    // Compute first share: x0 = x XOR x1
    for (int i = 0; i < 32; i++) {
        masked->share0[i] = key[i] ^ masked->share1[i];
    }
}

void unmask_key(uint8_t key[32], const masked_key_t *masked) {
    for (int i = 0; i < 32; i++) {
        key[i] = masked->share0[i] ^ masked->share1[i];
    }
}
\end{lstlisting}

\subsection{Fault Attacks}
\label{subsec:fault-attacks}

Fault attacks induce errors (via voltage glitches, clock manipulation, lasers) to extract secrets.

\subsubsection{Countermeasures}

\begin{enumerate}
    \item \textbf{Redundant computation}: Compute twice and compare
    \item \textbf{Integrity checks}: Verify intermediate values
    \item \textbf{Infection}: Randomize output if fault detected
    \item \textbf{Hardware countermeasures}: Voltage/clock monitors
\end{enumerate}

\begin{lstlisting}[language=C, caption={Redundant computation for fault resistance}, label={lst:fault-resist}]
// Double computation with comparison
int secure_verify(const uint8_t *pk, const uint8_t *msg, size_t msg_len,
                  const uint8_t *sig) {
    int result1, result2;
    
    // First verification
    result1 = crypto_sign_verify(sig, msg, msg_len, pk);
    
    // Second verification (ideally with different implementation)
    result2 = crypto_sign_verify(sig, msg, msg_len, pk);
    
    // Both must agree
    if (result1 != result2) {
        // Fault detected! Take appropriate action
        fault_detected_handler();
        return -1;  // Reject
    }
    
    return result1;
}
\end{lstlisting}

\section{Hardware Acceleration}
\label{sec:hw-acceleration}

\subsection{Cryptographic Accelerators}
\label{subsec:crypto-accel}

Many modern MCUs include hardware acceleration for common operations:

\begin{table}[H]
\centering
\caption{Hardware crypto support in popular IoT MCUs}
\label{tab:hw-crypto}
\begin{tabular}{lccccc}
\toprule
\textbf{MCU Family} & \textbf{AES} & \textbf{SHA-2} & \textbf{SHA-3} & \textbf{RNG} & \textbf{PKA} \\
\midrule
STM32L4 & Yes & Yes & No & Yes & No \\
STM32U5 & Yes & Yes & Yes & Yes & No \\
STM32H7 & Yes & Yes & No & Yes & Yes \\
nRF52840 & Yes & No & No & Yes & No \\
ESP32-S3 & Yes & Yes & No & Yes & Yes \\
LPC55S69 & Yes & Yes & No & Yes & Yes \\
MAX32666 & Yes & Yes & No & Yes & Yes \\
\bottomrule
\end{tabular}
\end{table}

\subsubsection{Using Hardware SHA-3 (STM32U5)}

\begin{lstlisting}[language=C, caption={Hardware SHA-3 on STM32U5}, label={lst:hw-sha3}]
#include "stm32u5xx_hal.h"

HASH_HandleTypeDef hhash;

void sha3_256_hw(uint8_t *output, const uint8_t *input, size_t len) {
    // Configure for SHA3-256
    hhash.Init.DataType = HASH_DATATYPE_8B;
    hhash.Init.Algorithm = HASH_ALGOSELECTION_SHA3_256;
    HAL_HASH_Init(&hhash);
    
    // Process data
    HAL_HASHEx_SHA3_256_Start(&hhash, (uint8_t *)input, len, 
                               output, HAL_MAX_DELAY);
}

// SHAKE256 XOF using hardware
void shake256_hw(uint8_t *output, size_t outlen,
                 const uint8_t *input, size_t inlen) {
    hhash.Init.Algorithm = HASH_ALGOSELECTION_SHAKE256;
    HAL_HASH_Init(&hhash);
    
    // Absorb
    HAL_HASHEx_SHAKE256_Start(&hhash, (uint8_t *)input, inlen,
                               output, HAL_MAX_DELAY);
    
    // Squeeze additional output if needed
    while (outlen > 32) {
        HAL_HASHEx_SHAKE256_Squeeze(&hhash, output, 32, HAL_MAX_DELAY);
        output += 32;
        outlen -= 32;
    }
    if (outlen > 0) {
        HAL_HASHEx_SHAKE256_Squeeze(&hhash, output, outlen, HAL_MAX_DELAY);
    }
}
\end{lstlisting}

\subsection{FPGA and Custom Hardware}
\label{subsec:fpga}

For high-throughput IoT applications (gateways, base stations), FPGAs provide significant acceleration:

\begin{table}[H]
\centering
\caption{PQC on FPGA: Performance examples}
\label{tab:fpga-pqc}
\begin{tabular}{llrrr}
\toprule
\textbf{Algorithm} & \textbf{FPGA} & \textbf{Freq} & \textbf{KeyGen} & \textbf{Ops/sec} \\
\midrule
ML-KEM-768 & Artix-7 & 200 MHz & 3.2 µs & 312,500 \\
ML-KEM-768 & Zynq-7020 & 150 MHz & 4.5 µs & 222,222 \\
ML-DSA-65 & Artix-7 & 200 MHz & 15 µs & 66,666 \\
Falcon-512 & Virtex-7 & 250 MHz & 850 µs & 1,176 \\
\bottomrule
\end{tabular}
\end{table}

\section{Random Number Generation}
\label{sec:rng}

\subsection{Importance in PQC}
\label{subsec:rng-importance}

High-quality randomness is essential for:
\begin{itemize}
    \item Key generation (private keys)
    \item Nonce/randomness in signing (ML-DSA, Falcon)
    \item Masking values for side-channel protection
    \item Session keys and initialization vectors
\end{itemize}

\warningbox{Poor randomness is one of the most common causes of cryptographic failures. A predictable RNG can completely undermine PQC security, even with correct algorithm implementation.}

\subsection{Hardware RNG}
\label{subsec:hw-rng}

\begin{lstlisting}[language=C, caption={Hardware RNG on STM32}, label={lst:hw-rng}]
#include "stm32l4xx_hal.h"

RNG_HandleTypeDef hrng;

int randombytes(uint8_t *buf, size_t len) {
    uint32_t random_word;
    size_t i = 0;
    
    while (i < len) {
        if (HAL_RNG_GenerateRandomNumber(&hrng, &random_word) != HAL_OK) {
            return -1;  // RNG error
        }
        
        // Copy bytes from random word
        size_t bytes_to_copy = (len - i < 4) ? (len - i) : 4;
        memcpy(buf + i, &random_word, bytes_to_copy);
        i += bytes_to_copy;
    }
    
    return 0;
}

// Initialize RNG with health checks
int rng_init(void) {
    __HAL_RCC_RNG_CLK_ENABLE();
    
    hrng.Instance = RNG;
    if (HAL_RNG_Init(&hrng) != HAL_OK) {
        return -1;
    }
    
    // Health test: verify output is not stuck
    uint32_t test1, test2;
    HAL_RNG_GenerateRandomNumber(&hrng, &test1);
    HAL_RNG_GenerateRandomNumber(&hrng, &test2);
    
    if (test1 == test2) {
        return -1;  // RNG may be faulty
    }
    
    return 0;
}
\end{lstlisting}

\subsection{DRBG Seeding}
\label{subsec:drbg}

For devices without hardware RNG, use a DRBG seeded from multiple entropy sources:

\begin{lstlisting}[language=C, caption={Multi-source entropy collection}, label={lst:entropy}]
// Collect entropy from multiple sources
void collect_entropy(uint8_t *seed, size_t seed_len) {
    sha3_256_ctx ctx;
    sha3_256_init(&ctx);
    
    // Source 1: Hardware RNG (if available)
    #ifdef HAS_HWRNG
    uint8_t hw_random[32];
    hw_rng_get(hw_random, 32);
    sha3_256_update(&ctx, hw_random, 32);
    #endif
    
    // Source 2: ADC noise
    uint16_t adc_samples[64];
    for (int i = 0; i < 64; i++) {
        adc_samples[i] = read_adc_noise_source();
    }
    sha3_256_update(&ctx, (uint8_t *)adc_samples, sizeof(adc_samples));
    
    // Source 3: Timer jitter
    uint32_t timer_values[32];
    for (int i = 0; i < 32; i++) {
        timer_values[i] = get_high_res_timer();
        busy_wait_random();
    }
    sha3_256_update(&ctx, (uint8_t *)timer_values, sizeof(timer_values));
    
    // Source 4: Unique device ID
    uint8_t device_id[12];
    get_device_unique_id(device_id);
    sha3_256_update(&ctx, device_id, 12);
    
    // Finalize
    sha3_256_final(&ctx, seed);
}
\end{lstlisting}

\section{Testing and Validation}
\label{sec:testing}

\subsection{Known Answer Tests (KAT)}
\label{subsec:kat}

Validate implementations against official test vectors:

\begin{lstlisting}[language=C, caption={KAT verification framework}, label={lst:kat}]
// Structure for KAT test case
typedef struct {
    uint8_t seed[48];
    uint8_t pk[CRYPTO_PUBLICKEYBYTES];
    uint8_t sk[CRYPTO_SECRETKEYBYTES];
    uint8_t ct[CRYPTO_CIPHERTEXTBYTES];
    uint8_t ss[CRYPTO_BYTES];
} kem_kat_t;

int run_kat_test(const kem_kat_t *kat) {
    uint8_t pk[CRYPTO_PUBLICKEYBYTES];
    uint8_t sk[CRYPTO_SECRETKEYBYTES];
    uint8_t ct[CRYPTO_CIPHERTEXTBYTES];
    uint8_t ss1[CRYPTO_BYTES], ss2[CRYPTO_BYTES];
    
    // Seed the DRBG with known value
    drbg_seed(kat->seed, 48);
    
    // Generate keypair
    crypto_kem_keypair(pk, sk);
    
    // Verify keys match expected
    if (memcmp(pk, kat->pk, CRYPTO_PUBLICKEYBYTES) != 0) {
        printf("KAT FAIL: public key mismatch\n");
        return -1;
    }
    
    // Test encapsulation
    crypto_kem_enc(ct, ss1, pk);
    if (memcmp(ct, kat->ct, CRYPTO_CIPHERTEXTBYTES) != 0) {
        printf("KAT FAIL: ciphertext mismatch\n");
        return -1;
    }
    
    // Test decapsulation
    crypto_kem_dec(ss2, ct, sk);
    if (memcmp(ss1, ss2, CRYPTO_BYTES) != 0) {
        printf("KAT FAIL: shared secret mismatch\n");
        return -1;
    }
    
    printf("KAT PASS\n");
    return 0;
}
\end{lstlisting}

\subsection{Benchmark Framework}
\label{subsec:benchmark}

\begin{lstlisting}[language=C, caption={Benchmarking framework for IoT}, label={lst:benchmark}]
#include "cycle_count.h"

typedef struct {
    uint32_t min;
    uint32_t max;
    uint64_t total;
    uint32_t count;
} benchmark_t;

void benchmark_init(benchmark_t *b) {
    b->min = UINT32_MAX;
    b->max = 0;
    b->total = 0;
    b->count = 0;
}

void benchmark_record(benchmark_t *b, uint32_t cycles) {
    if (cycles < b->min) b->min = cycles;
    if (cycles > b->max) b->max = cycles;
    b->total += cycles;
    b->count++;
}

void benchmark_report(const char *name, benchmark_t *b) {
    printf("%s: min=%lu, max=%lu, avg=%lu (n=%lu)\n",
           name, b->min, b->max, 
           (uint32_t)(b->total / b->count), b->count);
}

// Example usage
void benchmark_mlkem(void) {
    benchmark_t keygen_bench, encaps_bench, decaps_bench;
    uint32_t start, end;
    
    benchmark_init(&keygen_bench);
    benchmark_init(&encaps_bench);
    benchmark_init(&decaps_bench);
    
    for (int i = 0; i < 100; i++) {
        uint8_t pk[MLKEM_PUBLICKEYBYTES];
        uint8_t sk[MLKEM_SECRETKEYBYTES];
        uint8_t ct[MLKEM_CIPHERTEXTBYTES];
        uint8_t ss[32];
        
        start = get_cycle_count();
        crypto_kem_keypair(pk, sk);
        end = get_cycle_count();
        benchmark_record(&keygen_bench, end - start);
        
        start = get_cycle_count();
        crypto_kem_enc(ct, ss, pk);
        end = get_cycle_count();
        benchmark_record(&encaps_bench, end - start);
        
        start = get_cycle_count();
        crypto_kem_dec(ss, ct, sk);
        end = get_cycle_count();
        benchmark_record(&decaps_bench, end - start);
    }
    
    benchmark_report("KeyGen", &keygen_bench);
    benchmark_report("Encaps", &encaps_bench);
    benchmark_report("Decaps", &decaps_bench);
}
\end{lstlisting}

\section{Chapter Summary}
\label{sec:ch6-summary}

This chapter provided comprehensive implementation guidance for PQC on IoT devices:

\textbf{Hardware Considerations}:
\begin{itemize}
    \item ARM Cortex-M4 is the sweet spot for PQC (DSP, reasonable RAM)
    \item DSP instructions provide 2$\times$ speedup for NTT operations
    \item Stack usage ranges from 2--3 KB (ML-KEM) to 44 KB (ML-DSA signing)
\end{itemize}

\textbf{Optimization Techniques}:
\begin{itemize}
    \item On-the-fly matrix generation saves memory
    \item Montgomery/Barrett reduction for efficient modular arithmetic
    \item Assembly NTT provides significant speedups
    \item Loop unrolling and SIMD improve ILP
\end{itemize}

\textbf{Security Considerations}:
\begin{itemize}
    \item All operations must be constant-time
    \item Masking protects against power analysis
    \item Redundant computation detects faults
    \item Hardware RNG is essential; DRBG as backup
\end{itemize}

\textbf{Testing}:
\begin{itemize}
    \item KAT tests verify correctness against standards
    \item Benchmarking framework for performance validation
    \item Constant-time verification tools (ctgrind)
\end{itemize}

\infobox{Start with reference implementations and well-tested libraries (pqm4, liboqs). Optimize only after profiling shows specific bottlenecks. Security must never be sacrificed for performance.}

% End of Chapter 6

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% CHAPTER 7: LIBRARIES AND TOOLS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Libraries and Tools}
\label{ch:libraries}

This chapter provides a comprehensive survey of software libraries, frameworks, and tools available for implementing post-quantum cryptography. We focus on libraries suitable for IoT development, including both general-purpose and embedded-specific options.

\section{Overview of PQC Libraries}
\label{sec:lib-overview}

\begin{table}[H]
\centering
\caption{Major PQC libraries comparison}
\label{tab:lib-overview}
\begin{tabular}{lcccccc}
\toprule
\textbf{Library} & \textbf{Language} & \textbf{IoT} & \textbf{Algorithms} & \textbf{License} & \textbf{Maintained} \\
\midrule
liboqs & C & Limited & All NIST & MIT & Active \\
PQClean & C & Yes & All NIST & Public Domain & Active \\
pqm4 & C/ASM & Yes & Most NIST & Public Domain & Active \\
PQCRYPTO-LWEKE & C & Yes & Kyber & MIT & Active \\
wolfSSL/wolfCrypt & C & Yes & ML-KEM, ML-DSA & GPLv2/Commercial & Active \\
Botan & C++ & Limited & ML-KEM, ML-DSA & BSD-2 & Active \\
libsodium-pq & C & Yes & Kyber (fork) & ISC & Limited \\
pqcrypto (Rust) & Rust & Limited & Most NIST & Various & Active \\
liboqs-go & Go & No & All NIST & MIT & Active \\
liboqs-python & Python & No & All NIST & MIT & Active \\
\bottomrule
\end{tabular}
\end{table}

\section{liboqs (Open Quantum Safe)}
\label{sec:liboqs}

liboqs is the reference library from the Open Quantum Safe project, providing a unified API for all NIST PQC algorithms.

\subsection{Features}
\label{subsec:liboqs-features}

\begin{itemize}
    \item \textbf{Comprehensive}: Implements all NIST finalists and alternates
    \item \textbf{Unified API}: Consistent interface across all algorithms
    \item \textbf{Regularly updated}: Tracks NIST specification changes
    \item \textbf{Language bindings}: C, Python, Go, Java, .NET, Rust
    \item \textbf{Integration}: Works with OpenSSL, BoringSSL, OpenSSH
\end{itemize}

\subsection{Installation}
\label{subsec:liboqs-install}

\begin{lstlisting}[language=bash, caption={Building liboqs}, label={lst:liboqs-build}]
# Clone the repository
git clone https://github.com/open-quantum-safe/liboqs.git
cd liboqs

# Build with CMake
mkdir build && cd build
cmake -DCMAKE_INSTALL_PREFIX=/usr/local \
      -DBUILD_SHARED_LIBS=ON \
      -DOQS_BUILD_ONLY_LIB=ON \
      ..
make -j$(nproc)
sudo make install

# For embedded (minimal build)
cmake -DOQS_MINIMAL_BUILD="KEM_kyber_768;SIG_dilithium3" \
      -DOQS_USE_OPENSSL=OFF \
      -DOQS_USE_AES_OPENSSL=OFF \
      -DBUILD_SHARED_LIBS=OFF \
      ..
\end{lstlisting}

\subsection{API Reference}
\label{subsec:liboqs-api}

\begin{lstlisting}[language=C, caption={liboqs KEM API}, label={lst:liboqs-kem-api}]
#include <oqs/oqs.h>

// List available algorithms
for (size_t i = 0; i < OQS_KEM_alg_count(); i++) {
    const char *alg = OQS_KEM_alg_identifier(i);
    if (OQS_KEM_alg_is_enabled(alg)) {
        printf("Available: %s\n", alg);
    }
}

// Algorithm names
// "ML-KEM-512", "ML-KEM-768", "ML-KEM-1024"
// "Kyber512", "Kyber768", "Kyber1024" (aliases)

// Create KEM instance
OQS_KEM *kem = OQS_KEM_new(OQS_KEM_alg_ml_kem_768);

// Access properties
printf("Public key length: %zu\n", kem->length_public_key);
printf("Secret key length: %zu\n", kem->length_secret_key);
printf("Ciphertext length: %zu\n", kem->length_ciphertext);
printf("Shared secret length: %zu\n", kem->length_shared_secret);

// Key generation
uint8_t *pk = malloc(kem->length_public_key);
uint8_t *sk = malloc(kem->length_secret_key);
OQS_KEM_keypair(kem, pk, sk);

// Encapsulation
uint8_t *ct = malloc(kem->length_ciphertext);
uint8_t *ss_enc = malloc(kem->length_shared_secret);
OQS_KEM_encaps(kem, ct, ss_enc, pk);

// Decapsulation
uint8_t *ss_dec = malloc(kem->length_shared_secret);
OQS_KEM_decaps(kem, ss_dec, ct, sk);

// Cleanup (secure)
OQS_MEM_secure_free(sk, kem->length_secret_key);
OQS_MEM_secure_free(ss_enc, kem->length_shared_secret);
OQS_MEM_secure_free(ss_dec, kem->length_shared_secret);
free(pk);
free(ct);
OQS_KEM_free(kem);
\end{lstlisting}

\begin{lstlisting}[language=C, caption={liboqs Signature API}, label={lst:liboqs-sig-api}]
#include <oqs/oqs.h>

// Available signature algorithms
// "ML-DSA-44", "ML-DSA-65", "ML-DSA-87"
// "Falcon-512", "Falcon-1024"
// "SPHINCS+-SHA2-128f-simple", "SPHINCS+-SHA2-128s-simple", ...

// Create signature instance
OQS_SIG *sig = OQS_SIG_new(OQS_SIG_alg_ml_dsa_65);

// Key generation
uint8_t *pk = malloc(sig->length_public_key);
uint8_t *sk = malloc(sig->length_secret_key);
OQS_SIG_keypair(sig, pk, sk);

// Signing
const uint8_t msg[] = "Message to sign";
size_t msg_len = sizeof(msg) - 1;
uint8_t *signature = malloc(sig->length_signature);
size_t sig_len;
OQS_SIG_sign(sig, signature, &sig_len, msg, msg_len, sk);

// Verification
OQS_STATUS result = OQS_SIG_verify(sig, msg, msg_len, 
                                    signature, sig_len, pk);
if (result == OQS_SUCCESS) {
    printf("Signature valid\n");
} else {
    printf("Signature invalid\n");
}

// Cleanup
OQS_MEM_secure_free(sk, sig->length_secret_key);
free(pk);
free(signature);
OQS_SIG_free(sig);
\end{lstlisting}

\subsection{Python Bindings}
\label{subsec:liboqs-python}

\begin{lstlisting}[language=Python, caption={liboqs-python usage}, label={lst:liboqs-python}]
import oqs

# List available KEMs
print("Available KEMs:", oqs.get_enabled_kem_mechanisms())

# Key exchange example
with oqs.KeyEncapsulation("ML-KEM-768") as client:
    # Server generates keypair
    with oqs.KeyEncapsulation("ML-KEM-768") as server:
        public_key = server.generate_keypair()
        
        # Client encapsulates
        ciphertext, shared_secret_client = client.encap_secret(public_key)
        
        # Server decapsulates
        shared_secret_server = server.decap_secret(ciphertext)
        
        assert shared_secret_client == shared_secret_server
        print(f"Shared secret: {shared_secret_client.hex()[:32]}...")

# Signature example
with oqs.Signature("ML-DSA-65") as signer:
    public_key = signer.generate_keypair()
    
    message = b"Important document"
    signature = signer.sign(message)
    
    # Verify (could be different instance)
    with oqs.Signature("ML-DSA-65") as verifier:
        is_valid = verifier.verify(message, signature, public_key)
        print(f"Signature valid: {is_valid}")
\end{lstlisting}

\section{PQClean}
\label{sec:pqclean}

PQClean provides clean, portable, and auditable reference implementations.

\subsection{Design Philosophy}
\label{subsec:pqclean-philosophy}

\begin{itemize}
    \item \textbf{Clean code}: Readable, well-documented implementations
    \item \textbf{No dependencies}: Self-contained, no external libraries
    \item \textbf{Consistent API}: Uniform interface across all schemes
    \item \textbf{Multiple variants}: Clean, AVX2, aarch64 optimized versions
    \item \textbf{Public domain}: CC0 license for maximum flexibility
\end{itemize}

\subsection{Structure}
\label{subsec:pqclean-structure}

\begin{lstlisting}[language=bash, caption={PQClean directory structure}, label={lst:pqclean-struct}]
PQClean/
├── crypto_kem/
│   ├── kyber512/
│   │   ├── clean/           # Reference implementation
│   │   │   ├── api.h        # Public API
│   │   │   ├── kem.c        # KEM functions
│   │   │   ├── indcpa.c     # CPA-secure encryption
│   │   │   ├── poly.c       # Polynomial operations
│   │   │   ├── ntt.c        # Number theoretic transform
│   │   │   └── ...
│   │   ├── avx2/            # AVX2 optimized
│   │   └── aarch64/         # ARM64 optimized
│   ├── kyber768/
│   └── kyber1024/
├── crypto_sign/
│   ├── dilithium2/
│   ├── dilithium3/
│   ├── falcon-512/
│   └── sphincs-sha2-128f-simple/
├── common/
│   ├── fips202.c            # SHA-3/SHAKE
│   ├── sha2.c               # SHA-2
│   └── aes.c                # AES
└── test/
\end{lstlisting}

\subsection{API}
\label{subsec:pqclean-api}

\begin{lstlisting}[language=C, caption={PQClean unified API}, label={lst:pqclean-api}]
// api.h defines these constants for each scheme:
#define CRYPTO_SECRETKEYBYTES  ...
#define CRYPTO_PUBLICKEYBYTES  ...
#define CRYPTO_CIPHERTEXTBYTES ...  // KEM only
#define CRYPTO_BYTES           ...  // Shared secret / signature max

#define CRYPTO_ALGNAME "..."

// KEM API
int crypto_kem_keypair(uint8_t *pk, uint8_t *sk);
int crypto_kem_enc(uint8_t *ct, uint8_t *ss, const uint8_t *pk);
int crypto_kem_dec(uint8_t *ss, const uint8_t *ct, const uint8_t *sk);

// Signature API
int crypto_sign_keypair(uint8_t *pk, uint8_t *sk);

// Signed message (signature prepended to message)
int crypto_sign(uint8_t *sm, size_t *smlen,
                const uint8_t *m, size_t mlen,
                const uint8_t *sk);
int crypto_sign_open(uint8_t *m, size_t *mlen,
                     const uint8_t *sm, size_t smlen,
                     const uint8_t *pk);

// Detached signature
int crypto_sign_signature(uint8_t *sig, size_t *siglen,
                          const uint8_t *m, size_t mlen,
                          const uint8_t *sk);
int crypto_sign_verify(const uint8_t *sig, size_t siglen,
                       const uint8_t *m, size_t mlen,
                       const uint8_t *pk);
\end{lstlisting}

\subsection{Integration Example}
\label{subsec:pqclean-integration}

\begin{lstlisting}[language=C, caption={Integrating PQClean into a project}, label={lst:pqclean-integrate}]
// Include the specific scheme
#include "crypto_kem/kyber768/clean/api.h"

// For multiple schemes, use namespaced versions
#define PQCLEAN_NAMESPACE(name) PQCLEAN_KYBER768_CLEAN_##name

int main() {
    uint8_t pk[CRYPTO_PUBLICKEYBYTES];
    uint8_t sk[CRYPTO_SECRETKEYBYTES];
    uint8_t ct[CRYPTO_CIPHERTEXTBYTES];
    uint8_t ss1[CRYPTO_BYTES], ss2[CRYPTO_BYTES];
    
    // Generate keypair
    PQCLEAN_NAMESPACE(crypto_kem_keypair)(pk, sk);
    
    // Encapsulate
    PQCLEAN_NAMESPACE(crypto_kem_enc)(ct, ss1, pk);
    
    // Decapsulate
    PQCLEAN_NAMESPACE(crypto_kem_dec)(ss2, ct, sk);
    
    // Verify
    if (memcmp(ss1, ss2, CRYPTO_BYTES) == 0) {
        printf("Key exchange successful!\n");
    }
    
    return 0;
}
\end{lstlisting}

\section{pqm4: PQC for ARM Cortex-M4}
\label{sec:pqm4}

pqm4 is the premier library for PQC on ARM Cortex-M4 microcontrollers, featuring highly optimized implementations with assembly kernels.

\subsection{Supported Platforms}
\label{subsec:pqm4-platforms}

\begin{table}[H]
\centering
\caption{pqm4 supported development boards}
\label{tab:pqm4-boards}
\begin{tabular}{llcc}
\toprule
\textbf{Board} & \textbf{MCU} & \textbf{RAM} & \textbf{Flash} \\
\midrule
NUCLEO-L4R5ZI & STM32L4R5ZI & 640 KB & 2 MB \\
NUCLEO-F446RE & STM32F446RE & 128 KB & 512 KB \\
STM32F4-Discovery & STM32F407VG & 192 KB & 1 MB \\
NUCLEO-L476RG & STM32L476RG & 128 KB & 1 MB \\
EFM32GG-STK3701A & EFM32GG11 & 512 KB & 2 MB \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Building and Running}
\label{subsec:pqm4-build}

\begin{lstlisting}[language=bash, caption={Building pqm4}, label={lst:pqm4-build}]
# Clone repository
git clone https://github.com/mupq/pqm4.git
cd pqm4

# Install dependencies (Ubuntu/Debian)
sudo apt install gcc-arm-none-eabi openocd python3-serial

# Build all implementations for default board
make -j$(nproc)

# Build specific scheme
make IMPLEMENTATION_PATH=crypto_kem/kyber768/m4fspeed

# Flash to board
make flash IMPLEMENTATION_PATH=crypto_kem/kyber768/m4fspeed

# Run benchmarks
python3 benchmarks.py
\end{lstlisting}

\subsection{Implementation Variants}
\label{subsec:pqm4-variants}

\begin{table}[H]
\centering
\caption{pqm4 implementation variants}
\label{tab:pqm4-variants}
\begin{tabular}{lp{8cm}}
\toprule
\textbf{Variant} & \textbf{Description} \\
\midrule
\texttt{clean} & Reference C implementation, portable \\
\texttt{m4} & Basic M4 optimization (C with some ASM) \\
\texttt{m4f} & M4 with FPU utilization where applicable \\
\texttt{m4fspeed} & Maximum speed, higher memory usage \\
\texttt{m4fstack} & Optimized for minimal stack usage \\
\texttt{opt} & General optimized version \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Benchmark Results}
\label{subsec:pqm4-benchmarks}

\begin{table}[H]
\centering
\caption{Complete pqm4 benchmarks (STM32L4R5ZI @ 80 MHz)}
\label{tab:pqm4-complete}
\begin{tabular}{llrrrr}
\toprule
\textbf{Scheme} & \textbf{Variant} & \textbf{KeyGen} & \textbf{Enc/Sign} & \textbf{Dec/Ver} & \textbf{Stack} \\
\midrule
\multicolumn{6}{c}{\textit{Key Encapsulation Mechanisms}} \\
\midrule
ML-KEM-512 & m4fspeed & 392,295 & 391,355 & 428,037 & 3,080 \\
ML-KEM-768 & m4fspeed & 642,163 & 659,069 & 708,044 & 3,592 \\
ML-KEM-1024 & m4fspeed & 1,019,877 & 1,031,009 & 1,094,181 & 4,104 \\
ML-KEM-768 & m4fstack & 676,896 & 854,339 & 912,308 & 2,588 \\
\midrule
\multicolumn{6}{c}{\textit{Digital Signatures}} \\
\midrule
ML-DSA-44 & m4f & 800,974 & 2,292,188 & 786,486 & 24,512 \\
ML-DSA-65 & m4f & 1,406,298 & 3,948,962 & 1,380,582 & 34,752 \\
ML-DSA-87 & m4f & 2,222,174 & 5,383,044 & 2,148,702 & 43,968 \\
Falcon-512 & opt & 53.3M & 7.0M & 340,000 & 39,000 \\
SLH-SHA2-128f & clean & 2.9M & 51.7M & 3.5M & 2,500 \\
\bottomrule
\end{tabular}
\begin{tablenotes}
\small
\item Cycles measured at 80 MHz. Stack in bytes. M = millions.
\end{tablenotes}
\end{table}

\subsection{Using pqm4 in Your Project}
\label{subsec:pqm4-usage}

\begin{lstlisting}[language=C, caption={Integrating pqm4 implementations}, label={lst:pqm4-integrate}]
// Project structure
// your_project/
// ├── src/
// │   └── main.c
// ├── pqm4/
// │   └── crypto_kem/kyber768/m4fspeed/
// └── Makefile

// main.c
#include "api.h"
#include "randombytes.h"

int main(void) {
    // Initialize hardware
    SystemClock_Config();
    UART_Init();
    RNG_Init();
    
    // PQC operations
    uint8_t pk[CRYPTO_PUBLICKEYBYTES];
    uint8_t sk[CRYPTO_SECRETKEYBYTES];
    uint8_t ct[CRYPTO_CIPHERTEXTBYTES];
    uint8_t ss[CRYPTO_BYTES];
    
    // Time measurement
    uint32_t start = DWT->CYCCNT;
    crypto_kem_keypair(pk, sk);
    uint32_t keygen_cycles = DWT->CYCCNT - start;
    
    printf("KeyGen: %lu cycles\n", keygen_cycles);
    
    return 0;
}
\end{lstlisting}

\section{wolfSSL / wolfCrypt}
\label{sec:wolfssl}

wolfSSL is a commercial-grade TLS library with comprehensive PQC support, ideal for production IoT deployments.

\subsection{Features}
\label{subsec:wolfssl-features}

\begin{itemize}
    \item \textbf{FIPS 140-3 validated}: Certificate \#4718
    \item \textbf{Production ready}: Used in billions of devices
    \item \textbf{Full TLS 1.3}: With PQ hybrid key exchange
    \item \textbf{DTLS 1.3}: For IoT protocols
    \item \textbf{Small footprint}: 20--100 KB code size
    \item \textbf{Dual license}: GPLv2 and commercial
\end{itemize}

\subsection{PQC Algorithms}
\label{subsec:wolfssl-pqc}

\begin{table}[H]
\centering
\caption{wolfSSL PQC support}
\label{tab:wolfssl-pqc}
\begin{tabular}{lcc}
\toprule
\textbf{Algorithm} & \textbf{Status} & \textbf{FIPS} \\
\midrule
ML-KEM-512/768/1024 & Supported & Hybrid* \\
ML-DSA-44/65/87 & Supported & Planned \\
Falcon-512/1024 & Supported & No \\
SPHINCS+ & Supported & No \\
LMS/HSS & Supported & Yes \\
XMSS/XMSS$^{MT}$ & Supported & Yes \\
\bottomrule
\end{tabular}
\begin{tablenotes}
\small
\item *FIPS compliance via hybrid with ECDH
\end{tablenotes}
\end{table}

\subsection{Building with PQC}
\label{subsec:wolfssl-build}

\begin{lstlisting}[language=bash, caption={Building wolfSSL with PQC}, label={lst:wolfssl-build}]
# Clone wolfSSL
git clone https://github.com/wolfSSL/wolfssl.git
cd wolfssl

# Configure with PQC support
./autogen.sh
./configure --enable-kyber \
            --enable-dilithium \
            --enable-falcon \
            --enable-sphincs \
            --enable-tls13 \
            --enable-dtls13

# Build
make -j$(nproc)
sudo make install

# For embedded (ARM Cortex-M)
./configure --host=arm-none-eabi \
            --enable-kyber \
            --enable-singlethreaded \
            --disable-filesystem \
            CFLAGS="-mcpu=cortex-m4 -mthumb -Os"
\end{lstlisting}

\subsection{API Usage}
\label{subsec:wolfssl-api}

\begin{lstlisting}[language=C, caption={wolfCrypt PQC API}, label={lst:wolfcrypt-api}]
#include <wolfssl/wolfcrypt/kyber.h>
#include <wolfssl/wolfcrypt/dilithium.h>

// ML-KEM (Kyber) example
void kyber_example(void) {
    KyberKey key;
    byte pk[KYBER768_PUBLIC_KEY_SIZE];
    byte sk[KYBER768_PRIVATE_KEY_SIZE];
    byte ct[KYBER768_CIPHER_TEXT_SIZE];
    byte ss1[KYBER_SS_SZ], ss2[KYBER_SS_SZ];
    WC_RNG rng;
    
    wc_InitRng(&rng);
    wc_KyberKey_Init(KYBER768, &key, NULL, INVALID_DEVID);
    
    // Generate keypair
    wc_KyberKey_MakeKey(&key, &rng);
    wc_KyberKey_ExportPubKey(&key, pk, sizeof(pk));
    wc_KyberKey_ExportPrivKey(&key, sk, sizeof(sk));
    
    // Encapsulate
    wc_KyberKey_Encapsulate(&key, ct, ss1, &rng);
    
    // Decapsulate
    wc_KyberKey_Decapsulate(&key, ss2, ct, sizeof(ct));
    
    // Cleanup
    wc_KyberKey_Free(&key);
    wc_FreeRng(&rng);
}

// ML-DSA (Dilithium) example
void dilithium_example(void) {
    dilithium_key key;
    byte pk[DILITHIUM_LEVEL3_PUB_KEY_SIZE];
    byte sk[DILITHIUM_LEVEL3_PRV_KEY_SIZE];
    byte sig[DILITHIUM_LEVEL3_SIG_SIZE];
    word32 sigLen = sizeof(sig);
    byte msg[] = "Test message";
    WC_RNG rng;
    
    wc_InitRng(&rng);
    wc_dilithium_init(&key);
    wc_dilithium_set_level(&key, 3);  // ML-DSA-65
    
    // Generate keypair
    wc_dilithium_make_key(&key, &rng);
    
    // Sign
    wc_dilithium_sign_msg(msg, sizeof(msg), sig, &sigLen, &key, &rng);
    
    // Verify
    int ret = wc_dilithium_verify_msg(sig, sigLen, msg, sizeof(msg), 
                                       &verified, &key);
    
    wc_dilithium_free(&key);
}
\end{lstlisting}

\subsection{TLS 1.3 with Hybrid PQC}
\label{subsec:wolfssl-tls}

\begin{lstlisting}[language=C, caption={wolfSSL TLS 1.3 with PQ hybrid}, label={lst:wolfssl-tls}]
#include <wolfssl/ssl.h>

// Server setup with PQ hybrid key exchange
WOLFSSL_CTX* create_pq_server_ctx(void) {
    WOLFSSL_CTX* ctx = wolfSSL_CTX_new(wolfTLSv1_3_server_method());
    
    // Enable hybrid key exchange
    wolfSSL_CTX_set_groups(ctx, 
        (int[]){WOLFSSL_ECC_SECP256R1, 
                WOLFSSL_KYBER_LEVEL3,      // Pure PQ
                WOLFSSL_P256_KYBER_LEVEL1}, // Hybrid
        3);
    
    // Load certificates
    wolfSSL_CTX_use_certificate_file(ctx, "server.pem", 
                                      SSL_FILETYPE_PEM);
    wolfSSL_CTX_use_PrivateKey_file(ctx, "server-key.pem", 
                                     SSL_FILETYPE_PEM);
    
    return ctx;
}

// Client connection with PQ
int pq_client_connect(const char *host, int port) {
    WOLFSSL_CTX* ctx = wolfSSL_CTX_new(wolfTLSv1_3_client_method());
    
    // Prefer hybrid, fallback to pure PQ or classical
    wolfSSL_CTX_set_groups(ctx,
        (int[]){WOLFSSL_P256_KYBER_LEVEL1,  // Prefer hybrid
                WOLFSSL_KYBER_LEVEL3,        // Pure PQ
                WOLFSSL_ECC_SECP256R1},      // Classical fallback
        3);
    
    // Connect
    int sockfd = tcp_connect(host, port);
    WOLFSSL* ssl = wolfSSL_new(ctx);
    wolfSSL_set_fd(ssl, sockfd);
    
    if (wolfSSL_connect(ssl) == SSL_SUCCESS) {
        printf("Connected with %s\n", wolfSSL_get_cipher(ssl));
    }
    
    return 0;
}
\end{lstlisting}

\section{Rust Libraries}
\label{sec:rust-libs}

\subsection{pqcrypto Crate}
\label{subsec:pqcrypto}

The \texttt{pqcrypto} crate provides safe Rust bindings to PQClean implementations.

\begin{lstlisting}[language=Rust, caption={pqcrypto crate usage}, label={lst:pqcrypto-rust}]
// Cargo.toml
// [dependencies]
// pqcrypto-kyber = "0.8"
// pqcrypto-dilithium = "0.5"
// pqcrypto-traits = "0.3"

use pqcrypto_kyber::kyber768;
use pqcrypto_dilithium::dilithium3;
use pqcrypto_traits::kem::{PublicKey, SecretKey, SharedSecret, Ciphertext};
use pqcrypto_traits::sign::{SignedMessage, DetachedSignature};

fn kem_example() {
    // Key generation
    let (pk, sk) = kyber768::keypair();
    
    // Encapsulation
    let (ss_sender, ct) = kyber768::encapsulate(&pk);
    
    // Decapsulation
    let ss_receiver = kyber768::decapsulate(&ct, &sk);
    
    assert_eq!(ss_sender.as_bytes(), ss_receiver.as_bytes());
    println!("KEM successful!");
}

fn sign_example() {
    // Key generation
    let (pk, sk) = dilithium3::keypair();
    
    // Sign message
    let message = b"Important data to sign";
    let signed_msg = dilithium3::sign(message, &sk);
    
    // Verify and extract message
    match dilithium3::open(&signed_msg, &pk) {
        Ok(verified_msg) => {
            assert_eq!(&verified_msg[..], message);
            println!("Signature valid!");
        }
        Err(_) => println!("Signature invalid!"),
    }
    
    // Detached signature
    let sig = dilithium3::detached_sign(message, &sk);
    let valid = dilithium3::verify_detached_signature(&sig, message, &pk);
    assert!(valid.is_ok());
}

fn main() {
    kem_example();
    sign_example();
}
\end{lstlisting}

\subsection{RustCrypto PQC}
\label{subsec:rustcrypto}

The RustCrypto project is developing pure-Rust implementations:

\begin{lstlisting}[language=Rust, caption={ml-kem crate (pure Rust)}, label={lst:mlkem-rust}]
// Cargo.toml
// [dependencies]
// ml-kem = "0.1"

use ml_kem::{MlKem768, KemCore, Encoded};
use rand_core::OsRng;

fn pure_rust_kem() {
    // Generate keypair
    let (dk, ek) = MlKem768::generate(&mut OsRng);
    
    // Encapsulate
    let (ct, ss_sender) = ek.encapsulate(&mut OsRng).unwrap();
    
    // Decapsulate
    let ss_receiver = dk.decapsulate(&ct).unwrap();
    
    assert_eq!(ss_sender.as_bytes(), ss_receiver.as_bytes());
}
\end{lstlisting}

\section{Development Tools}
\label{sec:dev-tools}

\subsection{Testing Tools}
\label{subsec:testing-tools}

\begin{table}[H]
\centering
\caption{PQC testing and analysis tools}
\label{tab:testing-tools}
\begin{tabular}{lll}
\toprule
\textbf{Tool} & \textbf{Purpose} & \textbf{URL} \\
\midrule
NIST KAT & Known Answer Tests & NIST PQC website \\
pqcgenkat & Generate KAT files & Part of PQClean \\
SUPERCOP & Benchmarking suite & bench.cr.yp.to \\
ctgrind & Constant-time check & github.com/agl/ctgrind \\
valgrind & Memory analysis & valgrind.org \\
AFL/libFuzzer & Fuzzing & Various \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Side-Channel Analysis}
\label{subsec:sca-tools}

\begin{table}[H]
\centering
\caption{Side-channel analysis tools}
\label{tab:sca-tools}
\begin{tabular}{llc}
\toprule
\textbf{Tool} & \textbf{Purpose} & \textbf{Open Source} \\
\midrule
ChipWhisperer & Power analysis platform & Yes \\
Lascar & Side-channel analysis library & Yes \\
Scared & Side-channel evaluation & Yes \\
REASSURE & Leakage assessment & Yes \\
Inspector & Commercial SCA suite & No \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Formal Verification}
\label{subsec:formal-tools}

\begin{table}[H]
\centering
\caption{Formal verification for cryptography}
\label{tab:formal-tools}
\begin{tabular}{lll}
\toprule
\textbf{Tool} & \textbf{Purpose} & \textbf{Language} \\
\midrule
EasyCrypt & Cryptographic proofs & EasyCrypt \\
CryptoVerif & Protocol verification & CryptoVerif \\
Jasmin & Verified assembly & Jasmin \\
Fiat-Crypto & Verified field arithmetic & Coq \\
HACL* & Verified crypto library & F* \\
\bottomrule
\end{tabular}
\end{table}

\section{Library Selection Guide}
\label{sec:lib-selection}

\subsection{Decision Matrix}
\label{subsec:decision-matrix}

\begin{table}[H]
\centering
\caption{Library selection by use case}
\label{tab:lib-selection}
\begin{tabular}{lccccc}
\toprule
\textbf{Use Case} & \textbf{liboqs} & \textbf{PQClean} & \textbf{pqm4} & \textbf{wolfSSL} & \textbf{pqcrypto} \\
\midrule
Research/Prototyping & \checkmark & \checkmark & & & \checkmark \\
Embedded (Cortex-M) & & \checkmark & \checkmark & \checkmark & \\
Production TLS & & & & \checkmark & \\
FIPS compliance & & & & \checkmark & \\
Algorithm comparison & \checkmark & \checkmark & & & \\
Minimal dependencies & & \checkmark & \checkmark & & \\
Rust projects & & & & & \checkmark \\
Python scripts & \checkmark & & & & \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Recommendations by Platform}
\label{subsec:platform-recs}

\begin{table}[H]
\centering
\caption{Recommended libraries by platform}
\label{tab:platform-recs}
\begin{tabular}{ll}
\toprule
\textbf{Platform} & \textbf{Recommended Library} \\
\midrule
Linux/Desktop & liboqs or wolfSSL \\
ARM Cortex-M4/M7 & pqm4 or wolfSSL \\
ARM Cortex-M0/M3 & PQClean (clean variants) \\
ESP32 & wolfSSL or adapted PQClean \\
RISC-V & PQClean or liboqs \\
Web/WASM & liboqs (WASM build) \\
iOS/Android & liboqs or wolfSSL \\
Rust anywhere & pqcrypto or ml-kem \\
Python scripts & liboqs-python \\
\bottomrule
\end{tabular}
\end{table}

\section{Chapter Summary}
\label{sec:ch7-summary}

This chapter surveyed the major PQC libraries and tools:

\textbf{General-Purpose Libraries}:
\begin{itemize}
    \item \textbf{liboqs}: Most comprehensive, excellent for research and prototyping
    \item \textbf{PQClean}: Clean reference implementations, no dependencies
    \item \textbf{Botan}: C++ library with PQC support
\end{itemize}

\textbf{Embedded/IoT Libraries}:
\begin{itemize}
    \item \textbf{pqm4}: Optimized for ARM Cortex-M4, best performance
    \item \textbf{wolfSSL}: Production-ready, FIPS validated, TLS support
    \item \textbf{PQClean clean variants}: Portable to any platform
\end{itemize}

\textbf{Language-Specific}:
\begin{itemize}
    \item \textbf{Rust}: pqcrypto, ml-kem (pure Rust)
    \item \textbf{Python}: liboqs-python
    \item \textbf{Go}: liboqs-go
\end{itemize}

\textbf{Key Recommendations}:
\begin{itemize}
    \item For Cortex-M4 IoT: Use \textbf{pqm4} for best performance
    \item For production TLS: Use \textbf{wolfSSL} with hybrid mode
    \item For research: Use \textbf{liboqs} for comprehensive algorithm access
    \item For minimal footprint: Use \textbf{PQClean} clean implementations
\end{itemize}

\infobox{Always verify library versions support the final NIST standards (FIPS 203, 204, 205). Earlier versions may implement draft specifications with incompatible parameters or APIs.}

% End of Chapter 7

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% CHAPTER 8: PROTOCOL INTEGRATION
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Protocol Integration}
\label{ch:protocols}

This chapter covers the integration of post-quantum cryptography into IoT communication protocols. We examine TLS/DTLS, MQTT, CoAP, Matter, and other protocols essential for IoT security, providing practical guidance for PQC migration.

\section{TLS 1.3 with Post-Quantum Cryptography}
\label{sec:tls13}

Transport Layer Security (TLS) 1.3 is the foundation for secure communication in IoT. Integrating PQC into TLS requires careful consideration of handshake overhead and backward compatibility.

\subsection{TLS 1.3 Handshake Overview}
\label{subsec:tls13-overview}

\begin{figure}[H]
\centering
\begin{tikzpicture}[
    message/.style={->, thick, >=stealth},
    entity/.style={rectangle, draw, minimum width=2cm, minimum height=1cm}
]
    % Entities
    \node[entity] (client) at (0, 0) {Client};
    \node[entity] (server) at (8, 0) {Server};
    
    % Timeline
    \draw[dashed] (0, -0.5) -- (0, -8);
    \draw[dashed] (8, -0.5) -- (8, -8);
    
    % Messages
    \draw[message] (0, -1) -- node[above, font=\small] {ClientHello + key\_share} (8, -1.5);
    \draw[message] (8, -2) -- node[above, font=\small] {ServerHello + key\_share} (0, -2.5);
    \draw[message] (8, -3) -- node[above, font=\small] {EncryptedExtensions} (0, -3.5);
    \draw[message] (8, -4) -- node[above, font=\small] {Certificate + CertVerify} (0, -4.5);
    \draw[message] (8, -5) -- node[above, font=\small] {Finished} (0, -5.5);
    \draw[message] (0, -6) -- node[above, font=\small] {Finished} (8, -6.5);
    \draw[message, <->] (0, -7.5) -- node[above, font=\small] {Application Data} (8, -7.5);
    
    % Annotations
    \node[right, font=\footnotesize] at (8.5, -1.25) {PQ KEM pk};
    \node[right, font=\footnotesize] at (8.5, -2.25) {PQ KEM ct};
    \node[right, font=\footnotesize] at (8.5, -4.25) {PQ Signature};
\end{tikzpicture}
\caption{TLS 1.3 handshake with PQC integration points}
\label{fig:tls13-handshake}
\end{figure}

\subsection{Key Exchange Integration}
\label{subsec:tls-keyex}

TLS 1.3 key exchange uses ephemeral Diffie-Hellman, which can be replaced or augmented with PQC KEMs.

\subsubsection{Hybrid Key Exchange}

The recommended approach combines classical and post-quantum algorithms:

\begin{lstlisting}[language=C, caption={Hybrid key share structure}, label={lst:hybrid-keyshare}]
// TLS 1.3 key_share extension with hybrid
struct {
    NamedGroup group;  // e.g., x25519_kyber768
    opaque key_exchange<1..2^16-1>;
} KeyShareEntry;

// Hybrid key_exchange format
struct {
    opaque classical_key<1..255>;    // X25519: 32 bytes
    opaque pq_key<1..2^16-1>;        // ML-KEM-768: 1184 bytes
} HybridKeyShare;

// Total ClientHello key_share: 32 + 1184 = 1216 bytes
// Total ServerHello key_share: 32 + 1088 = 1120 bytes (ciphertext)
\end{lstlisting}

\subsubsection{IANA Registered Groups}

\begin{table}[H]
\centering
\caption{TLS named groups for PQC (draft registrations)}
\label{tab:tls-groups}
\begin{tabular}{llcc}
\toprule
\textbf{Name} & \textbf{Components} & \textbf{Code Point} & \textbf{Status} \\
\midrule
\multicolumn{4}{c}{\textit{Hybrid Groups}} \\
\midrule
x25519\_kyber768 & X25519 + ML-KEM-768 & 0x6399 & Draft \\
secp256r1\_kyber768 & P-256 + ML-KEM-768 & 0x639a & Draft \\
x25519\_kyber512 & X25519 + ML-KEM-512 & 0x6398 & Draft \\
secp384r1\_kyber1024 & P-384 + ML-KEM-1024 & 0x639b & Draft \\
\midrule
\multicolumn{4}{c}{\textit{Pure PQ Groups (future)}} \\
\midrule
mlkem512 & ML-KEM-512 & TBD & Planned \\
mlkem768 & ML-KEM-768 & TBD & Planned \\
mlkem1024 & ML-KEM-1024 & TBD & Planned \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Authentication Integration}
\label{subsec:tls-auth}

Certificate-based authentication requires PQ signatures in both certificates and handshake messages.

\subsubsection{Certificate Chain Impact}

\begin{table}[H]
\centering
\caption{Certificate chain size comparison}
\label{tab:cert-chain}
\begin{tabular}{lrrrr}
\toprule
\textbf{Algorithm} & \textbf{pk Size} & \textbf{sig Size} & \textbf{Leaf Cert} & \textbf{Chain (3)} \\
\midrule
RSA-2048 & 256 B & 256 B & $\sim$1.5 KB & $\sim$4.5 KB \\
ECDSA P-256 & 64 B & 64 B & $\sim$0.8 KB & $\sim$2.4 KB \\
ML-DSA-65 & 1,952 B & 3,293 B & $\sim$6 KB & $\sim$18 KB \\
Falcon-512 & 897 B & 666 B & $\sim$2.5 KB & $\sim$7.5 KB \\
SLH-DSA-128f & 32 B & 17,088 B & $\sim$18 KB & $\sim$54 KB \\
\bottomrule
\end{tabular}
\end{table}

\warningbox{PQ certificates significantly increase handshake size. A typical ML-DSA certificate chain is 7$\times$ larger than ECDSA. Consider certificate compression (RFC 8879) and caching strategies.}

\subsubsection{Hybrid Certificates}

During transition, certificates may contain both classical and PQ keys:

\begin{lstlisting}[language=bash, caption={Creating hybrid certificate with OpenSSL + OQS}, label={lst:hybrid-cert}]
# Using OQS-OpenSSL provider
export OPENSSL_MODULES=/usr/local/lib/ossl-modules

# Generate hybrid CA key (ECDSA + ML-DSA)
openssl genpkey -algorithm ec -pkeyopt ec_paramgen_curve:P-256 \
    -out ca-classical.key
openssl genpkey -provider oqsprovider -algorithm mldsa65 \
    -out ca-pq.key

# Create composite key (implementation specific)
# Some implementations use X.509 alternative signatures extension

# Generate leaf certificate with PQ signature
openssl req -new -x509 \
    -provider oqsprovider \
    -key server.key \
    -sigopt algorithm:mldsa65 \
    -out server-pq.crt \
    -days 365 \
    -subj "/CN=iot-device.local"
\end{lstlisting}

\subsection{Handshake Size Analysis}
\label{subsec:tls-handshake-size}

\begin{table}[H]
\centering
\caption{TLS 1.3 handshake size comparison}
\label{tab:tls-handshake-size}
\begin{tabular}{lrrrr}
\toprule
\textbf{Configuration} & \textbf{ClientHello} & \textbf{ServerHello+} & \textbf{Total} & \textbf{RTT} \\
\midrule
ECDHE + ECDSA & 200 B & 3.5 KB & 4.2 KB & 1-RTT \\
X25519 + Ed25519 & 180 B & 2.8 KB & 3.3 KB & 1-RTT \\
\midrule
Hybrid (X25519+Kyber768) & 1.4 KB & 5.5 KB & 7.4 KB & 1-RTT \\
+ ML-DSA-65 certs & 1.4 KB & 22 KB & 24 KB & 1-RTT \\
\midrule
Pure PQ (Kyber768) & 1.3 KB & 5.2 KB & 7 KB & 1-RTT \\
+ ML-DSA-65 certs & 1.3 KB & 21 KB & 23 KB & 1-RTT \\
+ Falcon-512 certs & 1.3 KB & 11 KB & 13 KB & 1-RTT \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Performance Impact}
\label{subsec:tls-performance}

\begin{table}[H]
\centering
\caption{TLS 1.3 handshake time on ARM Cortex-M4 @ 80 MHz}
\label{tab:tls-perf}
\begin{tabular}{lrrr}
\toprule
\textbf{Configuration} & \textbf{Client (ms)} & \textbf{Server (ms)} & \textbf{Total (ms)} \\
\midrule
ECDHE P-256 + ECDSA & 45 & 55 & 100 \\
X25519 + Ed25519 & 25 & 30 & 55 \\
\midrule
Hybrid + ECDSA & 35 & 45 & 80 \\
Hybrid + ML-DSA-65 & 85 & 110 & 195 \\
Hybrid + Falcon-512 & 95 & 50 & 145 \\
\midrule
Pure PQ + ML-DSA-65 & 75 & 100 & 175 \\
Pure PQ + Falcon-512 & 85 & 40 & 125 \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Implementation with wolfSSL}
\label{subsec:tls-wolfssl}

\begin{lstlisting}[language=C, caption={Complete TLS 1.3 PQ client}, label={lst:tls-client}]
#include <wolfssl/ssl.h>
#include <wolfssl/wolfcrypt/settings.h>

int pq_tls_client(const char *host, int port) {
    WOLFSSL_CTX *ctx;
    WOLFSSL *ssl;
    int sockfd, ret;
    
    // Initialize wolfSSL
    wolfSSL_Init();
    
    // Create TLS 1.3 context
    ctx = wolfSSL_CTX_new(wolfTLSv1_3_client_method());
    if (!ctx) {
        printf("Failed to create context\n");
        return -1;
    }
    
    // Configure hybrid key exchange
    // Priority: hybrid > pure PQ > classical
    ret = wolfSSL_CTX_set_groups(ctx, (int[]){
        WOLFSSL_P256_KYBER_LEVEL1,   // P-256 + ML-KEM-512
        WOLFSSL_KYBER_LEVEL3,         // ML-KEM-768
        WOLFSSL_ECC_SECP256R1         // Fallback to classical
    }, 3);
    
    // Load CA certificates (may include PQ certs)
    wolfSSL_CTX_load_verify_locations(ctx, "ca-bundle.pem", NULL);
    
    // Create socket and connect
    sockfd = socket(AF_INET, SOCK_STREAM, 0);
    struct sockaddr_in addr = {
        .sin_family = AF_INET,
        .sin_port = htons(port)
    };
    inet_pton(AF_INET, host, &addr.sin_addr);
    connect(sockfd, (struct sockaddr *)&addr, sizeof(addr));
    
    // Create SSL object
    ssl = wolfSSL_new(ctx);
    wolfSSL_set_fd(ssl, sockfd);
    
    // Perform handshake
    ret = wolfSSL_connect(ssl);
    if (ret != SSL_SUCCESS) {
        int err = wolfSSL_get_error(ssl, ret);
        char errBuf[256];
        wolfSSL_ERR_error_string(err, errBuf);
        printf("TLS handshake failed: %s\n", errBuf);
        return -1;
    }
    
    // Print connection info
    printf("Connected with %s\n", wolfSSL_get_cipher(ssl));
    printf("Key exchange: %s\n", wolfSSL_get_curve_name(ssl));
    
    // Send/receive data
    const char *msg = "GET / HTTP/1.1\r\nHost: example.com\r\n\r\n";
    wolfSSL_write(ssl, msg, strlen(msg));
    
    char buffer[4096];
    int bytes = wolfSSL_read(ssl, buffer, sizeof(buffer) - 1);
    buffer[bytes] = '\0';
    printf("Response:\n%s\n", buffer);
    
    // Cleanup
    wolfSSL_shutdown(ssl);
    wolfSSL_free(ssl);
    close(sockfd);
    wolfSSL_CTX_free(ctx);
    wolfSSL_Cleanup();
    
    return 0;
}
\end{lstlisting}

\section{DTLS 1.3 for Constrained IoT}
\label{sec:dtls}

Datagram TLS (DTLS) provides TLS security over UDP, essential for IoT protocols that cannot use TCP.

\subsection{DTLS vs TLS for IoT}
\label{subsec:dtls-vs-tls}

\begin{table}[H]
\centering
\caption{DTLS vs TLS comparison for IoT}
\label{tab:dtls-vs-tls}
\begin{tabular}{lcc}
\toprule
\textbf{Aspect} & \textbf{TLS 1.3} & \textbf{DTLS 1.3} \\
\midrule
Transport & TCP & UDP \\
Connection state & Required & Optional \\
Packet ordering & Guaranteed & Not guaranteed \\
Retransmission & TCP handles & DTLS handles \\
Fragmentation & TCP handles & DTLS handles \\
NAT traversal & Easier & Harder \\
Multicast & Not supported & Supported \\
IoT protocols & MQTT, HTTP & CoAP, LwM2M \\
\bottomrule
\end{tabular}
\end{table}

\subsection{DTLS Fragmentation with PQC}
\label{subsec:dtls-fragment}

Large PQ key shares and certificates require DTLS fragmentation, which adds complexity and latency.

\begin{table}[H]
\centering
\caption{DTLS fragmentation impact}
\label{tab:dtls-fragment}
\begin{tabular}{lcccc}
\toprule
\textbf{MTU} & \textbf{Classical} & \textbf{Hybrid KE} & \textbf{+ ML-DSA cert} \\
\midrule
1500 B (Ethernet) & 1 frag & 1 frag & 15 frags \\
1280 B (IPv6 min) & 1 frag & 2 frags & 18 frags \\
576 B (IPv4 min) & 2 frags & 4 frags & 42 frags \\
127 B (LoRaWAN) & 15 frags & 55 frags & 180+ frags \\
\bottomrule
\end{tabular}
\end{table}

\warningbox{For constrained networks like LoRaWAN (127 B MTU), PQ DTLS may be impractical. Consider connection ID (RFC 9146) to reduce repeated handshakes, or use pre-shared keys with PQ KEM for initial provisioning.}

\subsection{Connection ID for IoT}
\label{subsec:dtls-cid}

\begin{lstlisting}[language=C, caption={DTLS with Connection ID}, label={lst:dtls-cid}]
// Enable Connection ID to avoid re-handshakes
// Useful when NAT rebinding or IP changes occur

// wolfSSL configuration
WOLFSSL_CTX *ctx = wolfSSL_CTX_new(wolfDTLSv1_3_client_method());

// Enable Connection ID
wolfSSL_CTX_set_options(ctx, WOLFSSL_OP_CONNECTION_ID);

// Set CID length (typically 4-8 bytes)
wolfSSL_CTX_set_cid_len(ctx, 4);

// After handshake, connection survives IP changes
// Re-handshake only needed for key refresh
\end{lstlisting}

\section{MQTT with PQC}
\label{sec:mqtt}

MQTT (Message Queuing Telemetry Transport) is the dominant IoT messaging protocol. PQC integration occurs at the TLS layer.

\subsection{MQTT Architecture}
\label{subsec:mqtt-arch}

\begin{figure}[H]
\centering
\begin{tikzpicture}[
    device/.style={rectangle, draw, minimum width=2cm, minimum height=1cm},
    broker/.style={rectangle, draw, fill=blue!20, minimum width=3cm, minimum height=2cm},
    arrow/.style={->, thick, >=stealth}
]
    \node[device] (d1) at (0, 2) {Device 1};
    \node[device] (d2) at (0, 0) {Device 2};
    \node[device] (d3) at (0, -2) {Device 3};
    \node[broker] (broker) at (5, 0) {MQTT\\Broker};
    \node[device] (app) at (10, 0) {Application};
    
    \draw[arrow] (d1) -- node[above, font=\small] {PUBLISH} (broker);
    \draw[arrow] (d2) -- node[above, font=\small] {PUBLISH} (broker);
    \draw[arrow] (d3) -- node[above, font=\small] {SUBSCRIBE} (broker);
    \draw[arrow] (broker) -- node[above, font=\small] {Messages} (app);
    
    \node[below=0.3cm of broker, font=\footnotesize] {TLS/DTLS + PQC};
\end{tikzpicture}
\caption{MQTT with PQC-secured TLS connections}
\label{fig:mqtt-pqc}
\end{figure}

\subsection{MQTT over TLS with PQC}
\label{subsec:mqtt-tls}

\begin{lstlisting}[language=C, caption={MQTT client with PQ TLS (Paho + wolfSSL)}, label={lst:mqtt-pq}]
#include <MQTTClient.h>
#include <wolfssl/ssl.h>

#define BROKER_URI "ssl://iot-broker.example.com:8883"
#define CLIENT_ID "pq-iot-device-001"

// Custom SSL context creation with PQC
SSL_CTX* create_pq_ssl_ctx(void) {
    SSL_CTX *ctx = wolfSSL_CTX_new(wolfTLSv1_3_client_method());
    
    // Configure PQ hybrid key exchange
    wolfSSL_CTX_set_groups(ctx, (int[]){
        WOLFSSL_P256_KYBER_LEVEL1,
        WOLFSSL_ECC_SECP256R1
    }, 2);
    
    // Load device certificate (could be PQ-signed)
    wolfSSL_CTX_use_certificate_file(ctx, "device.crt", SSL_FILETYPE_PEM);
    wolfSSL_CTX_use_PrivateKey_file(ctx, "device.key", SSL_FILETYPE_PEM);
    
    // Load CA bundle
    wolfSSL_CTX_load_verify_locations(ctx, "ca-bundle.pem", NULL);
    
    return ctx;
}

int mqtt_pq_connect(void) {
    MQTTClient client;
    MQTTClient_connectOptions conn_opts = MQTTClient_connectOptions_initializer;
    MQTTClient_SSLOptions ssl_opts = MQTTClient_SSLOptions_initializer;
    
    MQTTClient_create(&client, BROKER_URI, CLIENT_ID,
                      MQTTCLIENT_PERSISTENCE_NONE, NULL);
    
    // Configure SSL with PQ
    ssl_opts.ssl_ctx = create_pq_ssl_ctx();
    ssl_opts.verify = 1;
    conn_opts.ssl = &ssl_opts;
    
    // Connect
    conn_opts.keepAliveInterval = 60;
    conn_opts.cleansession = 1;
    
    int rc = MQTTClient_connect(client, &conn_opts);
    if (rc != MQTTCLIENT_SUCCESS) {
        printf("MQTT connection failed: %d\n", rc);
        return -1;
    }
    
    printf("Connected to MQTT broker with PQ TLS\n");
    
    // Publish sensor data
    const char *topic = "sensors/temperature";
    const char *payload = "{\"temp\": 23.5, \"unit\": \"C\"}";
    
    MQTTClient_publish(client, topic, strlen(payload), payload, 1, 0, NULL);
    
    return 0;
}
\end{lstlisting}

\subsection{MQTT-SN for Constrained Devices}
\label{subsec:mqtt-sn}

MQTT-SN (Sensor Networks) is designed for constrained devices and can use DTLS:

\begin{table}[H]
\centering
\caption{MQTT vs MQTT-SN for PQC}
\label{tab:mqtt-vs-sn}
\begin{tabular}{lcc}
\toprule
\textbf{Aspect} & \textbf{MQTT} & \textbf{MQTT-SN} \\
\midrule
Transport & TCP & UDP, ZigBee, etc. \\
Security layer & TLS & DTLS \\
Message size & Variable & Optimized (small) \\
Topic handling & String names & Numeric IDs \\
Gateway & Not needed & Required \\
PQ suitability & Good & Limited* \\
\bottomrule
\end{tabular}
\begin{tablenotes}
\small
\item *Limited by DTLS fragmentation overhead
\end{tablenotes}
\end{table}

\section{CoAP with PQC}
\label{sec:coap}

Constrained Application Protocol (CoAP) is a lightweight RESTful protocol for IoT, secured with DTLS or OSCORE.

\subsection{CoAP Security Options}
\label{subsec:coap-security}

\begin{table}[H]
\centering
\caption{CoAP security modes}
\label{tab:coap-security}
\begin{tabular}{lccc}
\toprule
\textbf{Mode} & \textbf{Security} & \textbf{End-to-End} & \textbf{PQ Support} \\
\midrule
NoSec & None & N/A & N/A \\
DTLS (PSK) & Transport & No (hop-by-hop) & Limited \\
DTLS (Cert) & Transport & No (hop-by-hop) & Yes (hybrid) \\
OSCORE & Object & Yes & Planned \\
\bottomrule
\end{tabular}
\end{table}

\subsection{OSCORE: Object Security for CoAP}
\label{subsec:oscore}

OSCORE (RFC 8613) provides end-to-end security for CoAP, independent of transport security.

\begin{lstlisting}[language=C, caption={OSCORE context with PQ key establishment}, label={lst:oscore}]
// OSCORE security context derived from PQ KEM
typedef struct {
    uint8_t master_secret[32];   // From ML-KEM shared secret
    uint8_t master_salt[8];      // Optional
    uint8_t sender_id[8];
    size_t sender_id_len;
    uint8_t recipient_id[8];
    size_t recipient_id_len;
    uint8_t common_iv[13];       // Derived
    uint8_t sender_key[16];      // Derived (AES-128)
    uint8_t recipient_key[16];   // Derived
} oscore_ctx_t;

// Initialize OSCORE from ML-KEM exchange
int oscore_init_from_kem(oscore_ctx_t *ctx, 
                         const uint8_t kem_shared_secret[32],
                         const uint8_t *sender_id, size_t sender_id_len,
                         const uint8_t *recipient_id, size_t recipient_id_len) {
    // Copy shared secret as master secret
    memcpy(ctx->master_secret, kem_shared_secret, 32);
    
    // Copy IDs
    memcpy(ctx->sender_id, sender_id, sender_id_len);
    ctx->sender_id_len = sender_id_len;
    memcpy(ctx->recipient_id, recipient_id, recipient_id_len);
    ctx->recipient_id_len = recipient_id_len;
    
    // Derive keys using HKDF
    // Common IV = HKDF(master_secret, info="IV")
    hkdf_sha256(ctx->common_iv, 13, 
                ctx->master_secret, 32,
                NULL, 0,  // salt
                "OSCORE IV", 9);
    
    // Sender key = HKDF(master_secret, info="Key" || sender_id)
    uint8_t info[64];
    size_t info_len = 0;
    memcpy(info, "Key", 3); info_len += 3;
    memcpy(info + info_len, sender_id, sender_id_len); 
    info_len += sender_id_len;
    
    hkdf_sha256(ctx->sender_key, 16,
                ctx->master_secret, 32,
                NULL, 0, info, info_len);
    
    // Similarly derive recipient_key...
    
    return 0;
}
\end{lstlisting}

\subsection{EDHOC: Lightweight Key Exchange}
\label{subsec:edhoc}

EDHOC (Ephemeral Diffie-Hellman Over COSE) is a compact key exchange protocol designed for constrained IoT.

\begin{table}[H]
\centering
\caption{EDHOC vs DTLS handshake comparison}
\label{tab:edhoc-vs-dtls}
\begin{tabular}{lcc}
\toprule
\textbf{Aspect} & \textbf{EDHOC} & \textbf{DTLS 1.3} \\
\midrule
Messages & 3 & 6+ \\
Total bytes (ECDH) & $\sim$200 B & $\sim$500 B \\
Total bytes (PQ hybrid) & $\sim$2.5 KB & $\sim$4 KB \\
Round trips & 1.5 & 2+ \\
Result & OSCORE context & TLS record layer \\
PQ extension & Draft & Supported \\
\bottomrule
\end{tabular}
\end{table}

\begin{lstlisting}[language=C, caption={EDHOC with PQ (conceptual)}, label={lst:edhoc-pq}]
// EDHOC message 1 with hybrid key share
typedef struct {
    uint8_t method;              // Key exchange method
    uint8_t suites[4];           // Cipher suites
    uint8_t g_x_classical[32];   // X25519 ephemeral public
    uint8_t g_x_pq[1184];        // ML-KEM-768 encapsulation key
    uint8_t c_i;                 // Connection identifier initiator
} edhoc_msg1_pq_t;

// EDHOC message 2 with hybrid response
typedef struct {
    uint8_t c_i;                 // Echo connection ID
    uint8_t g_y_classical[32];   // X25519 ephemeral public
    uint8_t g_y_pq[1088];        // ML-KEM-768 ciphertext
    uint8_t ciphertext[];        // Encrypted ID_CRED_R, Signature
} edhoc_msg2_pq_t;

// Shared secret derivation
// ss = KDF(X25519_ss || ML-KEM_ss, context)
\end{lstlisting}

\section{Matter Protocol}
\label{sec:matter}

Matter is the new smart home standard supported by Apple, Google, Amazon, and Samsung. PQC migration is being planned for future versions.

\subsection{Matter Security Architecture}
\label{subsec:matter-security}

\begin{table}[H]
\centering
\caption{Matter security layers}
\label{tab:matter-security}
\begin{tabular}{lll}
\toprule
\textbf{Layer} & \textbf{Current} & \textbf{PQ Migration Path} \\
\midrule
Device attestation & ECDSA P-256 & ML-DSA or Falcon \\
Commissioning & SPAKE2+ & SPAKE2+ (quantum-safe?) \\
Session security & CASE (ECDH) & Hybrid ECDH + ML-KEM \\
Message encryption & AES-CCM-128 & AES-CCM-128 (unchanged) \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Matter Commissioning with PQC}
\label{subsec:matter-commission}

\begin{lstlisting}[language=C, caption={Matter CASE with hybrid key exchange}, label={lst:matter-case}]
// Certificate Authenticated Session Establishment (CASE)
// Modified for hybrid PQ key exchange

typedef struct {
    // Session identifiers
    uint16_t session_id;
    uint64_t node_id;
    
    // Key exchange (hybrid)
    struct {
        uint8_t ecdh_public[65];      // P-256 uncompressed
        uint8_t mlkem_encap[1184];    // ML-KEM-768 encapsulation key
    } ephemeral_keys;
    
    // Device certificate (currently ECDSA, future: ML-DSA)
    uint8_t certificate[MAX_CERT_SIZE];
    
    // Signature over transcript
    uint8_t signature[MAX_SIG_SIZE];
    
} matter_case_sigma1_pq_t;

// Hybrid shared secret computation
int matter_compute_shared_secret(
    uint8_t shared_secret[32],
    const uint8_t *ecdh_private,
    const uint8_t *ecdh_peer_public,
    const uint8_t *mlkem_private,
    const uint8_t *mlkem_ciphertext
) {
    uint8_t ecdh_ss[32];
    uint8_t mlkem_ss[32];
    
    // ECDH key agreement
    ecdh_compute_shared(ecdh_ss, ecdh_private, ecdh_peer_public);
    
    // ML-KEM decapsulation
    mlkem768_decaps(mlkem_ss, mlkem_ciphertext, mlkem_private);
    
    // Combine: SS = KDF(ECDH_SS || MLKEM_SS)
    uint8_t combined[64];
    memcpy(combined, ecdh_ss, 32);
    memcpy(combined + 32, mlkem_ss, 32);
    
    hkdf_sha256(shared_secret, 32, combined, 64, 
                "Matter CASE Hybrid", 18);
    
    // Securely clear intermediates
    secure_zero(ecdh_ss, 32);
    secure_zero(mlkem_ss, 32);
    secure_zero(combined, 64);
    
    return 0;
}
\end{lstlisting}

\section{LoRaWAN Security}
\label{sec:lorawan}

LoRaWAN presents unique challenges for PQC due to extreme bandwidth constraints.

\subsection{LoRaWAN Constraints}
\label{subsec:lorawan-constraints}

\begin{table}[H]
\centering
\caption{LoRaWAN data rate limitations}
\label{tab:lorawan-dr}
\begin{tabular}{lccc}
\toprule
\textbf{Spreading Factor} & \textbf{Data Rate} & \textbf{Max Payload} & \textbf{ToA (51B)} \\
\midrule
SF7 (DR5) & 5.5 kbps & 242 B & 72 ms \\
SF8 (DR4) & 3.1 kbps & 242 B & 144 ms \\
SF9 (DR3) & 1.8 kbps & 123 B & 267 ms \\
SF10 (DR2) & 980 bps & 59 B & 493 ms \\
SF11 (DR1) & 440 bps & 59 B & 987 ms \\
SF12 (DR0) & 250 bps & 59 B & 1,810 ms \\
\bottomrule
\end{tabular}
\end{table}

\warningbox{ML-KEM-768 public key (1,184 B) would require 5+ LoRaWAN frames at SF7 or 20+ frames at SF12. Standard PQC key exchange is impractical for LoRaWAN.}

\subsection{PQC Strategies for LoRaWAN}
\label{subsec:lorawan-pq}

\subsubsection{Option 1: Pre-Provisioned Keys}

\begin{lstlisting}[language=C, caption={PQ key pre-provisioning for LoRaWAN}, label={lst:lorawan-preprov}]
// At manufacturing time:
// 1. Generate ML-KEM keypair for network server
// 2. Encapsulate shared secret with device's public key
// 3. Store symmetric key in device secure element

typedef struct {
    uint8_t dev_eui[8];           // Device identifier
    uint8_t app_key[16];          // Derived from ML-KEM SS (AES-128)
    uint8_t nwk_key[16];          // Derived from ML-KEM SS
    uint8_t kem_key_id[4];        // Reference to PQ key used
} lorawan_pq_credentials_t;

// Join procedure uses pre-shared keys
// No PQ exchange needed over-the-air
\end{lstlisting}

\subsubsection{Option 2: Out-of-Band Key Exchange}

\begin{lstlisting}[language=C, caption={Out-of-band PQ key exchange}, label={lst:lorawan-oob}]
// PQ key exchange via different channel (WiFi, BLE, USB)
// before LoRaWAN commissioning

int lorawan_pq_oob_setup(lorawan_device_t *device) {
    // Step 1: Establish BLE connection for key exchange
    ble_connect(device->ble_address);
    
    // Step 2: Perform ML-KEM key exchange over BLE
    uint8_t pk[MLKEM768_PK_SIZE];
    uint8_t ct[MLKEM768_CT_SIZE];
    uint8_t ss[32];
    
    mlkem768_keypair(pk, device->sk);
    ble_send(pk, sizeof(pk));
    ble_receive(ct, sizeof(ct));
    mlkem768_decaps(ss, ct, device->sk);
    
    // Step 3: Derive LoRaWAN keys from shared secret
    derive_lorawan_keys(&device->credentials, ss);
    
    // Step 4: Proceed with standard LoRaWAN join
    // (now using PQ-derived keys)
    ble_disconnect();
    lorawan_join(device);
    
    return 0;
}
\end{lstlisting}

\subsubsection{Option 3: Lightweight PQC Research}

Research is ongoing for PQC schemes optimized for constrained environments:
\begin{itemize}
    \item \textbf{FrodoKEM}: More conservative, but larger keys
    \item \textbf{NTRU LPRime}: Potentially smaller keys
    \item \textbf{Symmetric ratcheting}: Extend initial PQ key
\end{itemize}

\section{Zigbee and Thread}
\label{sec:zigbee-thread}

\subsection{Zigbee Security}
\label{subsec:zigbee}

Zigbee uses AES-128 for link and network security. PQC integration would affect:
\begin{itemize}
    \item \textbf{Trust Center}: Key distribution mechanism
    \item \textbf{Install codes}: Device provisioning
    \item \textbf{Link keys}: Pairwise device keys
\end{itemize}

\subsection{Thread Security}
\label{subsec:thread}

Thread uses DTLS for commissioning and MLE (Mesh Link Establishment) for network security.

\begin{table}[H]
\centering
\caption{Thread security with PQC considerations}
\label{tab:thread-security}
\begin{tabular}{lll}
\toprule
\textbf{Phase} & \textbf{Current Security} & \textbf{PQ Upgrade Path} \\
\midrule
Commissioning & DTLS 1.2 + J-PAKE & DTLS 1.3 + hybrid \\
MLE & AES-CCM & AES-CCM (unchanged) \\
Border Router & TLS 1.2 & TLS 1.3 + hybrid \\
Matter integration & CASE & Hybrid CASE \\
\bottomrule
\end{tabular}
\end{table}

\section{Protocol Migration Strategy}
\label{sec:protocol-migration}

\subsection{Phased Approach}
\label{subsec:phased-migration}

\begin{table}[H]
\centering
\caption{Recommended PQC protocol migration phases}
\label{tab:migration-phases}
\begin{tabular}{clll}
\toprule
\textbf{Phase} & \textbf{Timeframe} & \textbf{Action} & \textbf{Impact} \\
\midrule
1 & 2024--2025 & Inventory cryptographic assets & None \\
2 & 2025--2026 & Test hybrid TLS/DTLS & Low \\
3 & 2026--2027 & Deploy hybrid in production & Medium \\
4 & 2027--2030 & Transition to pure PQ & High \\
5 & 2030+ & Deprecate classical-only & Full \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Backward Compatibility}
\label{subsec:backward-compat}

\begin{lstlisting}[language=C, caption={Negotiating PQ support}, label={lst:negotiate-pq}]
// Server-side: support both classical and hybrid
int configure_flexible_server(WOLFSSL_CTX *ctx) {
    // Offer multiple options in preference order
    int groups[] = {
        // Hybrid (preferred)
        WOLFSSL_P256_KYBER_LEVEL1,
        WOLFSSL_X25519_KYBER_LEVEL1,
        // Pure PQ (if client supports)
        WOLFSSL_KYBER_LEVEL3,
        // Classical fallback
        WOLFSSL_ECC_SECP256R1,
        WOLFSSL_ECC_X25519
    };
    
    wolfSSL_CTX_set_groups(ctx, groups, 
                           sizeof(groups)/sizeof(groups[0]));
    
    // Log negotiated algorithm for monitoring
    wolfSSL_CTX_set_info_callback(ctx, connection_info_cb);
    
    return 0;
}

void connection_info_cb(const WOLFSSL *ssl, int type, int val) {
    if (type == SSL_CB_HANDSHAKE_DONE) {
        const char *kex = wolfSSL_get_curve_name(ssl);
        const char *cipher = wolfSSL_get_cipher(ssl);
        
        if (strstr(kex, "KYBER") || strstr(kex, "kyber")) {
            log_info("PQ-secured connection: %s, %s", kex, cipher);
        } else {
            log_warn("Classical-only connection: %s, %s", kex, cipher);
        }
    }
}
\end{lstlisting}

\section{Chapter Summary}
\label{sec:ch8-summary}

This chapter covered PQC integration into IoT protocols:

\textbf{TLS 1.3}:
\begin{itemize}
    \item Hybrid key exchange (X25519 + ML-KEM) is recommended
    \item Certificate chains grow 5--7$\times$ with ML-DSA
    \item Handshake overhead is manageable for most IoT
\end{itemize}

\textbf{DTLS 1.3}:
\begin{itemize}
    \item Fragmentation adds significant overhead
    \item Connection ID reduces re-handshake frequency
    \item May be impractical for very constrained networks
\end{itemize}

\textbf{MQTT}:
\begin{itemize}
    \item PQC via underlying TLS layer
    \item MQTT-SN faces DTLS fragmentation challenges
\end{itemize}

\textbf{CoAP}:
\begin{itemize}
    \item DTLS provides transport security
    \item OSCORE offers end-to-end security
    \item EDHOC provides lightweight key exchange
\end{itemize}

\textbf{LoRaWAN}:
\begin{itemize}
    \item Standard PQC key exchange is impractical
    \item Use pre-provisioned keys or out-of-band exchange
\end{itemize}

\textbf{Matter}:
\begin{itemize}
    \item PQC migration planned for future versions
    \item Hybrid CASE key exchange
\end{itemize}

\infobox{For most IoT deployments, \textbf{hybrid TLS 1.3} with X25519 + ML-KEM-768 provides the best balance of security and compatibility. Deploy hybrid now to protect long-lived data against future quantum attacks.}

% End of Chapter 8

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% CHAPTER 9: SECURITY ANALYSIS AND BEST PRACTICES
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Security Analysis and Best Practices}
\label{chap:security}

The deployment of post-quantum cryptography in IoT environments introduces unique security challenges that extend beyond algorithm selection. This chapter provides a comprehensive security analysis framework, covering threat modeling specific to PQC-enabled IoT systems, side-channel vulnerability assessment, and security parameter selection guidelines. We present practical methodologies for evaluating and mitigating risks in constrained deployments.

\section{Threat Modeling for PQC-IoT Systems}
\label{sec:threat-modeling}

\subsection{The STRIDE-PQ Framework}

Traditional threat modeling frameworks require adaptation for post-quantum scenarios. We extend the STRIDE model to address quantum-specific threats:

\begin{table}[htbp]
\centering
\caption{STRIDE-PQ: Extended Threat Model for Post-Quantum IoT}
\label{tab:stride-pq}
\begin{tabular}{@{}llp{6cm}@{}}
\toprule
\textbf{Category} & \textbf{Classical Threat} & \textbf{Quantum Extension} \\
\midrule
\textbf{S}poofing & Identity theft & Forged PQ signatures, compromised device attestation \\
\textbf{T}ampering & Data modification & Algorithm substitution attacks, parameter manipulation \\
\textbf{R}epudiation & Denial of actions & Signature scheme migration disputes \\
\textbf{I}nformation Disclosure & Data leakage & Harvest-now-decrypt-later (HNDL), side-channel extraction \\
\textbf{D}enial of Service & Resource exhaustion & PQ computation DoS, memory exhaustion attacks \\
\textbf{E}levation of Privilege & Unauthorized access & Quantum-assisted key recovery, hybrid downgrade \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Harvest-Now-Decrypt-Later (HNDL) Risk Assessment}

The HNDL threat represents the most pressing concern for IoT deployments. Adversaries intercept and store encrypted communications today, planning to decrypt them once quantum computers become available.

\begin{figure}[htbp]
\centering
\begin{tikzpicture}[scale=0.9]
    % Timeline
    \draw[thick,->] (0,0) -- (14,0) node[right] {Time};
    
    % Time markers
    \foreach \x/\year in {1/2024, 4/2027, 7/2030, 10/2033, 13/2035+} {
        \draw (\x,0.1) -- (\x,-0.1);
        \node[below] at (\x,-0.2) {\footnotesize \year};
    }
    
    % Data sensitivity period
    \fill[blue!20] (1,0.5) rectangle (10,1.5);
    \draw[blue,thick] (1,0.5) rectangle (10,1.5);
    \node at (5.5,1) {\footnotesize Data Sensitivity Period};
    
    % Harvest period
    \fill[red!20] (1,2) rectangle (7,3);
    \draw[red,thick] (1,2) rectangle (7,3);
    \node at (4,2.5) {\footnotesize Adversary Harvest Window};
    
    % Quantum capability
    \fill[orange!30] (7,3.5) rectangle (13,4.5);
    \draw[orange,thick] (7,3.5) rectangle (13,4.5);
    \node at (10,4) {\footnotesize Quantum Decryption Capability};
    
    % Risk zone
    \draw[purple,very thick,dashed] (7,0.5) -- (7,4.5);
    \node[purple,rotate=90] at (6.5,2.5) {\footnotesize CRQC};
    
    % Legend
    \node[right] at (0,5) {\footnotesize CRQC = Cryptographically Relevant Quantum Computer};
\end{tikzpicture}
\caption{HNDL Timeline Risk Visualization}
\label{fig:hndl-timeline}
\end{figure}

\warningbox{If your IoT data must remain confidential for $X$ years, and you estimate CRQC arrival in $Y$ years, you must deploy PQC within $(Y - X)$ years. For medical devices with 25-year data retention and 2030 CRQC estimates, PQC deployment should have started in 2020.}

\textbf{HNDL Risk Calculation Formula:}

\begin{equation}
\text{HNDL\_Risk} = P(\text{CRQC}_t) \times V(\text{data}) \times \left(1 - e^{-\lambda \cdot T_{\text{sensitive}}}\right)
\label{eq:hndl-risk}
\end{equation}

Where:
\begin{itemize}
    \item $P(\text{CRQC}_t)$ = Probability of CRQC availability by time $t$
    \item $V(\text{data})$ = Value/sensitivity of the data
    \item $\lambda$ = Data capture rate by adversaries
    \item $T_{\text{sensitive}}$ = Duration data remains sensitive
\end{itemize}

\subsection{IoT-Specific Attack Surfaces}

IoT devices present unique attack surfaces that differ significantly from traditional computing environments:

\begin{lstlisting}[style=cstyle, caption={Attack Surface Enumeration for PQC-IoT Device}]
/* IoT PQC Attack Surface Analysis */

typedef enum {
    /* Physical Layer Attacks */
    ATTACK_PHYSICAL_PROBING,      // Direct hardware access
    ATTACK_FAULT_INJECTION,       // Voltage/clock glitching
    ATTACK_COLD_BOOT,             // Memory extraction
    ATTACK_JTAG_DEBUG,            // Debug interface exploitation
    
    /* Side-Channel Attacks */
    ATTACK_TIMING,                // Execution time analysis
    ATTACK_POWER_ANALYSIS,        // SPA/DPA/CPA
    ATTACK_EM_EMANATION,          // Electromagnetic analysis
    ATTACK_ACOUSTIC,              // Sound-based leakage
    ATTACK_CACHE_TIMING,          // Cache access patterns
    
    /* Cryptographic Attacks */
    ATTACK_IMPLEMENTATION,        // Incorrect implementation
    ATTACK_PARAMETER_MISUSE,      // Wrong security level
    ATTACK_RNG_WEAKNESS,          // Poor randomness
    ATTACK_KEY_REUSE,             // Nonce/key reuse
    ATTACK_HYBRID_DOWNGRADE,      // Force classical-only
    
    /* Protocol Attacks */
    ATTACK_REPLAY,                // Message replay
    ATTACK_MITM,                  // Man-in-the-middle
    ATTACK_FRAGMENTATION,         // Reassembly attacks
    ATTACK_CERTIFICATE_MISUSE,    // Cert validation bypass
    
    /* Supply Chain Attacks */
    ATTACK_FIRMWARE_TAMPERING,    // Modified firmware
    ATTACK_BACKDOOR,              // Malicious code insertion
    ATTACK_COMPONENT_SUBSTITUTION // Counterfeit components
} iot_attack_vector_t;

/* Risk scoring structure */
typedef struct {
    iot_attack_vector_t vector;
    uint8_t likelihood;      // 1-10 scale
    uint8_t impact;          // 1-10 scale
    uint8_t detectability;   // 1-10 (10 = hard to detect)
    char mitigation[256];
} attack_risk_t;

/* Example risk assessment */
static const attack_risk_t pqc_risks[] = {
    {ATTACK_POWER_ANALYSIS, 8, 9, 7, 
     "Constant-time implementation, masking"},
    {ATTACK_TIMING, 9, 8, 5, 
     "Constant-time code, no secret-dependent branches"},
    {ATTACK_RNG_WEAKNESS, 6, 10, 8, 
     "Hardware TRNG, NIST SP 800-90A DRBG"},
    {ATTACK_HYBRID_DOWNGRADE, 5, 9, 4, 
     "Strict hybrid enforcement, no fallback"},
    {ATTACK_IMPLEMENTATION, 7, 10, 6, 
     "Use certified libraries, formal verification"}
};
\end{lstlisting}

\subsection{Threat Actor Profiling}

Understanding adversary capabilities is essential for appropriate countermeasure selection:

\begin{table}[htbp]
\centering
\caption{Threat Actor Capabilities for PQC-IoT Attacks}
\label{tab:threat-actors}
\begin{tabular}{@{}lcccc@{}}
\toprule
\textbf{Actor Type} & \textbf{Quantum Access} & \textbf{Side-Channel} & \textbf{Resources} & \textbf{Persistence} \\
\midrule
Script Kiddie & None & Basic timing & Low & Low \\
Cybercriminal & None (future) & Commercial tools & Medium & Medium \\
Competitor & Cloud (future) & Lab equipment & Medium-High & High \\
Nation State & Own CRQC & Advanced lab & Unlimited & Very High \\
Insider & Indirect & Physical access & Variable & Variable \\
\bottomrule
\end{tabular}
\end{table}

\section{Side-Channel Vulnerability Analysis}
\label{sec:side-channel-analysis}

\subsection{Algorithm-Specific Vulnerabilities}

Each PQC algorithm family presents distinct side-channel characteristics:

\subsubsection{ML-KEM Side-Channel Profile}

\begin{table}[htbp]
\centering
\caption{ML-KEM Side-Channel Vulnerability Assessment}
\label{tab:mlkem-sidechannel}
\begin{tabular}{@{}lllp{5cm}@{}}
\toprule
\textbf{Operation} & \textbf{Vulnerability} & \textbf{Severity} & \textbf{Mitigation} \\
\midrule
NTT butterfly & Timing & Medium & Constant-time multiplication \\
Modular reduction & Power (DPA) & High & Masking, shuffling \\
Polynomial sampling & Timing & High & Constant-time rejection sampling \\
Comparison (decaps) & Timing & Critical & Constant-time comparison \\
Secret key access & Cache & High & Memory access patterns masking \\
SHAKE operations & Power & Medium & Masked Keccak implementation \\
\bottomrule
\end{tabular}
\end{table}

\begin{lstlisting}[style=cstyle, caption={Constant-Time Comparison for ML-KEM Decapsulation}]
/* CRITICAL: Decapsulation comparison must be constant-time */

#include <stdint.h>
#include <stddef.h>

/*
 * Constant-time byte array comparison
 * Returns 0 if equal, non-zero otherwise
 * Execution time independent of data values
 */
static int ct_memcmp(const uint8_t *a, const uint8_t *b, size_t len) {
    volatile uint8_t result = 0;
    
    for (size_t i = 0; i < len; i++) {
        result |= a[i] ^ b[i];
    }
    
    /* Convert to 0 or 1 in constant time */
    result = (result - 1) >> 8;  /* 0xFF if zero, 0x00 otherwise */
    return (int)(result & 1) ^ 1;
}

/*
 * Constant-time conditional select
 * Returns a if selector == 0, b if selector == 1
 */
static void ct_select(uint8_t *out, 
                      const uint8_t *a, 
                      const uint8_t *b,
                      size_t len,
                      uint8_t selector) {
    /* Expand selector to full byte mask */
    uint8_t mask = (uint8_t)(-(int8_t)selector);  /* 0xFF or 0x00 */
    
    for (size_t i = 0; i < len; i++) {
        out[i] = a[i] ^ (mask & (a[i] ^ b[i]));
    }
}

/*
 * ML-KEM decapsulation with side-channel protection
 * Implements implicit rejection per FIPS 203
 */
int mlkem_decaps_protected(uint8_t *shared_secret,
                           const uint8_t *ciphertext,
                           const uint8_t *secret_key) {
    uint8_t expected_ct[MLKEM_CIPHERTEXT_BYTES];
    uint8_t ss_real[MLKEM_SHARED_SECRET_BYTES];
    uint8_t ss_fake[MLKEM_SHARED_SECRET_BYTES];
    uint8_t decrypted_msg[MLKEM_MSG_BYTES];
    
    /* Step 1: Decrypt ciphertext to recover message */
    mlkem_decrypt_internal(decrypted_msg, ciphertext, secret_key);
    
    /* Step 2: Re-encrypt to get expected ciphertext */
    mlkem_encrypt_internal(expected_ct, decrypted_msg, 
                          secret_key + MLKEM_SECRET_KEY_OFFSET);
    
    /* Step 3: Constant-time comparison */
    int cmp_result = ct_memcmp(ciphertext, expected_ct, 
                               MLKEM_CIPHERTEXT_BYTES);
    
    /* Step 4: Compute both possible shared secrets */
    /* Real shared secret from decrypted message */
    shake256(ss_real, MLKEM_SHARED_SECRET_BYTES,
             decrypted_msg, MLKEM_MSG_BYTES);
    
    /* Fake shared secret from implicit rejection value */
    shake256(ss_fake, MLKEM_SHARED_SECRET_BYTES,
             secret_key + MLKEM_Z_OFFSET, MLKEM_Z_BYTES);
    
    /* Step 5: Constant-time select based on comparison */
    ct_select(shared_secret, ss_real, ss_fake,
              MLKEM_SHARED_SECRET_BYTES, (uint8_t)cmp_result);
    
    /* Clear sensitive data */
    secure_zero(decrypted_msg, sizeof(decrypted_msg));
    secure_zero(ss_real, sizeof(ss_real));
    secure_zero(ss_fake, sizeof(ss_fake));
    secure_zero(expected_ct, sizeof(expected_ct));
    
    return 0;  /* Always return success (implicit rejection) */
}
\end{lstlisting}

\subsubsection{ML-DSA Side-Channel Profile}

ML-DSA's rejection sampling during signature generation creates significant timing vulnerabilities:

\begin{lstlisting}[style=cstyle, caption={ML-DSA Timing Attack and Mitigation}]
/*
 * ML-DSA VULNERABLE rejection sampling (DO NOT USE)
 * Variable number of iterations leaks information about secret key
 */
int mldsa_sign_VULNERABLE(uint8_t *sig, const uint8_t *msg, 
                          size_t msg_len, const uint8_t *sk) {
    poly_vec y, w, z;
    uint16_t nonce = 0;
    
    while (1) {
        /* Sample y from uniform distribution */
        expand_mask(&y, sk, nonce++);
        
        /* Compute w = A*y */
        matrix_vector_mul(&w, &A, &y);
        
        /* Compute challenge c = H(w, msg) */
        challenge_hash(&c, &w, msg, msg_len);
        
        /* Compute z = y + c*s1 */
        poly_vec_mul_add(&z, &c, &s1, &y);
        
        /* TIMING LEAK: Different messages require different
         * numbers of iterations, leaking info about s1 */
        if (check_norm(&z) && check_hints(&h)) {
            break;  /* Variable timing! */
        }
    }
    
    pack_signature(sig, &z, &h, &c);
    return 0;
}

/*
 * Side-channel resistant approach: Deterministic timing
 * Always perform fixed number of iterations
 */
int mldsa_sign_protected(uint8_t *sig, const uint8_t *msg,
                         size_t msg_len, const uint8_t *sk) {
    poly_vec y, w, z;
    poly_vec z_candidates[MAX_SIGN_ITERATIONS];
    uint8_t valid[MAX_SIGN_ITERATIONS];
    uint16_t nonce = 0;
    
    /* Always perform MAX_SIGN_ITERATIONS attempts */
    for (int i = 0; i < MAX_SIGN_ITERATIONS; i++) {
        expand_mask(&y, sk, nonce++);
        matrix_vector_mul(&w, &A, &y);
        challenge_hash(&c, &w, msg, msg_len);
        poly_vec_mul_add(&z_candidates[i], &c, &s1, &y);
        
        /* Check validity but don't branch */
        valid[i] = (check_norm(&z_candidates[i]) && 
                    check_hints(&h)) ? 1 : 0;
    }
    
    /* Constant-time selection of first valid signature */
    int selected = ct_select_first_valid(valid, MAX_SIGN_ITERATIONS);
    
    if (selected < 0) {
        return -1;  /* Extremely rare: no valid signature found */
    }
    
    /* Copy selected signature in constant time */
    ct_copy_signature(sig, z_candidates, selected, MAX_SIGN_ITERATIONS);
    
    /* Clear all candidates */
    secure_zero(z_candidates, sizeof(z_candidates));
    
    return 0;
}
\end{lstlisting}

\subsubsection{Falcon Side-Channel Profile}

Falcon's use of floating-point arithmetic in its sampler creates unique challenges:

\begin{table}[htbp]
\centering
\caption{Falcon Floating-Point Side-Channel Risks}
\label{tab:falcon-float}
\begin{tabular}{@{}llp{6cm}@{}}
\toprule
\textbf{Component} & \textbf{Risk Level} & \textbf{Details} \\
\midrule
Fast Fourier Sampling & Critical & FPU operations have data-dependent timing on most platforms \\
Gaussian sampler & High & Rejection sampling with variable iterations \\
Tree traversal & Medium & Access patterns may leak secret structure \\
Integer conversion & Medium & Float-to-int conversion timing varies \\
\bottomrule
\end{tabular}
\end{table}

\begin{lstlisting}[style=cstyle, caption={Falcon Constant-Time Gaussian Sampling (Simplified)}]
/*
 * Falcon requires constant-time Gaussian sampling
 * This is a simplified illustration of the approach
 */

#include <stdint.h>
#include <math.h>

/* Precomputed cumulative distribution table */
static const uint64_t gaussian_cdf[256] = {
    /* Values for sigma = 1.17*sqrt(q/2n) */
    0x0000000000000000ULL, 0x00000000027A3B39ULL,
    /* ... (full table omitted for brevity) */
};

/*
 * Constant-time Gaussian sampler using CDT
 * Avoids rejection sampling timing leaks
 */
static int32_t sample_gaussian_ct(uint64_t random_bits) {
    int32_t result = 0;
    uint64_t mask;
    
    /* Compare against all table entries in constant time */
    for (int i = 0; i < 256; i++) {
        /* mask = 0xFFFFFFFF if random_bits >= gaussian_cdf[i] */
        mask = (uint64_t)(-(int64_t)(random_bits >= gaussian_cdf[i]));
        
        /* Increment result if condition met */
        result += (int32_t)(mask & 1);
    }
    
    /* Apply sign bit from additional random bit */
    int32_t sign = (int32_t)((random_bits >> 63) & 1);
    sign = 1 - 2 * sign;  /* Convert 0/1 to +1/-1 */
    
    return result * sign;
}

/*
 * Fixed-point arithmetic alternative for constrained devices
 * Avoids floating-point timing variations entirely
 */
typedef int64_t fxp_t;  /* Q32.32 fixed point */

#define FXP_ONE ((fxp_t)1 << 32)
#define FXP_HALF ((fxp_t)1 << 31)

static fxp_t fxp_mul(fxp_t a, fxp_t b) {
    /* Constant-time 64-bit multiplication */
    __int128 temp = (__int128)a * b;
    return (fxp_t)(temp >> 32);
}

static fxp_t fxp_exp_neg(fxp_t x) {
    /* Polynomial approximation of exp(-x) for x >= 0 */
    /* Coefficients scaled for Q32.32 format */
    static const fxp_t coeffs[] = {
        FXP_ONE,                    /* 1 */
        -FXP_ONE,                   /* -x */
        FXP_HALF,                   /* x^2/2 */
        -0x2AAAAAABLL,              /* -x^3/6 */
        0x0AAAAAABLL,               /* x^4/24 */
    };
    
    fxp_t result = coeffs[4];
    for (int i = 3; i >= 0; i--) {
        result = fxp_mul(result, x) + coeffs[i];
    }
    
    return result;
}
\end{lstlisting}

\subsection{Power Analysis Countermeasures}

\subsubsection{Masking Techniques}

Boolean and arithmetic masking protect against differential power analysis:

\begin{lstlisting}[style=cstyle, caption={First-Order Masking for NTT Operations}]
/*
 * First-order Boolean masking for polynomial coefficients
 * Each coefficient x is split into shares: x = x1 XOR x2
 */

#include <stdint.h>

typedef struct {
    int16_t share1[256];
    int16_t share2[256];
} masked_poly_t;

/* Generate random mask */
static void generate_mask(int16_t *mask, size_t len) {
    /* Use hardware RNG or DRBG */
    for (size_t i = 0; i < len; i++) {
        mask[i] = (int16_t)(get_random_uint32() & 0xFFFF);
    }
}

/* Boolean-to-arithmetic mask conversion */
static int16_t b2a_convert(int16_t x_bool, int16_t r_bool, 
                           int16_t r_arith, int16_t q) {
    /* Convert (x XOR r_bool) to ((x - r_arith) mod q) */
    /* This is a simplified version; full implementation is complex */
    int16_t gamma = get_random_int16() % q;
    int16_t t = (x_bool ^ r_bool) - r_arith + gamma;
    return ((t % q) + q) % q;
}

/* Masked NTT butterfly operation */
static void masked_butterfly(masked_poly_t *p, int i, int j, 
                            int16_t zeta, int16_t q) {
    /* Process both shares independently */
    /* Share 1 */
    int16_t t1 = montgomery_mul(zeta, p->share1[j], q);
    p->share1[j] = barrett_reduce(p->share1[i] - t1, q);
    p->share1[i] = barrett_reduce(p->share1[i] + t1, q);
    
    /* Share 2 - with independent randomization */
    int16_t t2 = montgomery_mul(zeta, p->share2[j], q);
    p->share2[j] = barrett_reduce(p->share2[i] - t2, q);
    p->share2[i] = barrett_reduce(p->share2[i] + t2, q);
    
    /* Refresh masks periodically to prevent higher-order attacks */
    if ((i + j) % 16 == 0) {
        refresh_masks(p, i, j, q);
    }
}

/* Mask refreshing to prevent accumulation attacks */
static void refresh_masks(masked_poly_t *p, int i, int j, int16_t q) {
    int16_t r1 = get_random_int16() % q;
    int16_t r2 = get_random_int16() % q;
    
    p->share1[i] = barrett_reduce(p->share1[i] + r1, q);
    p->share2[i] = barrett_reduce(p->share2[i] - r1, q);
    
    p->share1[j] = barrett_reduce(p->share1[j] + r2, q);
    p->share2[j] = barrett_reduce(p->share2[j] - r2, q);
}

/* Unmask at the end of computation */
static void unmask_poly(int16_t *out, const masked_poly_t *p, 
                        size_t len, int16_t q) {
    for (size_t i = 0; i < len; i++) {
        out[i] = barrett_reduce(p->share1[i] + p->share2[i], q);
    }
}
\end{lstlisting}

\subsubsection{Shuffling Countermeasures}

Randomizing operation order prevents localized power analysis:

\begin{lstlisting}[style=cstyle, caption={Shuffled NTT Implementation}]
/*
 * Shuffled NTT: Randomize butterfly order within each level
 * Prevents adversary from locating specific coefficient operations
 */

#include <stdint.h>
#include <stdlib.h>

/* Fisher-Yates shuffle for index permutation */
static void shuffle_indices(uint16_t *indices, size_t n) {
    for (size_t i = n - 1; i > 0; i--) {
        size_t j = get_random_uint32() % (i + 1);
        /* Swap */
        uint16_t temp = indices[i];
        indices[i] = indices[j];
        indices[j] = temp;
    }
}

/* Shuffled NTT implementation */
void ntt_shuffled(int16_t *poly, const int16_t *zetas, int16_t q) {
    uint16_t indices[128];  /* For n=256, we have 128 butterflies per level */
    
    int k = 1;
    for (int len = 128; len >= 2; len >>= 1) {
        int num_butterflies = 256 / (2 * len);
        
        /* Generate shuffled indices for this level */
        for (int i = 0; i < num_butterflies * len; i++) {
            indices[i] = i;
        }
        shuffle_indices(indices, num_butterflies * len);
        
        /* Perform butterflies in shuffled order */
        for (int idx = 0; idx < num_butterflies * len; idx++) {
            int shuffled_idx = indices[idx];
            int start = (shuffled_idx / len) * 2 * len;
            int offset = shuffled_idx % len;
            
            int i = start + offset;
            int j = i + len;
            int zeta_idx = k + (shuffled_idx / len);
            
            int16_t t = montgomery_mul(zetas[zeta_idx], poly[j], q);
            poly[j] = barrett_reduce(poly[i] - t, q);
            poly[i] = barrett_reduce(poly[i] + t, q);
        }
        
        k += num_butterflies;
    }
    
    /* Clear indices */
    secure_zero(indices, sizeof(indices));
}
\end{lstlisting}

\subsection{Fault Injection Countermeasures}

Fault attacks can bypass cryptographic protections by inducing computational errors:

\begin{lstlisting}[style=cstyle, caption={Fault Detection for ML-KEM Operations}]
/*
 * Double computation with comparison for fault detection
 * Critical operations are performed twice and compared
 */

#include <stdint.h>
#include <stdbool.h>

typedef struct {
    bool fault_detected;
    uint32_t fault_count;
    void (*fault_handler)(void);
} fault_monitor_t;

static fault_monitor_t g_fault_monitor = {
    .fault_detected = false,
    .fault_count = 0,
    .fault_handler = NULL
};

/* Register fault handler */
void register_fault_handler(void (*handler)(void)) {
    g_fault_monitor.fault_handler = handler;
}

/* Check computation result with redundancy */
static bool verify_computation(const uint8_t *result1, 
                               const uint8_t *result2,
                               size_t len) {
    volatile uint8_t diff = 0;
    
    for (size_t i = 0; i < len; i++) {
        diff |= result1[i] ^ result2[i];
    }
    
    if (diff != 0) {
        g_fault_monitor.fault_detected = true;
        g_fault_monitor.fault_count++;
        
        if (g_fault_monitor.fault_handler) {
            g_fault_monitor.fault_handler();
        }
        
        return false;
    }
    
    return true;
}

/*
 * Fault-protected ML-KEM decapsulation
 */
int mlkem_decaps_fault_protected(uint8_t *ss,
                                  const uint8_t *ct,
                                  const uint8_t *sk) {
    uint8_t ss1[32], ss2[32];
    
    /* First computation */
    mlkem_decaps_internal(ss1, ct, sk);
    
    /* Introduce random delay to desynchronize fault timing */
    random_delay(100, 1000);  /* 100-1000 cycles */
    
    /* Second computation with different register allocation */
    mlkem_decaps_internal_variant(ss2, ct, sk);
    
    /* Compare results */
    if (!verify_computation(ss1, ss2, 32)) {
        /* Fault detected - zeroize and return error */
        secure_zero(ss, 32);
        secure_zero(ss1, sizeof(ss1));
        secure_zero(ss2, sizeof(ss2));
        return -1;
    }
    
    /* Copy result and clean up */
    memcpy(ss, ss1, 32);
    secure_zero(ss1, sizeof(ss1));
    secure_zero(ss2, sizeof(ss2));
    
    return 0;
}

/*
 * Algorithm-level integrity check using mathematical properties
 * For NTT: verify NTT(INTT(x)) == x
 */
bool verify_ntt_integrity(const int16_t *original,
                          const int16_t *transformed,
                          size_t n, int16_t q) {
    int16_t verify[256];
    
    /* Apply inverse transform to transformed data */
    memcpy(verify, transformed, n * sizeof(int16_t));
    intt(verify, q);
    
    /* Compare with original */
    volatile int16_t diff = 0;
    for (size_t i = 0; i < n; i++) {
        diff |= original[i] ^ verify[i];
    }
    
    secure_zero(verify, sizeof(verify));
    return (diff == 0);
}

/*
 * Signature verification with fault protection
 * Verify signature twice with different code paths
 */
int verify_signature_fault_protected(const uint8_t *msg, size_t msg_len,
                                     const uint8_t *sig, size_t sig_len,
                                     const uint8_t *pk) {
    volatile int result1, result2;
    
    /* First verification */
    result1 = mldsa_verify(msg, msg_len, sig, sig_len, pk);
    
    /* Random delay */
    random_delay(50, 500);
    
    /* Second verification with reordered operations */
    result2 = mldsa_verify_variant(msg, msg_len, sig, sig_len, pk);
    
    /* Both must agree */
    if (result1 != result2) {
        g_fault_monitor.fault_detected = true;
        g_fault_monitor.fault_count++;
        return -1;  /* Fault detected */
    }
    
    return result1;
}
\end{lstlisting}

\section{Security Parameter Selection}
\label{sec:security-parameters}

\subsection{NIST Security Levels Explained}

NIST defines five security levels based on the computational effort required to break the scheme:

\begin{table}[htbp]
\centering
\caption{NIST Security Levels and Equivalent Strength}
\label{tab:nist-levels}
\begin{tabular}{@{}clll@{}}
\toprule
\textbf{Level} & \textbf{Classical Equivalent} & \textbf{Quantum Equivalent} & \textbf{Reference} \\
\midrule
1 & AES-128 key search & Grover on AES-128 & $2^{128}$ classical \\
2 & SHA-256 collision & Grover on SHA-256 & $2^{128}$ quantum \\
3 & AES-192 key search & Grover on AES-192 & $2^{192}$ classical \\
4 & SHA-384 collision & Grover on SHA-384 & $2^{192}$ quantum \\
5 & AES-256 key search & Grover on AES-256 & $2^{256}$ classical \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Parameter Selection by Application Domain}

\begin{table}[htbp]
\centering
\caption{Recommended Security Levels by IoT Application}
\label{tab:security-by-application}
\begin{tabular}{@{}llll@{}}
\toprule
\textbf{Application} & \textbf{Data Lifetime} & \textbf{Min. Level} & \textbf{Recommended} \\
\midrule
Consumer sensors & 1-3 years & 1 & ML-KEM-512 \\
Smart home & 5-10 years & 1-3 & ML-KEM-768 \\
Industrial IoT & 10-20 years & 3 & ML-KEM-768/1024 \\
Medical devices & 25+ years & 3-5 & ML-KEM-1024 \\
Critical infrastructure & 30+ years & 5 & ML-KEM-1024 + backup \\
Government/Defense & 50+ years & 5 & ML-KEM-1024, ML-DSA-87 \\
\bottomrule
\end{tabular}
\end{table}

\begin{lstlisting}[style=pythonstyle, caption={Security Level Selection Tool}]
#!/usr/bin/env python3
"""
PQC Security Level Selection Tool
Helps select appropriate parameters based on requirements
"""

from dataclasses import dataclass
from enum import Enum
from typing import Optional, List

class SecurityLevel(Enum):
    LEVEL_1 = 1  # ~AES-128
    LEVEL_2 = 2  # ~SHA-256 collision
    LEVEL_3 = 3  # ~AES-192
    LEVEL_4 = 4  # ~SHA-384 collision
    LEVEL_5 = 5  # ~AES-256

@dataclass
class DeviceConstraints:
    ram_kb: int
    flash_kb: int
    cpu_mhz: int
    has_hw_aes: bool = False
    has_hw_sha: bool = False
    battery_powered: bool = False

@dataclass
class SecurityRequirements:
    data_sensitivity: str  # 'low', 'medium', 'high', 'critical'
    data_lifetime_years: int
    threat_actors: List[str]  # 'script_kiddie', 'criminal', 'nation_state'
    compliance: List[str]  # 'none', 'hipaa', 'pci', 'cnsa', 'fips'

# Algorithm parameters database
MLKEM_PARAMS = {
    SecurityLevel.LEVEL_1: {
        'name': 'ML-KEM-512',
        'pk_bytes': 800,
        'sk_bytes': 1632,
        'ct_bytes': 768,
        'ram_required_kb': 8,
        'flash_required_kb': 12,
        'keygen_cycles_m4': 434_000,
        'encaps_cycles_m4': 486_000,
        'decaps_cycles_m4': 524_000,
    },
    SecurityLevel.LEVEL_3: {
        'name': 'ML-KEM-768',
        'pk_bytes': 1184,
        'sk_bytes': 2400,
        'ct_bytes': 1088,
        'ram_required_kb': 12,
        'flash_required_kb': 16,
        'keygen_cycles_m4': 720_000,
        'encaps_cycles_m4': 817_000,
        'decaps_cycles_m4': 879_000,
    },
    SecurityLevel.LEVEL_5: {
        'name': 'ML-KEM-1024',
        'pk_bytes': 1568,
        'sk_bytes': 3168,
        'ct_bytes': 1568,
        'ram_required_kb': 16,
        'flash_required_kb': 20,
        'keygen_cycles_m4': 1_105_000,
        'encaps_cycles_m4': 1_241_000,
        'decaps_cycles_m4': 1_337_000,
    },
}

MLDSA_PARAMS = {
    SecurityLevel.LEVEL_2: {
        'name': 'ML-DSA-44',
        'pk_bytes': 1312,
        'sk_bytes': 2560,
        'sig_bytes': 2420,
        'ram_required_kb': 32,
        'flash_required_kb': 24,
    },
    SecurityLevel.LEVEL_3: {
        'name': 'ML-DSA-65',
        'pk_bytes': 1952,
        'sk_bytes': 4032,
        'sig_bytes': 3293,
        'ram_required_kb': 48,
        'flash_required_kb': 32,
    },
    SecurityLevel.LEVEL_5: {
        'name': 'ML-DSA-87',
        'pk_bytes': 2592,
        'sk_bytes': 4896,
        'sig_bytes': 4595,
        'ram_required_kb': 64,
        'flash_required_kb': 40,
    },
}

def determine_minimum_level(requirements: SecurityRequirements) -> SecurityLevel:
    """Determine minimum required security level from requirements."""
    level = SecurityLevel.LEVEL_1
    
    # Data sensitivity
    sensitivity_map = {
        'low': SecurityLevel.LEVEL_1,
        'medium': SecurityLevel.LEVEL_3,
        'high': SecurityLevel.LEVEL_3,
        'critical': SecurityLevel.LEVEL_5,
    }
    level = max(level, sensitivity_map.get(
        requirements.data_sensitivity, SecurityLevel.LEVEL_1), 
        key=lambda x: x.value)
    
    # Data lifetime (account for HNDL threat)
    if requirements.data_lifetime_years > 25:
        level = max(level, SecurityLevel.LEVEL_5, key=lambda x: x.value)
    elif requirements.data_lifetime_years > 15:
        level = max(level, SecurityLevel.LEVEL_3, key=lambda x: x.value)
    elif requirements.data_lifetime_years > 5:
        level = max(level, SecurityLevel.LEVEL_3, key=lambda x: x.value)
    
    # Threat actors
    if 'nation_state' in requirements.threat_actors:
        level = max(level, SecurityLevel.LEVEL_5, key=lambda x: x.value)
    elif 'criminal' in requirements.threat_actors:
        level = max(level, SecurityLevel.LEVEL_3, key=lambda x: x.value)
    
    # Compliance requirements
    if 'cnsa' in requirements.compliance:
        level = SecurityLevel.LEVEL_5  # CNSA 2.0 requires Level 5
    elif 'fips' in requirements.compliance:
        level = max(level, SecurityLevel.LEVEL_3, key=lambda x: x.value)
    
    return level

def check_device_compatibility(level: SecurityLevel, 
                                constraints: DeviceConstraints,
                                algorithm: str = 'mlkem') -> dict:
    """Check if device can support the required security level."""
    
    params = MLKEM_PARAMS if algorithm == 'mlkem' else MLDSA_PARAMS
    
    if level not in params:
        # Find closest available level
        available = sorted(params.keys(), key=lambda x: x.value)
        level = min(available, key=lambda x: abs(x.value - level.value))
    
    algo_params = params[level]
    
    result = {
        'compatible': True,
        'algorithm': algo_params['name'],
        'issues': [],
        'recommendations': [],
    }
    
    # Check RAM
    if constraints.ram_kb < algo_params['ram_required_kb']:
        result['compatible'] = False
        result['issues'].append(
            f"Insufficient RAM: {constraints.ram_kb}KB < "
            f"{algo_params['ram_required_kb']}KB required"
        )
        result['recommendations'].append(
            "Consider stack optimization or lower security level"
        )
    
    # Check Flash
    if constraints.flash_kb < algo_params['flash_required_kb']:
        result['compatible'] = False
        result['issues'].append(
            f"Insufficient Flash: {constraints.flash_kb}KB < "
            f"{algo_params['flash_required_kb']}KB required"
        )
    
    # Performance estimate
    if algorithm == 'mlkem' and 'keygen_cycles_m4' in algo_params:
        cycles = algo_params['decaps_cycles_m4']
        time_ms = (cycles / (constraints.cpu_mhz * 1000))
        
        if time_ms > 1000:  # More than 1 second
            result['issues'].append(
                f"Slow performance: ~{time_ms:.0f}ms per operation"
            )
            if constraints.battery_powered:
                result['recommendations'].append(
                    "High energy consumption - consider caching keys"
                )
    
    return result

def select_parameters(requirements: SecurityRequirements,
                      constraints: DeviceConstraints) -> dict:
    """Main parameter selection function."""
    
    min_level = determine_minimum_level(requirements)
    
    # Try to meet minimum level
    kem_result = check_device_compatibility(min_level, constraints, 'mlkem')
    dsa_result = check_device_compatibility(min_level, constraints, 'mldsa')
    
    # If not compatible, find maximum achievable level
    if not kem_result['compatible'] or not dsa_result['compatible']:
        for level in sorted(SecurityLevel, key=lambda x: x.value, reverse=True):
            kem_check = check_device_compatibility(level, constraints, 'mlkem')
            dsa_check = check_device_compatibility(level, constraints, 'mldsa')
            
            if kem_check['compatible'] and dsa_check['compatible']:
                return {
                    'status': 'degraded',
                    'requested_level': min_level.value,
                    'achievable_level': level.value,
                    'kem': kem_check,
                    'dsa': dsa_check,
                    'warning': (
                        f"Device constraints limit security to Level {level.value}. "
                        f"Requested Level {min_level.value} not achievable."
                    ),
                }
        
        return {
            'status': 'incompatible',
            'error': 'No PQC configuration fits device constraints',
            'kem_issues': kem_result['issues'],
            'dsa_issues': dsa_result['issues'],
        }
    
    return {
        'status': 'ok',
        'security_level': min_level.value,
        'kem': kem_result,
        'dsa': dsa_result,
    }

# Example usage
if __name__ == '__main__':
    # Medical device example
    requirements = SecurityRequirements(
        data_sensitivity='critical',
        data_lifetime_years=25,
        threat_actors=['criminal', 'nation_state'],
        compliance=['hipaa', 'fips'],
    )
    
    constraints = DeviceConstraints(
        ram_kb=64,
        flash_kb=256,
        cpu_mhz=120,
        has_hw_aes=True,
        has_hw_sha=True,
        battery_powered=True,
    )
    
    result = select_parameters(requirements, constraints)
    
    print("=== PQC Parameter Selection Result ===")
    print(f"Status: {result['status']}")
    if result['status'] == 'ok':
        print(f"Security Level: {result['security_level']}")
        print(f"KEM: {result['kem']['algorithm']}")
        print(f"DSA: {result['dsa']['algorithm']}")
    else:
        print(f"Warning: {result.get('warning', result.get('error'))}")
\end{lstlisting}

\subsection{Conservative vs. Aggressive Parameter Choices}

The cryptographic community debates appropriate security margins:

\begin{table}[htbp]
\centering
\caption{Parameter Selection Philosophy Comparison}
\label{tab:param-philosophy}
\begin{tabular}{@{}lp{5.5cm}p{5.5cm}@{}}
\toprule
\textbf{Aspect} & \textbf{Conservative} & \textbf{Aggressive} \\
\midrule
Security margin & +20-30\% above estimates & Minimal margin \\
Level choice & Always Level 5 & Minimum required \\
Rationale & Unknown quantum advances, cryptanalysis improvements & Resource efficiency, measured risk \\
Best for & Government, critical infrastructure, long-term secrets & Consumer IoT, short-lived data \\
Risk & Over-provisioning, resource waste & Insufficient security if estimates wrong \\
\bottomrule
\end{tabular}
\end{table}

\warningbox{Recent lattice cryptanalysis improvements (2023-2024) have eroded some security margins. While NIST parameters remain secure, the trend suggests conservative choices are prudent for long-lived deployments.}

\section{Key Management Best Practices}
\label{sec:key-management}

Effective key management is critical for PQC deployments, particularly given the larger key sizes and new operational considerations introduced by post-quantum algorithms.

\subsection{Key Lifecycle Management}

\begin{figure}[htbp]
\centering
\begin{tikzpicture}[
    node distance=2.5cm,
    state/.style={rectangle, draw, rounded corners, minimum width=2.2cm, minimum height=1cm, align=center, fill=blue!10},
    arrow/.style={->, thick, >=stealth}
]
    \node[state] (gen) {Key\\Generation};
    \node[state, right of=gen] (dist) {Key\\Distribution};
    \node[state, right of=dist] (store) {Key\\Storage};
    \node[state, right of=store] (use) {Key\\Usage};
    \node[state, below of=use, yshift=0.5cm] (rotate) {Key\\Rotation};
    \node[state, left of=rotate] (revoke) {Key\\Revocation};
    \node[state, left of=revoke] (destroy) {Key\\Destruction};
    
    \draw[arrow] (gen) -- (dist);
    \draw[arrow] (dist) -- (store);
    \draw[arrow] (store) -- (use);
    \draw[arrow] (use) -- (rotate);
    \draw[arrow] (rotate) -- (revoke);
    \draw[arrow] (revoke) -- (destroy);
    \draw[arrow, dashed] (rotate) to[bend right=30] (store);
\end{tikzpicture}
\caption{PQC Key Lifecycle Stages}
\label{fig:key-lifecycle}
\end{figure}

\subsection{Key Generation Requirements}

PQC key generation demands high-quality randomness and secure execution environments:

\begin{lstlisting}[style=cstyle, caption={Secure PQC Key Generation Framework}]
/*
 * Secure Key Generation Framework for IoT PQC
 * Implements defense-in-depth for key generation
 */

#include <stdint.h>
#include <stdbool.h>
#include <string.h>

/* Key generation context */
typedef struct {
    uint8_t entropy_pool[64];
    uint32_t entropy_bits;
    bool hw_rng_available;
    bool health_check_passed;
    uint32_t generation_counter;
} keygen_context_t;

/* Entropy source types */
typedef enum {
    ENTROPY_HW_TRNG,      /* Hardware TRNG */
    ENTROPY_ADC_NOISE,    /* ADC noise sampling */
    ENTROPY_TIMER_JITTER, /* Timer jitter */
    ENTROPY_RADIO_RSSI,   /* Radio signal noise */
    ENTROPY_EXTERNAL      /* External entropy injection */
} entropy_source_t;

/* Health check for entropy source */
static bool entropy_health_check(const uint8_t *samples, size_t len) {
    /* Repetition count test (NIST SP 800-90B) */
    uint8_t last = samples[0];
    int repeat_count = 1;
    int max_repeat = 1;
    
    for (size_t i = 1; i < len; i++) {
        if (samples[i] == last) {
            repeat_count++;
            if (repeat_count > max_repeat) {
                max_repeat = repeat_count;
            }
        } else {
            last = samples[i];
            repeat_count = 1;
        }
    }
    
    /* Fail if too many repetitions (threshold depends on source) */
    if (max_repeat > 6) {
        return false;
    }
    
    /* Adaptive proportion test */
    int counts[256] = {0};
    for (size_t i = 0; i < len; i++) {
        counts[samples[i]]++;
    }
    
    int max_count = 0;
    for (int i = 0; i < 256; i++) {
        if (counts[i] > max_count) {
            max_count = counts[i];
        }
    }
    
    /* Fail if any value appears too frequently */
    if (max_count > (int)(len * 0.15)) {  /* >15% is suspicious */
        return false;
    }
    
    return true;
}

/* Gather entropy from multiple sources */
static int gather_entropy(keygen_context_t *ctx) {
    uint8_t raw_entropy[256];
    size_t offset = 0;
    
    /* Source 1: Hardware TRNG if available */
    if (ctx->hw_rng_available) {
        hw_trng_read(raw_entropy + offset, 64);
        offset += 64;
    }
    
    /* Source 2: ADC noise */
    for (int i = 0; i < 32; i++) {
        raw_entropy[offset++] = adc_read_noise() & 0xFF;
    }
    
    /* Source 3: Timer jitter */
    for (int i = 0; i < 32; i++) {
        uint32_t t1 = timer_get_cycles();
        volatile int dummy = 0;
        for (int j = 0; j < 100; j++) dummy++;
        uint32_t t2 = timer_get_cycles();
        raw_entropy[offset++] = (t2 - t1) & 0xFF;
    }
    
    /* Health check on raw entropy */
    if (!entropy_health_check(raw_entropy, offset)) {
        return -1;  /* Entropy source failure */
    }
    
    /* Condition entropy using SHAKE256 */
    shake256(ctx->entropy_pool, sizeof(ctx->entropy_pool),
             raw_entropy, offset);
    
    ctx->entropy_bits = 256;  /* Conservative estimate */
    ctx->health_check_passed = true;
    
    secure_zero(raw_entropy, sizeof(raw_entropy));
    return 0;
}

/* Generate ML-KEM keypair with full security measures */
int secure_mlkem_keygen(uint8_t *pk, uint8_t *sk,
                        keygen_context_t *ctx,
                        int security_level) {
    int ret = -1;
    
    /* Step 1: Verify entropy health */
    if (!ctx->health_check_passed) {
        if (gather_entropy(ctx) != 0) {
            return -1;  /* Cannot generate keys without good entropy */
        }
    }
    
    /* Step 2: Derive seed from entropy pool */
    uint8_t seed[64];
    uint8_t counter_bytes[4];
    
    counter_bytes[0] = (ctx->generation_counter >> 24) & 0xFF;
    counter_bytes[1] = (ctx->generation_counter >> 16) & 0xFF;
    counter_bytes[2] = (ctx->generation_counter >> 8) & 0xFF;
    counter_bytes[3] = ctx->generation_counter & 0xFF;
    
    /* seed = SHAKE256(entropy_pool || counter) */
    uint8_t hash_input[68];
    memcpy(hash_input, ctx->entropy_pool, 64);
    memcpy(hash_input + 64, counter_bytes, 4);
    shake256(seed, sizeof(seed), hash_input, sizeof(hash_input));
    
    /* Step 3: Generate keypair */
    switch (security_level) {
        case 1:
            ret = mlkem512_keypair_seed(pk, sk, seed);
            break;
        case 3:
            ret = mlkem768_keypair_seed(pk, sk, seed);
            break;
        case 5:
            ret = mlkem1024_keypair_seed(pk, sk, seed);
            break;
        default:
            ret = -1;
    }
    
    /* Step 4: Verify keypair (encaps/decaps test) */
    if (ret == 0) {
        uint8_t ct_test[MLKEM_MAX_CT_BYTES];
        uint8_t ss1[32], ss2[32];
        
        mlkem_encaps(ct_test, ss1, pk, security_level);
        mlkem_decaps(ss2, ct_test, sk, security_level);
        
        if (memcmp(ss1, ss2, 32) != 0) {
            ret = -1;  /* Keypair verification failed */
        }
        
        secure_zero(ct_test, sizeof(ct_test));
        secure_zero(ss1, sizeof(ss1));
        secure_zero(ss2, sizeof(ss2));
    }
    
    /* Step 5: Update counter and refresh entropy */
    ctx->generation_counter++;
    if (ctx->generation_counter % 100 == 0) {
        gather_entropy(ctx);  /* Periodic entropy refresh */
    }
    
    /* Cleanup */
    secure_zero(seed, sizeof(seed));
    secure_zero(hash_input, sizeof(hash_input));
    
    return ret;
}
\end{lstlisting}

\subsection{Secure Key Storage}

IoT devices require careful consideration for key storage given physical access threats:

\begin{table}[htbp]
\centering
\caption{Key Storage Options for IoT Devices}
\label{tab:key-storage}
\begin{tabular}{@{}llll@{}}
\toprule
\textbf{Storage Type} & \textbf{Security} & \textbf{Cost} & \textbf{PQC Suitability} \\
\midrule
Plain Flash & Low & \$ & Not recommended \\
Encrypted Flash & Medium & \$ & Acceptable for public keys \\
Secure Element (SE) & High & \$\$ & Limited by SE memory \\
Hardware Security Module & Very High & \$\$\$ & Best for gateways \\
ARM TrustZone & Medium-High & \$ & Good for Cortex-M33+ \\
PUF-derived keys & High & \$\$ & Excellent for IoT \\
\bottomrule
\end{tabular}
\end{table}

\begin{lstlisting}[style=cstyle, caption={PUF-Based Key Protection for PQC}]
/*
 * Physically Unclonable Function (PUF) based key wrapping
 * Protects PQC secret keys using device-unique secrets
 */

#include <stdint.h>
#include <string.h>

#define PUF_RESPONSE_SIZE 32
#define KEY_WRAP_OVERHEAD 16  /* AES-GCM tag */

/* PUF interface (hardware-specific) */
extern int puf_generate_response(uint8_t *response, 
                                  const uint8_t *challenge,
                                  size_t challenge_len);
extern int puf_get_helper_data(uint8_t *helper_data,
                               size_t *helper_len);
extern int puf_reconstruct(uint8_t *response,
                           const uint8_t *helper_data,
                           size_t helper_len);

/* Key wrapping structure */
typedef struct {
    uint8_t wrapped_key[MLKEM_MAX_SK_BYTES + KEY_WRAP_OVERHEAD];
    size_t wrapped_len;
    uint8_t challenge[32];
    uint8_t helper_data[256];
    size_t helper_len;
    uint8_t nonce[12];
} puf_wrapped_key_t;

/* Wrap a PQC secret key using PUF */
int puf_wrap_key(puf_wrapped_key_t *wrapped,
                 const uint8_t *sk, size_t sk_len) {
    uint8_t puf_response[PUF_RESPONSE_SIZE];
    uint8_t kek[32];  /* Key Encryption Key */
    int ret = -1;
    
    /* Generate random challenge */
    if (get_random_bytes(wrapped->challenge, 32) != 0) {
        return -1;
    }
    
    /* Get PUF response */
    if (puf_generate_response(puf_response, wrapped->challenge, 32) != 0) {
        goto cleanup;
    }
    
    /* Get helper data for reconstruction */
    if (puf_get_helper_data(wrapped->helper_data, &wrapped->helper_len) != 0) {
        goto cleanup;
    }
    
    /* Derive KEK from PUF response */
    shake256(kek, sizeof(kek), puf_response, PUF_RESPONSE_SIZE);
    
    /* Generate nonce for AES-GCM */
    if (get_random_bytes(wrapped->nonce, 12) != 0) {
        goto cleanup;
    }
    
    /* Wrap key using AES-256-GCM */
    wrapped->wrapped_len = sk_len + KEY_WRAP_OVERHEAD;
    if (aes_gcm_encrypt(wrapped->wrapped_key,
                        sk, sk_len,
                        NULL, 0,  /* No AAD */
                        kek,
                        wrapped->nonce) != 0) {
        goto cleanup;
    }
    
    ret = 0;
    
cleanup:
    secure_zero(puf_response, sizeof(puf_response));
    secure_zero(kek, sizeof(kek));
    return ret;
}

/* Unwrap a PQC secret key using PUF */
int puf_unwrap_key(uint8_t *sk, size_t *sk_len,
                   const puf_wrapped_key_t *wrapped) {
    uint8_t puf_response[PUF_RESPONSE_SIZE];
    uint8_t kek[32];
    int ret = -1;
    
    /* Reconstruct PUF response using helper data */
    if (puf_reconstruct(puf_response, 
                        wrapped->helper_data, 
                        wrapped->helper_len) != 0) {
        return -1;
    }
    
    /* Re-derive KEK */
    shake256(kek, sizeof(kek), puf_response, PUF_RESPONSE_SIZE);
    
    /* Unwrap key */
    *sk_len = wrapped->wrapped_len - KEY_WRAP_OVERHEAD;
    if (aes_gcm_decrypt(sk,
                        wrapped->wrapped_key, wrapped->wrapped_len,
                        NULL, 0,
                        kek,
                        wrapped->nonce) != 0) {
        /* Authentication failed - key may be tampered */
        secure_zero(sk, *sk_len);
        *sk_len = 0;
        goto cleanup;
    }
    
    ret = 0;
    
cleanup:
    secure_zero(puf_response, sizeof(puf_response));
    secure_zero(kek, sizeof(kek));
    return ret;
}
\end{lstlisting}

\subsection{Key Rotation Strategies}

PQC key rotation must balance security with the overhead of larger keys:

\begin{lstlisting}[style=cstyle, caption={Automated Key Rotation Manager}]
/*
 * Key Rotation Manager for PQC IoT Devices
 * Handles automated key lifecycle management
 */

#include <stdint.h>
#include <stdbool.h>
#include <time.h>

/* Key metadata */
typedef struct {
    uint32_t key_id;
    uint32_t creation_time;
    uint32_t expiration_time;
    uint32_t usage_count;
    uint32_t max_usage;
    uint8_t algorithm;       /* MLKEM512=1, MLKEM768=2, etc. */
    uint8_t status;          /* ACTIVE, DEPRECATED, REVOKED */
    uint8_t pk_hash[32];     /* SHA-256 of public key */
} key_metadata_t;

typedef enum {
    KEY_STATUS_ACTIVE = 0,
    KEY_STATUS_DEPRECATED = 1,  /* Still valid but being phased out */
    KEY_STATUS_REVOKED = 2,
    KEY_STATUS_EXPIRED = 3
} key_status_t;

/* Rotation policy */
typedef struct {
    uint32_t max_age_seconds;      /* Maximum key lifetime */
    uint32_t max_operations;       /* Maximum encaps/decaps operations */
    uint32_t rotation_overlap;     /* Overlap period for smooth transition */
    bool rotate_on_compromise;     /* Immediate rotation if compromise detected */
} rotation_policy_t;

/* Default rotation policies by application */
static const rotation_policy_t POLICY_CONSUMER = {
    .max_age_seconds = 365 * 24 * 3600,  /* 1 year */
    .max_operations = 1000000,
    .rotation_overlap = 7 * 24 * 3600,   /* 1 week */
    .rotate_on_compromise = true
};

static const rotation_policy_t POLICY_INDUSTRIAL = {
    .max_age_seconds = 90 * 24 * 3600,   /* 90 days */
    .max_operations = 100000,
    .rotation_overlap = 24 * 3600,       /* 1 day */
    .rotate_on_compromise = true
};

static const rotation_policy_t POLICY_CRITICAL = {
    .max_age_seconds = 30 * 24 * 3600,   /* 30 days */
    .max_operations = 10000,
    .rotation_overlap = 4 * 3600,        /* 4 hours */
    .rotate_on_compromise = true
};

/* Key rotation manager */
typedef struct {
    key_metadata_t current_key;
    key_metadata_t next_key;
    rotation_policy_t policy;
    bool rotation_pending;
    uint32_t last_check_time;
} key_rotation_manager_t;

/* Check if rotation is needed */
bool rotation_needed(key_rotation_manager_t *mgr, uint32_t current_time) {
    key_metadata_t *key = &mgr->current_key;
    
    /* Check expiration */
    if (current_time >= key->expiration_time) {
        return true;
    }
    
    /* Check usage count */
    if (key->usage_count >= mgr->policy.max_operations) {
        return true;
    }
    
    /* Check age */
    uint32_t age = current_time - key->creation_time;
    if (age >= mgr->policy.max_age_seconds) {
        return true;
    }
    
    /* Check if approaching expiration (start overlap period) */
    uint32_t time_remaining = key->expiration_time - current_time;
    if (time_remaining <= mgr->policy.rotation_overlap && 
        !mgr->rotation_pending) {
        return true;  /* Start generating next key */
    }
    
    return false;
}

/* Initiate key rotation */
int initiate_rotation(key_rotation_manager_t *mgr,
                      keygen_context_t *keygen_ctx,
                      uint32_t current_time) {
    if (mgr->rotation_pending) {
        return 0;  /* Already in progress */
    }
    
    /* Generate new keypair */
    uint8_t new_pk[MLKEM_MAX_PK_BYTES];
    uint8_t new_sk[MLKEM_MAX_SK_BYTES];
    
    int level = mgr->current_key.algorithm;
    if (secure_mlkem_keygen(new_pk, new_sk, keygen_ctx, level) != 0) {
        return -1;
    }
    
    /* Store new key (implementation-specific) */
    uint32_t new_key_id = mgr->current_key.key_id + 1;
    if (store_keypair(new_key_id, new_pk, new_sk, level) != 0) {
        secure_zero(new_sk, sizeof(new_sk));
        return -1;
    }
    
    /* Update next key metadata */
    mgr->next_key.key_id = new_key_id;
    mgr->next_key.creation_time = current_time;
    mgr->next_key.expiration_time = current_time + mgr->policy.max_age_seconds;
    mgr->next_key.usage_count = 0;
    mgr->next_key.max_usage = mgr->policy.max_operations;
    mgr->next_key.algorithm = level;
    mgr->next_key.status = KEY_STATUS_ACTIVE;
    sha256(mgr->next_key.pk_hash, new_pk, mlkem_pk_size(level));
    
    mgr->rotation_pending = true;
    
    /* Secure cleanup */
    secure_zero(new_sk, sizeof(new_sk));
    
    return 0;
}

/* Complete key rotation */
int complete_rotation(key_rotation_manager_t *mgr) {
    if (!mgr->rotation_pending) {
        return -1;
    }
    
    /* Deprecate current key */
    mgr->current_key.status = KEY_STATUS_DEPRECATED;
    update_key_status(mgr->current_key.key_id, KEY_STATUS_DEPRECATED);
    
    /* Promote next key to current */
    memcpy(&mgr->current_key, &mgr->next_key, sizeof(key_metadata_t));
    memset(&mgr->next_key, 0, sizeof(key_metadata_t));
    
    mgr->rotation_pending = false;
    
    /* Schedule deletion of old key after grace period */
    schedule_key_deletion(mgr->current_key.key_id - 1,
                          mgr->policy.rotation_overlap);
    
    return 0;
}

/* Emergency revocation */
int emergency_revoke(key_rotation_manager_t *mgr,
                     keygen_context_t *keygen_ctx,
                     uint32_t current_time) {
    /* Immediately revoke current key */
    mgr->current_key.status = KEY_STATUS_REVOKED;
    update_key_status(mgr->current_key.key_id, KEY_STATUS_REVOKED);
    
    /* Generate and activate new key immediately */
    if (initiate_rotation(mgr, keygen_ctx, current_time) != 0) {
        return -1;
    }
    
    /* Skip overlap - immediate promotion */
    return complete_rotation(mgr);
}
\end{lstlisting}

\subsection{Key Distribution for IoT Networks}

Distributing PQC keys across IoT networks presents unique challenges:

\begin{table}[htbp]
\centering
\caption{Key Distribution Methods for PQC IoT}
\label{tab:key-distribution}
\begin{tabular}{@{}lp{4cm}p{4cm}l@{}}
\toprule
\textbf{Method} & \textbf{Advantages} & \textbf{Disadvantages} & \textbf{Use Case} \\
\midrule
Pre-provisioning & Simple, no runtime overhead & Inflexible, no rotation & Disposable sensors \\
Online KEM & Dynamic, supports rotation & Requires connectivity & Smart home \\
Hierarchical & Scalable & Complex PKI & Industrial IoT \\
Group keys & Efficient multicast & Compromise affects group & Sensor networks \\
Hybrid (PSK+KEM) & Quantum-safe bootstrap & Key management burden & Critical systems \\
\bottomrule
\end{tabular}
\end{table}

\section{Secure Boot with Post-Quantum Signatures}
\label{sec:secure-boot}

Secure boot ensures that only authenticated firmware executes on IoT devices. Transitioning to post-quantum signatures introduces new challenges related to signature sizes, verification times, and boot latency requirements.

\subsection{Secure Boot Architecture}

\begin{figure}[htbp]
\centering
\begin{tikzpicture}[
    node distance=1.8cm,
    block/.style={rectangle, draw, minimum width=3cm, minimum height=1cm, align=center, fill=blue!10},
    trust/.style={rectangle, draw, minimum width=3cm, minimum height=1cm, align=center, fill=green!20},
    arrow/.style={->, thick, >=stealth}
]
    % Boot stages
    \node[trust] (rom) {ROM Bootloader\\(Immutable Root of Trust)};
    \node[block, below of=rom] (stage1) {Stage 1 Bootloader\\(Signed)};
    \node[block, below of=stage1] (stage2) {Stage 2 Bootloader\\(Signed)};
    \node[block, below of=stage2] (kernel) {OS/RTOS Kernel\\(Signed)};
    \node[block, below of=kernel] (app) {Application\\(Signed)};
    
    % Verification arrows
    \draw[arrow] (rom) -- node[right, font=\small] {Verify} (stage1);
    \draw[arrow] (stage1) -- node[right, font=\small] {Verify} (stage2);
    \draw[arrow] (stage2) -- node[right, font=\small] {Verify} (kernel);
    \draw[arrow] (kernel) -- node[right, font=\small] {Verify} (app);
    
    % Public keys
    \node[right of=rom, xshift=3cm, font=\small] (pk0) {PK\textsubscript{root} (in ROM)};
    \node[right of=stage1, xshift=3cm, font=\small] (pk1) {PK\textsubscript{stage1}};
    \node[right of=stage2, xshift=3cm, font=\small] (pk2) {PK\textsubscript{stage2}};
    \node[right of=kernel, xshift=3cm, font=\small] (pk3) {PK\textsubscript{kernel}};
    
    \draw[dashed, ->] (pk0) -- (rom);
    \draw[dashed, ->] (pk1) -- (stage1);
    \draw[dashed, ->] (pk2) -- (stage2);
    \draw[dashed, ->] (pk3) -- (kernel);
\end{tikzpicture}
\caption{Multi-Stage Secure Boot Chain with PQC Signatures}
\label{fig:secure-boot-chain}
\end{figure}

\subsection{Algorithm Selection for Secure Boot}

Secure boot has specific requirements that influence PQC algorithm selection:

\begin{table}[htbp]
\centering
\caption{PQC Signature Algorithms for Secure Boot}
\label{tab:secureboot-algorithms}
\begin{tabular}{@{}llllll@{}}
\toprule
\textbf{Algorithm} & \textbf{PK Size} & \textbf{Sig Size} & \textbf{Verify (M4)} & \textbf{ROM Impact} & \textbf{Rating} \\
\midrule
ML-DSA-44 & 1,312 B & 2,420 B & 0.8 ms & Medium & Good \\
ML-DSA-65 & 1,952 B & 3,293 B & 1.2 ms & Medium & Good \\
Falcon-512 & 897 B & 666 B & 0.3 ms & High\textsuperscript{*} & Best \\
Falcon-1024 & 1,793 B & 1,280 B & 0.6 ms & High\textsuperscript{*} & Good \\
SLH-DSA-128s & 32 B & 7,856 B & 2.1 ms & Low & Limited \\
SLH-DSA-128f & 32 B & 17,088 B & 0.4 ms & Low & Good \\
\bottomrule
\end{tabular}
\begin{tablenotes}
\small
\item \textsuperscript{*} Falcon requires floating-point or complex fixed-point code in ROM
\end{tablenotes}
\end{table}

\infobox{For secure boot, \textbf{Falcon-512} offers the best combination of small signatures and fast verification. However, its implementation complexity may favor \textbf{ML-DSA-44} for simpler deployments. \textbf{SLH-DSA-128f} is ideal when ROM space is extremely limited (only 32-byte public key in ROM).}

\subsection{PQC Secure Boot Implementation}

\begin{lstlisting}[style=cstyle, caption={Post-Quantum Secure Boot Implementation}]
/*
 * Post-Quantum Secure Boot for IoT Devices
 * Supports ML-DSA, Falcon, and SLH-DSA
 */

#include <stdint.h>
#include <stdbool.h>
#include <string.h>

/* Boot stage definitions */
typedef enum {
    BOOT_STAGE_ROM = 0,
    BOOT_STAGE_BL1 = 1,
    BOOT_STAGE_BL2 = 2,
    BOOT_STAGE_KERNEL = 3,
    BOOT_STAGE_APP = 4
} boot_stage_t;

/* Signature algorithm identifiers */
typedef enum {
    SIG_ALG_MLDSA44 = 1,
    SIG_ALG_MLDSA65 = 2,
    SIG_ALG_MLDSA87 = 3,
    SIG_ALG_FALCON512 = 4,
    SIG_ALG_FALCON1024 = 5,
    SIG_ALG_SLHDSA_SHA2_128F = 6,
    SIG_ALG_SLHDSA_SHA2_128S = 7,
    /* Hybrid options */
    SIG_ALG_HYBRID_ECDSA_MLDSA = 0x80,
    SIG_ALG_HYBRID_ED25519_FALCON = 0x81
} sig_algorithm_t;

/* Image header structure */
typedef struct __attribute__((packed)) {
    uint32_t magic;              /* 0x50514654 = "PQFT" */
    uint32_t header_version;     /* Header format version */
    uint32_t image_size;         /* Size of image (excluding header) */
    uint32_t load_address;       /* Where to load the image */
    uint32_t entry_point;        /* Execution entry point */
    uint8_t  algorithm;          /* Signature algorithm ID */
    uint8_t  security_level;     /* NIST security level (1-5) */
    uint16_t pk_size;            /* Public key size in bytes */
    uint16_t sig_size;           /* Signature size in bytes */
    uint16_t reserved;
    uint8_t  image_hash[64];     /* SHA-512 hash of image */
    uint8_t  pk_hash[32];        /* SHA-256 hash of next stage's PK */
    uint32_t version;            /* Firmware version (anti-rollback) */
    uint32_t build_timestamp;    /* Build time for audit */
    /* Followed by: signature, then public key for next stage */
} pqc_image_header_t;

#define PQC_IMAGE_MAGIC 0x50514654

/* Root public key stored in ROM (example: ML-DSA-44) */
extern const uint8_t ROM_ROOT_PUBLIC_KEY[];
extern const uint16_t ROM_ROOT_PUBLIC_KEY_SIZE;
extern const uint8_t ROM_ROOT_ALGORITHM;

/* Anti-rollback counter in secure storage */
extern uint32_t secure_storage_read_rollback_counter(boot_stage_t stage);
extern int secure_storage_update_rollback_counter(boot_stage_t stage, 
                                                   uint32_t version);

/* Signature verification dispatcher */
static int verify_signature(const uint8_t *message, size_t msg_len,
                           const uint8_t *signature, size_t sig_len,
                           const uint8_t *public_key, size_t pk_len,
                           sig_algorithm_t algorithm) {
    switch (algorithm) {
        case SIG_ALG_MLDSA44:
            return mldsa44_verify(signature, sig_len, 
                                  message, msg_len, public_key);
        
        case SIG_ALG_MLDSA65:
            return mldsa65_verify(signature, sig_len,
                                  message, msg_len, public_key);
        
        case SIG_ALG_MLDSA87:
            return mldsa87_verify(signature, sig_len,
                                  message, msg_len, public_key);
        
        case SIG_ALG_FALCON512:
            return falcon512_verify(signature, sig_len,
                                    message, msg_len, public_key);
        
        case SIG_ALG_FALCON1024:
            return falcon1024_verify(signature, sig_len,
                                     message, msg_len, public_key);
        
        case SIG_ALG_SLHDSA_SHA2_128F:
            return slhdsa_sha2_128f_verify(signature, sig_len,
                                           message, msg_len, public_key);
        
        case SIG_ALG_HYBRID_ECDSA_MLDSA:
            return verify_hybrid_ecdsa_mldsa(message, msg_len,
                                             signature, sig_len,
                                             public_key, pk_len);
        
        default:
            return -1;  /* Unknown algorithm */
    }
}

/* Verify hybrid signature (both must pass) */
static int verify_hybrid_ecdsa_mldsa(const uint8_t *msg, size_t msg_len,
                                      const uint8_t *sig, size_t sig_len,
                                      const uint8_t *pk, size_t pk_len) {
    /* Hybrid signature format:
     * [ECDSA sig (64 bytes)] [ML-DSA sig (2420 bytes)]
     * Hybrid public key format:
     * [ECDSA pk (64 bytes)] [ML-DSA pk (1312 bytes)]
     */
    
    const uint8_t *ecdsa_sig = sig;
    const uint8_t *mldsa_sig = sig + 64;
    const uint8_t *ecdsa_pk = pk;
    const uint8_t *mldsa_pk = pk + 64;
    
    /* Both signatures must verify */
    int ecdsa_result = ecdsa_p256_verify(ecdsa_sig, 64, msg, msg_len, ecdsa_pk);
    int mldsa_result = mldsa44_verify(mldsa_sig, 2420, msg, msg_len, mldsa_pk);
    
    /* Constant-time AND of results */
    return (ecdsa_result | mldsa_result);  /* 0 only if both are 0 */
}

/* Main secure boot verification function */
typedef enum {
    BOOT_OK = 0,
    BOOT_ERR_MAGIC = -1,
    BOOT_ERR_HASH = -2,
    BOOT_ERR_SIGNATURE = -3,
    BOOT_ERR_ROLLBACK = -4,
    BOOT_ERR_ALGORITHM = -5,
    BOOT_ERR_SIZE = -6
} boot_result_t;

boot_result_t verify_boot_image(const uint8_t *image_base,
                                const uint8_t *trusted_pk,
                                size_t trusted_pk_size,
                                sig_algorithm_t trusted_alg,
                                boot_stage_t stage) {
    const pqc_image_header_t *header = (const pqc_image_header_t *)image_base;
    
    /* Step 1: Validate magic number */
    if (header->magic != PQC_IMAGE_MAGIC) {
        return BOOT_ERR_MAGIC;
    }
    
    /* Step 2: Validate algorithm matches expected */
    if (header->algorithm != trusted_alg) {
        return BOOT_ERR_ALGORITHM;
    }
    
    /* Step 3: Check anti-rollback */
    uint32_t stored_version = secure_storage_read_rollback_counter(stage);
    if (header->version < stored_version) {
        return BOOT_ERR_ROLLBACK;
    }
    
    /* Step 4: Compute hash of image */
    const uint8_t *image_data = image_base + sizeof(pqc_image_header_t) 
                                + header->sig_size + header->pk_size;
    uint8_t computed_hash[64];
    sha512(computed_hash, image_data, header->image_size);
    
    /* Step 5: Verify hash matches header */
    if (secure_memcmp(computed_hash, header->image_hash, 64) != 0) {
        return BOOT_ERR_HASH;
    }
    
    /* Step 6: Verify signature over header (which includes hash) */
    const uint8_t *signature = image_base + sizeof(pqc_image_header_t);
    
    /* Sign header up to (but not including) signature */
    int sig_result = verify_signature(
        (const uint8_t *)header,
        offsetof(pqc_image_header_t, image_hash) + 64 + 32,  /* Through pk_hash */
        signature, header->sig_size,
        trusted_pk, trusted_pk_size,
        (sig_algorithm_t)header->algorithm
    );
    
    if (sig_result != 0) {
        return BOOT_ERR_SIGNATURE;
    }
    
    /* Step 7: Update rollback counter if version increased */
    if (header->version > stored_version) {
        secure_storage_update_rollback_counter(stage, header->version);
    }
    
    return BOOT_OK;
}

/* Complete boot chain verification */
boot_result_t secure_boot_chain(void) {
    boot_result_t result;
    
    /* Stage 1: ROM verifies BL1 using root key */
    const uint8_t *bl1_base = (const uint8_t *)BL1_LOAD_ADDRESS;
    result = verify_boot_image(bl1_base, 
                               ROM_ROOT_PUBLIC_KEY,
                               ROM_ROOT_PUBLIC_KEY_SIZE,
                               (sig_algorithm_t)ROM_ROOT_ALGORITHM,
                               BOOT_STAGE_BL1);
    if (result != BOOT_OK) {
        boot_failure_handler(BOOT_STAGE_BL1, result);
        return result;
    }
    
    /* Extract BL1's public key for next stage */
    const pqc_image_header_t *bl1_hdr = (const pqc_image_header_t *)bl1_base;
    const uint8_t *bl1_pk = bl1_base + sizeof(pqc_image_header_t) 
                            + bl1_hdr->sig_size;
    
    /* Stage 2: BL1 verifies BL2 */
    const uint8_t *bl2_base = (const uint8_t *)BL2_LOAD_ADDRESS;
    result = verify_boot_image(bl2_base,
                               bl1_pk, bl1_hdr->pk_size,
                               (sig_algorithm_t)bl1_hdr->algorithm,
                               BOOT_STAGE_BL2);
    if (result != BOOT_OK) {
        boot_failure_handler(BOOT_STAGE_BL2, result);
        return result;
    }
    
    /* Continue chain for kernel and application... */
    /* (Similar pattern) */
    
    return BOOT_OK;
}

/* Boot failure handler */
void boot_failure_handler(boot_stage_t stage, boot_result_t error) {
    /* Log failure securely */
    secure_log_boot_failure(stage, error);
    
    /* Options based on policy:
     * 1. Halt system (most secure)
     * 2. Boot recovery image
     * 3. Revert to known-good image (A/B scheme)
     */
    
    #if defined(BOOT_POLICY_HALT)
        while (1) {
            /* Halt - device bricked until recovery */
            __WFI();
        }
    #elif defined(BOOT_POLICY_RECOVERY)
        boot_recovery_image();
    #elif defined(BOOT_POLICY_AB_FALLBACK)
        boot_alternate_slot();
    #endif
}
\end{lstlisting}

\subsection{Boot Time Analysis}

Boot time is critical for IoT devices. The following analysis shows PQC impact:

\begin{table}[htbp]
\centering
\caption{Secure Boot Time Breakdown (Cortex-M4 @ 168 MHz)}
\label{tab:boot-time}
\begin{tabular}{@{}lrrrrr@{}}
\toprule
\textbf{Operation} & \textbf{Classical} & \textbf{ML-DSA-44} & \textbf{Falcon-512} & \textbf{SLH-DSA-128f} & \textbf{Hybrid} \\
\midrule
Hash 64KB image & 12 ms & 12 ms & 12 ms & 12 ms & 12 ms \\
Load signature & 0.1 ms & 0.4 ms & 0.1 ms & 2.8 ms & 0.5 ms \\
Load public key & 0.1 ms & 0.2 ms & 0.1 ms & 0.01 ms & 0.3 ms \\
Verify signature & 0.3 ms & 0.8 ms & 0.3 ms & 0.4 ms & 1.1 ms \\
\midrule
\textbf{Total per stage} & \textbf{12.5 ms} & \textbf{13.4 ms} & \textbf{12.5 ms} & \textbf{15.2 ms} & \textbf{13.9 ms} \\
\textbf{4-stage chain} & \textbf{50 ms} & \textbf{54 ms} & \textbf{50 ms} & \textbf{61 ms} & \textbf{56 ms} \\
\bottomrule
\end{tabular}
\end{table}

\infobox{PQC secure boot adds approximately \textbf{4-11 ms} per boot stage compared to classical ECDSA. For a 4-stage boot chain, total overhead is \textbf{16-44 ms}---acceptable for most IoT applications where boot time requirements are typically $<$1 second.}

\subsection{Hardware Root of Trust Considerations}

\begin{lstlisting}[style=cstyle, caption={Hardware Root of Trust Integration}]
/*
 * Hardware Root of Trust (HRoT) Integration for PQC
 * Example for ARM TrustZone-M based devices
 */

#include <stdint.h>
#include <arm_cmse.h>  /* ARM CMSE for TrustZone */

/* Secure region definitions */
#define SECURE_ROM_BASE     0x10000000
#define SECURE_ROM_SIZE     0x00010000  /* 64 KB secure ROM */
#define SECURE_RAM_BASE     0x30000000
#define SECURE_RAM_SIZE     0x00008000  /* 32 KB secure RAM */

/* Root public key in secure ROM (One-Time Programmable or ROM) */
__attribute__((section(".secure_rom.root_pk")))
const uint8_t root_public_key_mldsa44[1312] = {
    /* ML-DSA-44 public key programmed at manufacturing */
    /* This cannot be modified after device provisioning */
};

/* Secure boot state - only accessible from secure world */
typedef struct {
    bool boot_verified;
    boot_stage_t current_stage;
    uint8_t chain_hash[32];     /* Rolling hash of boot chain */
    uint32_t boot_flags;
} secure_boot_state_t;

__attribute__((section(".secure_ram")))
static secure_boot_state_t g_boot_state;

/* Secure function - callable from non-secure world */
__attribute__((cmse_nonsecure_entry))
bool secure_get_boot_status(void) {
    return g_boot_state.boot_verified;
}

/* Secure function - get attestation token */
__attribute__((cmse_nonsecure_entry))
int secure_get_attestation(uint8_t *token, size_t *token_len) {
    if (!g_boot_state.boot_verified) {
        return -1;  /* Cannot attest unverified boot */
    }
    
    /* Generate attestation token including:
     * - Boot chain hash
     * - Device ID
     * - Firmware versions
     * - Security configuration
     */
    return generate_attestation_token(token, token_len, &g_boot_state);
}

/* Secure boot verification - runs in secure world only */
__attribute__((section(".secure_text")))
boot_result_t secure_verify_image(const uint8_t *image, size_t image_size) {
    /* Ensure we're running in secure state */
    if (!__get_CONTROL() & 0x1) {
        /* Not in secure state - should not happen */
        return BOOT_ERR_SECURITY;
    }
    
    /* Perform verification using secure ROM key */
    return verify_boot_image(image, 
                             root_public_key_mldsa44,
                             sizeof(root_public_key_mldsa44),
                             SIG_ALG_MLDSA44,
                             g_boot_state.current_stage);
}

/* Memory Protection Unit configuration for boot stages */
void configure_mpu_for_boot_stage(boot_stage_t stage) {
    /* Disable MPU during reconfiguration */
    MPU->CTRL = 0;
    
    /* Region 0: Secure ROM - RO, executable */
    MPU->RNR = 0;
    MPU->RBAR = SECURE_ROM_BASE | MPU_RBAR_VALID_Msk | 0;
    MPU->RASR = MPU_RASR_ENABLE_Msk |
                (0x0F << MPU_RASR_SIZE_Pos) |  /* 64 KB */
                (0x06 << MPU_RASR_AP_Pos) |    /* RO */
                MPU_RASR_C_Msk;
    
    /* Region 1: Secure RAM - RW, no execute */
    MPU->RNR = 1;
    MPU->RBAR = SECURE_RAM_BASE | MPU_RBAR_VALID_Msk | 1;
    MPU->RASR = MPU_RASR_ENABLE_Msk |
                (0x0E << MPU_RASR_SIZE_Pos) |  /* 32 KB */
                (0x03 << MPU_RASR_AP_Pos) |    /* RW */
                MPU_RASR_XN_Msk |              /* No execute */
                MPU_RASR_C_Msk;
    
    /* Additional regions based on boot stage */
    switch (stage) {
        case BOOT_STAGE_BL1:
            /* BL1 has access to more peripherals */
            configure_bl1_mpu_regions();
            break;
        case BOOT_STAGE_KERNEL:
            /* Lock down further before kernel */
            configure_kernel_mpu_regions();
            break;
        default:
            break;
    }
    
    /* Enable MPU with default memory map for privileged */
    MPU->CTRL = MPU_CTRL_ENABLE_Msk | MPU_CTRL_PRIVDEFENA_Msk;
    __DSB();
    __ISB();
}
\end{lstlisting}

\section{Secure Firmware Updates with PQC}
\label{sec:firmware-updates}

Over-the-air (OTA) firmware updates are essential for maintaining IoT device security throughout their lifecycle. Post-quantum signatures ensure that firmware authenticity remains protected against future quantum attacks, while the larger signature sizes introduce new challenges for bandwidth-constrained networks.

\subsection{OTA Update Architecture}

\begin{figure}[htbp]
\centering
\begin{tikzpicture}[
    node distance=2cm,
    server/.style={rectangle, draw, minimum width=2.5cm, minimum height=1.2cm, align=center, fill=orange!20},
    device/.style={rectangle, draw, minimum width=2.5cm, minimum height=1.2cm, align=center, fill=blue!10},
    storage/.style={cylinder, draw, shape border rotate=90, minimum width=1.5cm, minimum height=1.2cm, fill=green!10},
    arrow/.style={->, thick, >=stealth}
]
    % Server side
    \node[server] (build) {Build Server};
    \node[server, right of=build, xshift=2cm] (sign) {Signing Server\\(HSM)};
    \node[storage, right of=sign, xshift=2cm] (cdn) {CDN/\\Storage};
    
    % Device side
    \node[device, below of=cdn, yshift=-2cm] (agent) {Update Agent};
    \node[storage, left of=agent, xshift=-1.5cm] (slota) {Slot A\\(Active)};
    \node[storage, right of=agent, xshift=1.5cm] (slotb) {Slot B\\(Staging)};
    
    % Connections
    \draw[arrow] (build) -- node[above, font=\small] {Image} (sign);
    \draw[arrow] (sign) -- node[above, font=\small] {Signed} (cdn);
    \draw[arrow] (cdn) -- node[right, font=\small] {Download} (agent);
    \draw[arrow] (agent) -- (slotb);
    \draw[arrow, dashed] (slota) -- (agent);
    
    % Labels
    \node[above of=build, yshift=-0.5cm, font=\small\bfseries] {Cloud Infrastructure};
    \node[below of=agent, yshift=0.5cm, font=\small\bfseries] {IoT Device};
\end{tikzpicture}
\caption{PQC-Secured OTA Update Architecture}
\label{fig:ota-architecture}
\end{figure}

\subsection{Update Package Format}

\begin{lstlisting}[style=cstyle, caption={PQC Firmware Update Package Structure}]
/*
 * Post-Quantum Secured Firmware Update Package
 * Supports delta updates and compression
 */

#include <stdint.h>

/* Update package magic numbers */
#define UPDATE_MAGIC_FULL   0x50514F54  /* "PQOT" - Full image */
#define UPDATE_MAGIC_DELTA  0x50514454  /* "PQDT" - Delta update */

/* Compression algorithms */
typedef enum {
    COMPRESS_NONE = 0,
    COMPRESS_LZ4 = 1,
    COMPRESS_ZSTD = 2,
    COMPRESS_LZMA = 3
} compression_algo_t;

/* Update package header */
typedef struct __attribute__((packed)) {
    uint32_t magic;                  /* Package type identifier */
    uint32_t header_version;         /* Header format version */
    uint32_t package_size;           /* Total package size */
    uint32_t payload_size;           /* Compressed payload size */
    uint32_t uncompressed_size;      /* Original image size */
    
    /* Target information */
    uint32_t target_hw_id;           /* Hardware ID this update is for */
    uint32_t min_version;            /* Minimum current version required */
    uint32_t new_version;            /* Version after update */
    
    /* For delta updates */
    uint32_t base_version;           /* Base version for delta */
    uint8_t  base_hash[32];          /* SHA-256 of base image */
    
    /* Cryptographic parameters */
    uint8_t  sig_algorithm;          /* Signature algorithm ID */
    uint8_t  compression;            /* Compression algorithm */
    uint16_t sig_size;               /* Signature size in bytes */
    uint16_t pk_size;                /* Public key size (if included) */
    uint16_t manifest_size;          /* Manifest size */
    
    /* Hashes */
    uint8_t  payload_hash[32];       /* SHA-256 of compressed payload */
    uint8_t  image_hash[32];         /* SHA-256 of final uncompressed image */
    
    /* Timestamps */
    uint64_t created_timestamp;      /* Package creation time */
    uint64_t expiry_timestamp;       /* Package expiry (0 = no expiry) */
    
    /* Followed by:
     * 1. Manifest (JSON/CBOR with detailed metadata)
     * 2. Signature over (header + manifest)
     * 3. Optional: Public key for next update
     * 4. Compressed/delta payload
     */
} pqc_update_header_t;

/* Manifest structure (CBOR encoded) */
typedef struct {
    char device_class[64];           /* Device class identifier */
    char vendor_id[32];              /* Vendor identifier */
    uint32_t component_id;           /* Component being updated */
    
    /* Dependencies */
    uint32_t required_bootloader;    /* Minimum bootloader version */
    uint32_t required_secure_boot;   /* Required secure boot version */
    
    /* Installation instructions */
    uint8_t  requires_reboot;        /* Reboot required after install */
    uint8_t  allow_downgrade;        /* Allow version downgrade */
    uint8_t  critical_update;        /* Security-critical update */
    uint8_t  install_priority;       /* Installation priority (0-255) */
    
    /* Recovery information */
    uint32_t rollback_version;       /* Version to rollback to on failure */
    char     release_notes_url[256]; /* URL for release notes */
} update_manifest_t;
\end{lstlisting}

\subsection{Bandwidth-Efficient Update Strategies}

PQC signatures are larger than classical signatures, impacting bandwidth-constrained IoT networks:

\begin{table}[htbp]
\centering
\caption{Update Overhead Comparison}
\label{tab:update-overhead}
\begin{tabular}{@{}lrrrr@{}}
\toprule
\textbf{Component} & \textbf{ECDSA} & \textbf{ML-DSA-44} & \textbf{Falcon-512} & \textbf{SLH-DSA-128f} \\
\midrule
Signature & 64 B & 2,420 B & 666 B & 17,088 B \\
Public Key (optional) & 64 B & 1,312 B & 897 B & 32 B \\
Header overhead & 256 B & 256 B & 256 B & 256 B \\
\midrule
\textbf{Total overhead} & \textbf{384 B} & \textbf{3,988 B} & \textbf{1,819 B} & \textbf{17,376 B} \\
\textbf{For 100 KB update} & 0.4\% & 3.9\% & 1.8\% & 17.4\% \\
\bottomrule
\end{tabular}
\end{table}

\begin{lstlisting}[style=cstyle, caption={Delta Update Generator and Applier}]
/*
 * Delta Update System for Bandwidth-Constrained IoT
 * Uses bsdiff-style binary differencing
 */

#include <stdint.h>
#include <stdbool.h>

/* Delta patch format */
typedef struct __attribute__((packed)) {
    uint32_t magic;          /* 0x44454C54 "DELT" */
    uint32_t ctrl_len;       /* Control block length */
    uint32_t diff_len;       /* Diff block length */
    uint32_t extra_len;      /* Extra block length */
    uint32_t new_size;       /* Size of new file */
} delta_header_t;

/* Control tuple for delta application */
typedef struct __attribute__((packed)) {
    int32_t diff_len;        /* Bytes to copy from diff block */
    int32_t extra_len;       /* Bytes to copy from extra block */
    int32_t seek_offset;     /* Seek in old file (can be negative) */
} delta_ctrl_t;

/* Stream interface for memory-constrained devices */
typedef struct {
    int (*read)(void *ctx, uint8_t *buf, size_t len);
    int (*write)(void *ctx, const uint8_t *buf, size_t len);
    int (*seek)(void *ctx, int32_t offset, int whence);
    void *context;
} stream_t;

/* Apply delta patch with minimal RAM usage */
int apply_delta_patch_streaming(stream_t *old_image,
                                 stream_t *patch,
                                 stream_t *new_image,
                                 uint8_t *work_buffer,
                                 size_t work_size) {
    delta_header_t header;
    delta_ctrl_t ctrl;
    int32_t old_pos = 0;
    int32_t new_pos = 0;
    
    /* Read and validate header */
    if (patch->read(patch->context, (uint8_t *)&header, 
                    sizeof(header)) != sizeof(header)) {
        return -1;
    }
    
    if (header.magic != 0x44454C54) {
        return -2;  /* Invalid magic */
    }
    
    /* Process control tuples */
    size_t ctrl_pos = 0;
    while (ctrl_pos < header.ctrl_len) {
        /* Read control tuple */
        if (patch->read(patch->context, (uint8_t *)&ctrl,
                        sizeof(ctrl)) != sizeof(ctrl)) {
            return -3;
        }
        ctrl_pos += sizeof(ctrl);
        
        /* Apply diff block: new[i] = old[i] + diff[i] */
        size_t remaining = ctrl.diff_len;
        while (remaining > 0) {
            size_t chunk = (remaining < work_size / 2) ? 
                           remaining : work_size / 2;
            
            /* Read from old image */
            uint8_t *old_buf = work_buffer;
            old_image->read(old_image->context, old_buf, chunk);
            
            /* Read diff block */
            uint8_t *diff_buf = work_buffer + work_size / 2;
            patch->read(patch->context, diff_buf, chunk);
            
            /* Apply diff: new = old + diff */
            for (size_t i = 0; i < chunk; i++) {
                old_buf[i] += diff_buf[i];
            }
            
            /* Write to new image */
            new_image->write(new_image->context, old_buf, chunk);
            
            old_pos += chunk;
            new_pos += chunk;
            remaining -= chunk;
        }
        
        /* Copy extra block directly to new image */
        remaining = ctrl.extra_len;
        while (remaining > 0) {
            size_t chunk = (remaining < work_size) ? remaining : work_size;
            patch->read(patch->context, work_buffer, chunk);
            new_image->write(new_image->context, work_buffer, chunk);
            new_pos += chunk;
            remaining -= chunk;
        }
        
        /* Seek in old file */
        old_pos += ctrl.seek_offset;
        old_image->seek(old_image->context, old_pos, SEEK_SET);
    }
    
    return (new_pos == (int32_t)header.new_size) ? 0 : -4;
}

/* Calculate delta patch size savings */
typedef struct {
    size_t full_size;
    size_t delta_size;
    float savings_percent;
    bool delta_viable;      /* True if delta is worth using */
} delta_analysis_t;

delta_analysis_t analyze_delta_savings(size_t full_image_size,
                                        size_t delta_size,
                                        size_t pqc_overhead) {
    delta_analysis_t result;
    
    result.full_size = full_image_size + pqc_overhead;
    result.delta_size = delta_size + pqc_overhead;
    
    if (result.delta_size < result.full_size) {
        result.savings_percent = 100.0f * 
            (1.0f - (float)result.delta_size / result.full_size);
        /* Delta viable if saves at least 20% */
        result.delta_viable = (result.savings_percent > 20.0f);
    } else {
        result.savings_percent = 0;
        result.delta_viable = false;
    }
    
    return result;
}
\end{lstlisting}

\subsection{A/B Update Scheme with Rollback}

\begin{lstlisting}[style=cstyle, caption={A/B Partition Update Manager}]
/*
 * A/B Partition Update System
 * Ensures atomic updates with automatic rollback
 */

#include <stdint.h>
#include <stdbool.h>

/* Partition slot identifiers */
typedef enum {
    SLOT_A = 0,
    SLOT_B = 1
} partition_slot_t;

/* Slot metadata stored in protected flash region */
typedef struct __attribute__((packed)) {
    uint32_t magic;              /* 0x534C4F54 "SLOT" */
    uint32_t version;            /* Firmware version in slot */
    uint32_t crc32;              /* CRC32 of slot contents */
    uint8_t  image_hash[32];     /* SHA-256 of image */
    uint8_t  status;             /* Slot status */
    uint8_t  boot_attempts;      /* Failed boot attempts */
    uint8_t  max_boot_attempts;  /* Max attempts before rollback */
    uint8_t  reserved;
    uint32_t install_time;       /* When this slot was written */
} slot_metadata_t;

typedef enum {
    SLOT_STATUS_EMPTY = 0,       /* No valid image */
    SLOT_STATUS_VALID = 1,       /* Valid, not yet tested */
    SLOT_STATUS_TESTING = 2,     /* Booting for testing */
    SLOT_STATUS_CONFIRMED = 3,   /* Confirmed working */
    SLOT_STATUS_FAILED = 4       /* Failed validation */
} slot_status_t;

/* Boot control block */
typedef struct __attribute__((packed)) {
    uint32_t magic;              /* 0x424F4F54 "BOOT" */
    uint8_t  active_slot;        /* Currently active slot */
    uint8_t  pending_slot;       /* Slot to try on next boot */
    uint8_t  rollback_slot;      /* Slot to rollback to */
    uint8_t  flags;
    slot_metadata_t slots[2];    /* Metadata for both slots */
} boot_control_t;

/* Global boot control (in protected storage) */
extern boot_control_t *g_boot_ctrl;

/* Get the inactive slot for staging updates */
partition_slot_t get_update_slot(void) {
    return (g_boot_ctrl->active_slot == SLOT_A) ? SLOT_B : SLOT_A;
}

/* Write update to inactive slot */
int stage_update(const pqc_update_header_t *header,
                 stream_t *payload_stream,
                 const uint8_t *signature,
                 const uint8_t *signing_key) {
    partition_slot_t target = get_update_slot();
    slot_metadata_t *slot_meta = &g_boot_ctrl->slots[target];
    
    /* Step 1: Verify signature before writing anything */
    /* (Signature covers header which contains image hash) */
    if (verify_update_signature(header, signature, 
                                header->sig_size, signing_key) != 0) {
        return -1;  /* Signature verification failed */
    }
    
    /* Step 2: Erase target partition */
    if (flash_erase_partition(target) != 0) {
        return -2;
    }
    
    /* Step 3: Stream and decompress payload to flash */
    uint8_t work_buffer[4096];
    sha256_ctx_t hash_ctx;
    sha256_init(&hash_ctx);
    
    size_t written = 0;
    size_t remaining = header->payload_size;
    
    /* Initialize decompressor */
    decompress_ctx_t decomp;
    decompress_init(&decomp, header->compression);
    
    while (remaining > 0) {
        size_t chunk = (remaining < sizeof(work_buffer)) ? 
                       remaining : sizeof(work_buffer);
        
        /* Read compressed chunk */
        if (payload_stream->read(payload_stream->context, 
                                  work_buffer, chunk) != (int)chunk) {
            return -3;
        }
        
        /* Decompress and write */
        uint8_t decompressed[8192];
        size_t decomp_len;
        
        if (decompress_chunk(&decomp, work_buffer, chunk,
                             decompressed, &decomp_len) != 0) {
            return -4;
        }
        
        /* Update hash */
        sha256_update(&hash_ctx, decompressed, decomp_len);
        
        /* Write to flash */
        if (flash_write_partition(target, written, 
                                   decompressed, decomp_len) != 0) {
            return -5;
        }
        
        written += decomp_len;
        remaining -= chunk;
    }
    
    decompress_finish(&decomp);
    
    /* Step 4: Verify hash of written image */
    uint8_t computed_hash[32];
    sha256_final(&hash_ctx, computed_hash);
    
    if (memcmp(computed_hash, header->image_hash, 32) != 0) {
        /* Hash mismatch - mark slot as failed */
        slot_meta->status = SLOT_STATUS_FAILED;
        return -6;
    }
    
    /* Step 5: Update slot metadata */
    slot_meta->magic = 0x534C4F54;
    slot_meta->version = header->new_version;
    slot_meta->crc32 = crc32_partition(target);
    memcpy(slot_meta->image_hash, computed_hash, 32);
    slot_meta->status = SLOT_STATUS_VALID;
    slot_meta->boot_attempts = 0;
    slot_meta->max_boot_attempts = 3;
    slot_meta->install_time = get_current_time();
    
    /* Step 6: Mark slot as pending for next boot */
    g_boot_ctrl->pending_slot = target;
    
    /* Persist boot control */
    save_boot_control(g_boot_ctrl);
    
    return 0;
}

/* Called early in boot to manage A/B state */
partition_slot_t select_boot_slot(void) {
    slot_metadata_t *pending = &g_boot_ctrl->slots[g_boot_ctrl->pending_slot];
    slot_metadata_t *active = &g_boot_ctrl->slots[g_boot_ctrl->active_slot];
    
    /* Check if we have a pending update to test */
    if (pending->status == SLOT_STATUS_VALID) {
        pending->status = SLOT_STATUS_TESTING;
        pending->boot_attempts++;
        save_boot_control(g_boot_ctrl);
        return g_boot_ctrl->pending_slot;
    }
    
    /* Check if we're testing an update */
    if (pending->status == SLOT_STATUS_TESTING) {
        if (pending->boot_attempts >= pending->max_boot_attempts) {
            /* Too many failed attempts - rollback */
            pending->status = SLOT_STATUS_FAILED;
            g_boot_ctrl->pending_slot = g_boot_ctrl->active_slot;
            save_boot_control(g_boot_ctrl);
            return g_boot_ctrl->active_slot;
        }
        pending->boot_attempts++;
        save_boot_control(g_boot_ctrl);
        return g_boot_ctrl->pending_slot;
    }
    
    /* Boot confirmed active slot */
    return g_boot_ctrl->active_slot;
}

/* Called by application after successful boot to confirm update */
int confirm_update(void) {
    slot_metadata_t *current = &g_boot_ctrl->slots[g_boot_ctrl->pending_slot];
    
    if (current->status != SLOT_STATUS_TESTING) {
        return -1;  /* Not in testing state */
    }
    
    /* Confirm the update */
    current->status = SLOT_STATUS_CONFIRMED;
    g_boot_ctrl->active_slot = g_boot_ctrl->pending_slot;
    g_boot_ctrl->rollback_slot = (g_boot_ctrl->active_slot == SLOT_A) ? 
                                  SLOT_B : SLOT_A;
    
    save_boot_control(g_boot_ctrl);
    return 0;
}

/* Manual rollback to previous version */
int rollback_update(void) {
    partition_slot_t rollback = g_boot_ctrl->rollback_slot;
    slot_metadata_t *slot = &g_boot_ctrl->slots[rollback];
    
    if (slot->status != SLOT_STATUS_CONFIRMED) {
        return -1;  /* No valid rollback slot */
    }
    
    /* Set rollback slot as pending */
    g_boot_ctrl->pending_slot = rollback;
    g_boot_ctrl->slots[g_boot_ctrl->active_slot].status = SLOT_STATUS_VALID;
    
    save_boot_control(g_boot_ctrl);
    
    /* Trigger reboot */
    system_reboot();
    
    return 0;  /* Won't reach here */
}
\end{lstlisting}

\subsection{Update Verification Pipeline}

\begin{lstlisting}[style=cstyle, caption={Complete Update Verification Pipeline}]
/*
 * End-to-End Update Verification
 * Multiple layers of validation
 */

typedef enum {
    UPDATE_OK = 0,
    UPDATE_ERR_NETWORK = -1,
    UPDATE_ERR_SIGNATURE = -2,
    UPDATE_ERR_VERSION = -3,
    UPDATE_ERR_HARDWARE = -4,
    UPDATE_ERR_HASH = -5,
    UPDATE_ERR_STORAGE = -6,
    UPDATE_ERR_EXPIRED = -7,
    UPDATE_ERR_DEPENDENCY = -8
} update_result_t;

/* Complete update verification */
update_result_t verify_update_package(const uint8_t *package,
                                       size_t package_len,
                                       const uint8_t *trusted_key) {
    const pqc_update_header_t *header = (const pqc_update_header_t *)package;
    
    /* 1. Basic header validation */
    if (header->magic != UPDATE_MAGIC_FULL && 
        header->magic != UPDATE_MAGIC_DELTA) {
        return UPDATE_ERR_SIGNATURE;
    }
    
    /* 2. Check expiry */
    if (header->expiry_timestamp != 0 && 
        get_current_time() > header->expiry_timestamp) {
        return UPDATE_ERR_EXPIRED;
    }
    
    /* 3. Hardware compatibility */
    if (header->target_hw_id != get_hardware_id()) {
        return UPDATE_ERR_HARDWARE;
    }
    
    /* 4. Version check (anti-rollback) */
    uint32_t current_version = get_current_firmware_version();
    if (header->new_version <= current_version && 
        !allow_downgrade_policy()) {
        return UPDATE_ERR_VERSION;
    }
    
    if (header->min_version > current_version) {
        return UPDATE_ERR_VERSION;  /* Current version too old */
    }
    
    /* 5. Parse and validate manifest */
    const uint8_t *manifest = package + sizeof(pqc_update_header_t);
    update_manifest_t parsed_manifest;
    if (parse_manifest(manifest, header->manifest_size, 
                       &parsed_manifest) != 0) {
        return UPDATE_ERR_SIGNATURE;
    }
    
    /* 6. Check dependencies */
    if (parsed_manifest.required_bootloader > get_bootloader_version()) {
        return UPDATE_ERR_DEPENDENCY;
    }
    
    /* 7. Verify signature */
    const uint8_t *signature = manifest + header->manifest_size;
    size_t signed_len = sizeof(pqc_update_header_t) + header->manifest_size;
    
    int sig_result = verify_signature(
        package, signed_len,
        signature, header->sig_size,
        trusted_key, get_key_size(header->sig_algorithm),
        (sig_algorithm_t)header->sig_algorithm
    );
    
    if (sig_result != 0) {
        return UPDATE_ERR_SIGNATURE;
    }
    
    /* 8. Verify payload hash */
    const uint8_t *payload = signature + header->sig_size;
    if (header->pk_size > 0) {
        payload += header->pk_size;
    }
    
    uint8_t computed_hash[32];
    sha256(computed_hash, payload, header->payload_size);
    
    if (memcmp(computed_hash, header->payload_hash, 32) != 0) {
        return UPDATE_ERR_HASH;
    }
    
    return UPDATE_OK;
}
\end{lstlisting}

\begin{table}[htbp]
\centering
\caption{Update Security Checklist}
\label{tab:update-checklist}
\begin{tabular}{@{}lll@{}}
\toprule
\textbf{Check} & \textbf{Purpose} & \textbf{Failure Action} \\
\midrule
Header magic & Valid package format & Reject immediately \\
Expiry timestamp & Prevent replay of old updates & Reject \\
Hardware ID & Prevent cross-device attacks & Reject \\
Version check & Anti-rollback protection & Reject \\
Manifest parse & Validate metadata & Reject \\
Dependency check & Ensure compatibility & Reject \\
PQC signature & Authenticity verification & Reject \\
Payload hash & Integrity verification & Reject \\
Post-install hash & Verify correct installation & Rollback \\
Boot test & Verify functionality & Auto-rollback \\
\bottomrule
\end{tabular}
\end{table}

\section{Certificate Lifecycle Management}
\label{sec:certificate-lifecycle}

X.509 certificates form the foundation of IoT device identity and authentication. The transition to post-quantum cryptography requires careful planning for certificate issuance, renewal, and revocation, particularly given the larger certificate sizes and the need for hybrid approaches during the migration period.

\subsection{PQC Certificate Formats}

\begin{table}[htbp]
\centering
\caption{X.509 Certificate Size Comparison}
\label{tab:cert-sizes}
\begin{tabular}{@{}lrrrr@{}}
\toprule
\textbf{Algorithm} & \textbf{Public Key} & \textbf{Signature} & \textbf{Typical Cert} & \textbf{Chain (3 certs)} \\
\midrule
RSA-2048 & 256 B & 256 B & 1.2 KB & 3.6 KB \\
ECDSA P-256 & 64 B & 64 B & 0.8 KB & 2.4 KB \\
ML-DSA-44 & 1,312 B & 2,420 B & 4.5 KB & 13.5 KB \\
ML-DSA-65 & 1,952 B & 3,293 B & 6.0 KB & 18.0 KB \\
Falcon-512 & 897 B & 666 B & 2.3 KB & 6.9 KB \\
SLH-DSA-128f & 32 B & 17,088 B & 17.8 KB & 53.4 KB \\
Hybrid (ECDSA+ML-DSA-44) & 1,376 B & 2,484 B & 5.3 KB & 15.9 KB \\
\bottomrule
\end{tabular}
\end{table}

\warningbox{A 3-certificate chain using ML-DSA-65 requires \textbf{18 KB} of storage and transmission---nearly 8x larger than ECDSA. For constrained IoT devices, consider Falcon-512 certificates or certificate compression techniques.}

\subsection{Certificate Provisioning Strategies}

\begin{lstlisting}[style=cstyle, caption={IoT Device Certificate Provisioning}]
/*
 * Certificate Provisioning for PQC-enabled IoT Devices
 * Supports factory provisioning and runtime enrollment
 */

#include <stdint.h>
#include <stdbool.h>
#include <string.h>

/* Certificate types */
typedef enum {
    CERT_TYPE_DEVICE_IDENTITY,    /* Long-term device identity */
    CERT_TYPE_OPERATIONAL,        /* Short-term operational cert */
    CERT_TYPE_ATTESTATION,        /* Platform attestation */
    CERT_TYPE_MANUFACTURER        /* Manufacturer CA cert */
} cert_type_t;

/* Certificate storage structure */
typedef struct {
    cert_type_t type;
    uint8_t algorithm;            /* Signature algorithm */
    uint32_t not_before;          /* Validity start (Unix timestamp) */
    uint32_t not_after;           /* Validity end */
    uint16_t cert_len;
    uint16_t key_len;             /* Associated private key length */
    uint8_t subject_hash[32];     /* SHA-256 of subject DN */
    uint8_t issuer_hash[32];      /* SHA-256 of issuer DN */
    /* Followed by: DER-encoded certificate, then encrypted private key */
} cert_entry_t;

/* Certificate store (in secure flash) */
#define MAX_CERTIFICATES 8
typedef struct {
    uint32_t magic;               /* 0x43455254 "CERT" */
    uint32_t version;
    uint16_t num_certs;
    uint16_t reserved;
    cert_entry_t entries[MAX_CERTIFICATES];
    /* Certificate data follows */
} cert_store_t;

/* Factory provisioning: Install manufacturer certificate chain */
int provision_manufacturer_chain(const uint8_t *root_cert, size_t root_len,
                                  const uint8_t *intermediate_cert, size_t int_len,
                                  const uint8_t *device_cert, size_t dev_len,
                                  const uint8_t *device_key_encrypted, 
                                  size_t key_len) {
    cert_store_t *store = get_cert_store();
    
    /* Verify chain before storing */
    if (verify_cert_chain(root_cert, root_len,
                          intermediate_cert, int_len,
                          device_cert, dev_len) != 0) {
        return -1;
    }
    
    /* Store root CA (self-signed) */
    if (store_certificate(store, CERT_TYPE_MANUFACTURER,
                          root_cert, root_len, NULL, 0) != 0) {
        return -2;
    }
    
    /* Store device certificate with encrypted private key */
    if (store_certificate(store, CERT_TYPE_DEVICE_IDENTITY,
                          device_cert, dev_len,
                          device_key_encrypted, key_len) != 0) {
        return -3;
    }
    
    /* Mark provisioning complete */
    store->magic = 0x43455254;
    persist_cert_store(store);
    
    return 0;
}

/* Runtime enrollment using EST (Enrollment over Secure Transport) */
typedef struct {
    char est_server[256];
    uint16_t est_port;
    uint8_t ca_cert_hash[32];     /* Expected CA cert hash for pinning */
    uint8_t auth_cert[4096];      /* Bootstrap/manufacturer cert for auth */
    size_t auth_cert_len;
} est_config_t;

int enroll_certificate_est(const est_config_t *config,
                           uint8_t algorithm,
                           uint8_t *new_cert, size_t *cert_len,
                           uint8_t *new_key, size_t *key_len) {
    int ret = -1;
    
    /* Step 1: Generate new PQC keypair */
    uint8_t pk[MLKEM_MAX_PK_BYTES];
    uint8_t sk[MLKEM_MAX_SK_BYTES];
    
    switch (algorithm) {
        case SIG_ALG_MLDSA44:
            mldsa44_keypair(pk, sk);
            *key_len = MLDSA44_SK_BYTES;
            break;
        case SIG_ALG_MLDSA65:
            mldsa65_keypair(pk, sk);
            *key_len = MLDSA65_SK_BYTES;
            break;
        case SIG_ALG_FALCON512:
            falcon512_keypair(pk, sk);
            *key_len = FALCON512_SK_BYTES;
            break;
        default:
            return -1;
    }
    
    /* Step 2: Create CSR (Certificate Signing Request) */
    uint8_t csr[8192];
    size_t csr_len;
    
    if (create_pqc_csr(csr, &csr_len, pk, sk, algorithm,
                       get_device_id(), get_device_serial()) != 0) {
        goto cleanup;
    }
    
    /* Step 3: Connect to EST server with mutual TLS */
    tls_context_t *tls = tls_connect_mutual(
        config->est_server, config->est_port,
        config->auth_cert, config->auth_cert_len,
        config->ca_cert_hash
    );
    
    if (!tls) {
        goto cleanup;
    }
    
    /* Step 4: Submit CSR via EST /simpleenroll */
    if (est_simple_enroll(tls, csr, csr_len, new_cert, cert_len) != 0) {
        tls_close(tls);
        goto cleanup;
    }
    
    tls_close(tls);
    
    /* Step 5: Verify received certificate */
    if (verify_cert_matches_key(new_cert, *cert_len, pk, algorithm) != 0) {
        goto cleanup;
    }
    
    /* Step 6: Encrypt and output private key */
    if (encrypt_private_key(new_key, sk, *key_len) != 0) {
        goto cleanup;
    }
    
    ret = 0;
    
cleanup:
    secure_zero(sk, sizeof(sk));
    return ret;
}
\end{lstlisting}

\subsection{Certificate Renewal and Rotation}

\begin{lstlisting}[style=cstyle, caption={Automated Certificate Renewal System}]
/*
 * Certificate Renewal Manager
 * Handles proactive renewal before expiration
 */

#include <stdint.h>
#include <stdbool.h>

/* Renewal policy configuration */
typedef struct {
    uint32_t renewal_threshold_days;  /* Days before expiry to renew */
    uint32_t retry_interval_hours;    /* Retry interval on failure */
    uint8_t max_retries;              /* Maximum renewal attempts */
    bool allow_expired_renewal;       /* Allow renewal after expiry */
    bool require_hybrid;              /* Require hybrid certificates */
} renewal_policy_t;

/* Default policy */
static const renewal_policy_t DEFAULT_RENEWAL_POLICY = {
    .renewal_threshold_days = 30,
    .retry_interval_hours = 24,
    .max_retries = 5,
    .allow_expired_renewal = true,
    .require_hybrid = false
};

/* Certificate status */
typedef enum {
    CERT_STATUS_VALID,
    CERT_STATUS_EXPIRING_SOON,
    CERT_STATUS_EXPIRED,
    CERT_STATUS_REVOKED,
    CERT_STATUS_NOT_YET_VALID
} cert_status_t;

/* Check certificate validity */
cert_status_t check_cert_status(const cert_entry_t *cert,
                                 const renewal_policy_t *policy) {
    uint32_t now = get_current_time();
    
    if (now < cert->not_before) {
        return CERT_STATUS_NOT_YET_VALID;
    }
    
    if (now > cert->not_after) {
        return CERT_STATUS_EXPIRED;
    }
    
    /* Check if within renewal window */
    uint32_t threshold = policy->renewal_threshold_days * 24 * 3600;
    if ((cert->not_after - now) < threshold) {
        return CERT_STATUS_EXPIRING_SOON;
    }
    
    return CERT_STATUS_VALID;
}

/* Renewal state machine */
typedef struct {
    cert_entry_t *target_cert;
    renewal_policy_t policy;
    uint8_t attempts;
    uint32_t next_retry_time;
    uint8_t new_cert[8192];
    size_t new_cert_len;
    uint8_t new_key[8192];
    size_t new_key_len;
    bool renewal_pending;
} renewal_state_t;

/* Periodic renewal check - call from main loop or timer */
int renewal_tick(renewal_state_t *state, const est_config_t *est_config) {
    uint32_t now = get_current_time();
    
    /* Check if renewal is needed */
    cert_status_t status = check_cert_status(state->target_cert, 
                                              &state->policy);
    
    if (status == CERT_STATUS_VALID && !state->renewal_pending) {
        return 0;  /* No action needed */
    }
    
    if (status == CERT_STATUS_EXPIRED && !state->policy.allow_expired_renewal) {
        return -1;  /* Cannot renew expired certificate */
    }
    
    /* Check retry timing */
    if (state->renewal_pending && now < state->next_retry_time) {
        return 0;  /* Waiting for retry interval */
    }
    
    /* Attempt renewal */
    state->attempts++;
    
    if (state->attempts > state->policy.max_retries) {
        /* Exceeded retry limit */
        log_error("Certificate renewal failed after %d attempts",
                  state->attempts);
        return -2;
    }
    
    /* Perform enrollment */
    int result = enroll_certificate_est(
        est_config,
        state->target_cert->algorithm,
        state->new_cert, &state->new_cert_len,
        state->new_key, &state->new_key_len
    );
    
    if (result != 0) {
        /* Schedule retry */
        state->next_retry_time = now + 
            (state->policy.retry_interval_hours * 3600);
        state->renewal_pending = true;
        log_warning("Certificate renewal failed, retry scheduled");
        return 0;
    }
    
    /* Success - install new certificate */
    result = install_renewed_certificate(
        state->target_cert,
        state->new_cert, state->new_cert_len,
        state->new_key, state->new_key_len
    );
    
    if (result == 0) {
        state->renewal_pending = false;
        state->attempts = 0;
        log_info("Certificate renewed successfully");
    }
    
    /* Clear sensitive data */
    secure_zero(state->new_key, sizeof(state->new_key));
    
    return result;
}

/* Hybrid certificate renewal - get both classical and PQC certs */
int renew_hybrid_certificates(const est_config_t *est_config) {
    uint8_t ecdsa_cert[2048], mldsa_cert[8192];
    uint8_t ecdsa_key[256], mldsa_key[4096];
    size_t ecdsa_cert_len, mldsa_cert_len;
    size_t ecdsa_key_len, mldsa_key_len;
    
    /* Enroll ECDSA certificate */
    int ret = enroll_certificate_est(est_config, SIG_ALG_ECDSA_P256,
                                      ecdsa_cert, &ecdsa_cert_len,
                                      ecdsa_key, &ecdsa_key_len);
    if (ret != 0) {
        return -1;
    }
    
    /* Enroll ML-DSA certificate */
    ret = enroll_certificate_est(est_config, SIG_ALG_MLDSA44,
                                  mldsa_cert, &mldsa_cert_len,
                                  mldsa_key, &mldsa_key_len);
    if (ret != 0) {
        secure_zero(ecdsa_key, sizeof(ecdsa_key));
        return -2;
    }
    
    /* Store both certificates */
    store_certificate(get_cert_store(), CERT_TYPE_OPERATIONAL,
                      ecdsa_cert, ecdsa_cert_len,
                      ecdsa_key, ecdsa_key_len);
    
    store_certificate(get_cert_store(), CERT_TYPE_DEVICE_IDENTITY,
                      mldsa_cert, mldsa_cert_len,
                      mldsa_key, mldsa_key_len);
    
    secure_zero(ecdsa_key, sizeof(ecdsa_key));
    secure_zero(mldsa_key, sizeof(mldsa_key));
    
    return 0;
}
\end{lstlisting}

\subsection{Certificate Revocation for IoT}

Traditional CRL (Certificate Revocation List) and OCSP (Online Certificate Status Protocol) approaches are often impractical for constrained IoT devices. Alternative approaches are needed:

\begin{table}[htbp]
\centering
\caption{Revocation Methods for IoT Devices}
\label{tab:revocation-methods}
\begin{tabular}{@{}lp{4cm}p{4cm}l@{}}
\toprule
\textbf{Method} & \textbf{Advantages} & \textbf{Disadvantages} & \textbf{IoT Suitability} \\
\midrule
Full CRL & Complete, standard & Large downloads, frequent updates & Poor \\
Delta CRL & Smaller updates & Still requires periodic checks & Limited \\
OCSP & Real-time status & Requires connectivity per-check & Limited \\
OCSP Stapling & Server provides status & Not applicable for device certs & N/A \\
Short-lived certs & No revocation needed & Frequent renewal overhead & Good \\
CRL lite/bloom filter & Compact representation & False positives possible & Good \\
Push revocation & Immediate notification & Requires push infrastructure & Excellent \\
\bottomrule
\end{tabular}
\end{table}

\begin{lstlisting}[style=cstyle, caption={Bloom Filter Based Revocation Checking}]
/*
 * Lightweight Certificate Revocation using Bloom Filters
 * Suitable for memory-constrained IoT devices
 */

#include <stdint.h>
#include <stdbool.h>

/* Bloom filter configuration */
#define BLOOM_SIZE_BITS (8 * 1024)  /* 8 Kbit = 1 KB */
#define BLOOM_SIZE_BYTES (BLOOM_SIZE_BITS / 8)
#define BLOOM_NUM_HASHES 7

typedef struct {
    uint8_t bits[BLOOM_SIZE_BYTES];
    uint32_t version;              /* CRL version */
    uint32_t timestamp;            /* Last update time */
    uint32_t num_revoked;          /* Approximate count */
} bloom_crl_t;

/* Hash functions for bloom filter */
static uint32_t bloom_hash(const uint8_t *data, size_t len, uint32_t seed) {
    /* MurmurHash3 32-bit */
    uint32_t h = seed;
    const uint32_t c1 = 0xcc9e2d51;
    const uint32_t c2 = 0x1b873593;
    
    const uint8_t *tail = data + (len / 4) * 4;
    
    for (size_t i = 0; i < len / 4; i++) {
        uint32_t k = ((uint32_t *)data)[i];
        k *= c1;
        k = (k << 15) | (k >> 17);
        k *= c2;
        h ^= k;
        h = (h << 13) | (h >> 19);
        h = h * 5 + 0xe6546b64;
    }
    
    uint32_t k = 0;
    switch (len & 3) {
        case 3: k ^= tail[2] << 16;
        case 2: k ^= tail[1] << 8;
        case 1: k ^= tail[0];
                k *= c1;
                k = (k << 15) | (k >> 17);
                k *= c2;
                h ^= k;
    }
    
    h ^= len;
    h ^= h >> 16;
    h *= 0x85ebca6b;
    h ^= h >> 13;
    h *= 0xc2b2ae35;
    h ^= h >> 16;
    
    return h;
}

/* Check if certificate might be revoked */
bool bloom_check_revoked(const bloom_crl_t *bloom,
                         const uint8_t *cert_serial,
                         size_t serial_len) {
    for (int i = 0; i < BLOOM_NUM_HASHES; i++) {
        uint32_t hash = bloom_hash(cert_serial, serial_len, i * 0x9E3779B9);
        uint32_t bit_index = hash % BLOOM_SIZE_BITS;
        uint32_t byte_index = bit_index / 8;
        uint8_t bit_mask = 1 << (bit_index % 8);
        
        if (!(bloom->bits[byte_index] & bit_mask)) {
            return false;  /* Definitely not revoked */
        }
    }
    
    return true;  /* Possibly revoked (may be false positive) */
}

/* Update bloom filter from server */
int update_bloom_crl(bloom_crl_t *bloom, const char *server_url) {
    uint8_t response[2048];
    size_t response_len;
    
    /* Download compressed bloom filter */
    if (https_get(server_url, response, &response_len) != 0) {
        return -1;
    }
    
    /* Verify signature on bloom filter update */
    bloom_crl_update_t *update = (bloom_crl_update_t *)response;
    
    if (verify_signature(update->data, update->data_len,
                         update->signature, update->sig_len,
                         get_crl_signing_key(), CRL_KEY_LEN,
                         SIG_ALG_MLDSA44) != 0) {
        return -2;
    }
    
    /* Check version is newer */
    if (update->version <= bloom->version) {
        return 0;  /* Already up to date */
    }
    
    /* Decompress and apply update */
    if (decompress_bloom(bloom->bits, update->compressed_bits,
                         update->compressed_len) != 0) {
        return -3;
    }
    
    bloom->version = update->version;
    bloom->timestamp = update->timestamp;
    bloom->num_revoked = update->num_revoked;
    
    return 0;
}

/* Short-lived certificate approach - no revocation needed */
typedef struct {
    uint32_t cert_lifetime_hours;  /* Typically 24-72 hours */
    uint32_t renewal_threshold;    /* Hours before expiry to renew */
} short_lived_policy_t;

static const short_lived_policy_t SHORT_LIVED_DEFAULT = {
    .cert_lifetime_hours = 24,
    .renewal_threshold = 6
};

/* Short-lived certificates eliminate revocation overhead */
bool should_use_short_lived_certs(const device_profile_t *profile) {
    /* Recommended when:
     * - Device has reliable connectivity
     * - Enrollment server is available
     * - Security requirements are high
     * - Certificate storage is limited
     */
    return (profile->connectivity == CONN_ALWAYS_ON) &&
           (profile->security_level >= 3) &&
           (profile->cert_storage_kb < 16);
}
\end{lstlisting}

\subsection{Certificate Chain Optimization}

\begin{lstlisting}[style=cstyle, caption={Certificate Chain Compression and Caching}]
/*
 * Certificate Chain Optimization for Bandwidth-Constrained IoT
 */

#include <stdint.h>
#include <stdbool.h>

/* Certificate reference (for caching) */
typedef struct {
    uint8_t issuer_key_hash[32];   /* SHA-256 of issuer's public key */
    uint8_t serial_number[20];      /* Certificate serial number */
} cert_ref_t;

/* Compressed certificate chain format */
typedef struct __attribute__((packed)) {
    uint8_t flags;                 /* Compression flags */
    uint8_t num_certs;             /* Number of certificates */
    uint16_t total_len;            /* Total compressed length */
    /* Followed by: compressed certificate data */
} compressed_chain_t;

#define CHAIN_FLAG_ZLIB       0x01  /* ZLIB compression */
#define CHAIN_FLAG_CACHED     0x02  /* Some certs referenced by hash */
#define CHAIN_FLAG_TRUNCATED  0x04  /* Root CA omitted (well-known) */

/* Certificate cache for frequently seen issuers */
#define CERT_CACHE_SIZE 4

typedef struct {
    cert_ref_t ref;
    uint8_t cert_data[4096];
    size_t cert_len;
    uint32_t last_used;
    bool valid;
} cached_cert_t;

static cached_cert_t g_cert_cache[CERT_CACHE_SIZE];

/* Check if certificate is in cache */
const uint8_t *cache_lookup(const cert_ref_t *ref, size_t *len) {
    for (int i = 0; i < CERT_CACHE_SIZE; i++) {
        if (g_cert_cache[i].valid &&
            memcmp(&g_cert_cache[i].ref, ref, sizeof(cert_ref_t)) == 0) {
            g_cert_cache[i].last_used = get_current_time();
            *len = g_cert_cache[i].cert_len;
            return g_cert_cache[i].cert_data;
        }
    }
    return NULL;
}

/* Add certificate to cache (LRU eviction) */
void cache_add(const cert_ref_t *ref, const uint8_t *cert, size_t len) {
    /* Find oldest entry */
    int oldest_idx = 0;
    uint32_t oldest_time = UINT32_MAX;
    
    for (int i = 0; i < CERT_CACHE_SIZE; i++) {
        if (!g_cert_cache[i].valid) {
            oldest_idx = i;
            break;
        }
        if (g_cert_cache[i].last_used < oldest_time) {
            oldest_time = g_cert_cache[i].last_used;
            oldest_idx = i;
        }
    }
    
    /* Store in cache */
    memcpy(&g_cert_cache[oldest_idx].ref, ref, sizeof(cert_ref_t));
    memcpy(g_cert_cache[oldest_idx].cert_data, cert, len);
    g_cert_cache[oldest_idx].cert_len = len;
    g_cert_cache[oldest_idx].last_used = get_current_time();
    g_cert_cache[oldest_idx].valid = true;
}

/* Decompress and reconstruct certificate chain */
int decompress_cert_chain(const compressed_chain_t *compressed,
                          uint8_t *chain_out, size_t *chain_len,
                          size_t max_len) {
    const uint8_t *src = (const uint8_t *)(compressed + 1);
    uint8_t *dst = chain_out;
    size_t dst_offset = 0;
    
    for (int i = 0; i < compressed->num_certs; i++) {
        if (compressed->flags & CHAIN_FLAG_CACHED) {
            /* Check if this entry is a cache reference */
            uint8_t entry_type = *src++;
            
            if (entry_type == 0xFF) {
                /* Cache reference */
                cert_ref_t ref;
                memcpy(&ref, src, sizeof(cert_ref_t));
                src += sizeof(cert_ref_t);
                
                size_t cached_len;
                const uint8_t *cached = cache_lookup(&ref, &cached_len);
                
                if (!cached) {
                    return -1;  /* Cache miss - cannot decompress */
                }
                
                if (dst_offset + cached_len > max_len) {
                    return -2;  /* Buffer overflow */
                }
                
                memcpy(dst + dst_offset, cached, cached_len);
                dst_offset += cached_len;
                continue;
            }
            
            src--;  /* Wasn't a cache marker, rewind */
        }
        
        /* Read certificate length */
        uint16_t cert_len = *(uint16_t *)src;
        src += 2;
        
        /* Decompress if needed */
        if (compressed->flags & CHAIN_FLAG_ZLIB) {
            size_t decomp_len = max_len - dst_offset;
            if (zlib_decompress(dst + dst_offset, &decomp_len,
                               src, cert_len) != 0) {
                return -3;
            }
            dst_offset += decomp_len;
            src += cert_len;
        } else {
            if (dst_offset + cert_len > max_len) {
                return -2;
            }
            memcpy(dst + dst_offset, src, cert_len);
            dst_offset += cert_len;
            src += cert_len;
        }
    }
    
    *chain_len = dst_offset;
    return 0;
}

/* TLS certificate compression extension (RFC 8879) */
typedef enum {
    CERT_COMPRESS_ZLIB = 1,
    CERT_COMPRESS_BROTLI = 2,
    CERT_COMPRESS_ZSTD = 3
} tls_cert_compression_t;

/* Advertise compression support in ClientHello */
int tls_add_cert_compression_ext(uint8_t *ext_out, size_t *ext_len) {
    /* Extension format:
     * uint16 algorithms<2..2^8-2>
     */
    ext_out[0] = 0x00;  /* Extension type high byte */
    ext_out[1] = 0x1B;  /* compress_certificate extension (27) */
    ext_out[2] = 0x00;  /* Length high byte */
    ext_out[3] = 0x03;  /* Length: 3 bytes */
    ext_out[4] = 0x02;  /* Algorithm list length */
    ext_out[5] = 0x00;  /* ZLIB high byte */
    ext_out[6] = 0x01;  /* ZLIB = 1 */
    
    *ext_len = 7;
    return 0;
}
\end{lstlisting}

\begin{table}[htbp]
\centering
\caption{Certificate Lifecycle Best Practices Summary}
\label{tab:cert-best-practices}
\begin{tabular}{@{}lp{9cm}@{}}
\toprule
\textbf{Practice} & \textbf{Recommendation} \\
\midrule
Algorithm choice & Falcon-512 for size-constrained devices; ML-DSA-44 for general use \\
Validity period & 1-3 years for device identity; 24-72 hours for short-lived operational \\
Renewal timing & Begin renewal at 10-20\% remaining lifetime \\
Chain length & Minimize to 2-3 certificates; use cached intermediates \\
Revocation & Bloom filter CRL or short-lived certificates for IoT \\
Compression & Enable TLS certificate compression (RFC 8879) \\
Hybrid approach & Maintain both classical and PQC certificates during transition \\
Key protection & Store private keys in secure element or PUF-wrapped \\
\bottomrule
\end{tabular}
\end{table}

\section{Compliance Frameworks and Standards}
\label{sec:compliance}

Organizations deploying PQC in IoT systems must navigate an evolving landscape of compliance requirements, government mandates, and industry standards. This section provides guidance on meeting regulatory requirements while implementing post-quantum cryptography.

\subsection{CNSA 2.0 (Commercial National Security Algorithm Suite)}

The U.S. National Security Agency (NSA) published CNSA 2.0 in September 2022, mandating the transition to quantum-resistant algorithms for National Security Systems (NSS).

\begin{table}[htbp]
\centering
\caption{CNSA 2.0 Algorithm Requirements}
\label{tab:cnsa2}
\begin{tabular}{@{}llll@{}}
\toprule
\textbf{Function} & \textbf{CNSA 2.0 Algorithm} & \textbf{Parameters} & \textbf{Deadline} \\
\midrule
Software/Firmware Signing & ML-DSA & ML-DSA-87 & 2025 \\
Key Establishment & ML-KEM & ML-KEM-1024 & 2025 \\
Web/Cloud Authentication & ML-DSA & ML-DSA-87 & 2025 \\
Traditional Networking & ML-KEM + ML-DSA & Level 5 & 2026 \\
Operating Systems & ML-DSA & ML-DSA-87 & 2027 \\
Custom Applications & ML-KEM + ML-DSA & Level 5 & 2027 \\
Legacy Equipment & Hybrid or exclusion & Case-by-case & 2033 \\
\bottomrule
\end{tabular}
\end{table}

\warningbox{CNSA 2.0 requires \textbf{NIST Security Level 5} (ML-KEM-1024, ML-DSA-87) for all National Security Systems. This is more stringent than typical commercial requirements and significantly impacts resource-constrained IoT devices.}

\begin{lstlisting}[style=cstyle, caption={CNSA 2.0 Compliance Checker}]
/*
 * CNSA 2.0 Compliance Verification Module
 * Validates cryptographic configurations against NSA requirements
 */

#include <stdint.h>
#include <stdbool.h>
#include <time.h>

/* CNSA 2.0 compliance levels */
typedef enum {
    CNSA_NOT_COMPLIANT = 0,
    CNSA_TRANSITIONAL = 1,     /* Hybrid mode acceptable */
    CNSA_COMPLIANT = 2,        /* Full CNSA 2.0 compliance */
    CNSA_PREFERRED = 3         /* Exceeds requirements */
} cnsa_compliance_t;

/* Algorithm compliance status */
typedef struct {
    bool kem_compliant;
    bool dsa_compliant;
    bool hash_compliant;
    bool symmetric_compliant;
    const char *kem_algorithm;
    const char *dsa_algorithm;
    cnsa_compliance_t overall;
    char deficiencies[512];
} compliance_report_t;

/* CNSA 2.0 required parameters */
static const struct {
    const char *name;
    int min_security_level;
    bool quantum_resistant;
} cnsa2_requirements[] = {
    {"ML-KEM-1024", 5, true},
    {"ML-DSA-87", 5, true},
    {"SHA-384", 3, false},      /* Hash minimum */
    {"SHA-512", 5, false},      /* Hash preferred */
    {"AES-256", 5, false},      /* Symmetric required */
};

/* Check KEM compliance */
static bool check_kem_cnsa2(const char *algorithm, int security_level) {
    if (strcmp(algorithm, "ML-KEM-1024") == 0 && security_level >= 5) {
        return true;
    }
    /* Hybrid acceptable during transition (until 2033) */
    if (strstr(algorithm, "ML-KEM-1024") != NULL && 
        get_current_year() < 2033) {
        return true;  /* Hybrid with ML-KEM-1024 */
    }
    return false;
}

/* Check DSA compliance */
static bool check_dsa_cnsa2(const char *algorithm, int security_level) {
    if (strcmp(algorithm, "ML-DSA-87") == 0 && security_level >= 5) {
        return true;
    }
    /* SLH-DSA also acceptable */
    if (strstr(algorithm, "SLH-DSA") != NULL && security_level >= 5) {
        return true;
    }
    return false;
}

/* Generate compliance report */
compliance_report_t check_cnsa2_compliance(
    const char *kem_alg, int kem_level,
    const char *dsa_alg, int dsa_level,
    const char *hash_alg,
    const char *symmetric_alg) {
    
    compliance_report_t report = {0};
    report.kem_algorithm = kem_alg;
    report.dsa_algorithm = dsa_alg;
    report.deficiencies[0] = '\0';
    
    /* Check KEM */
    report.kem_compliant = check_kem_cnsa2(kem_alg, kem_level);
    if (!report.kem_compliant) {
        strcat(report.deficiencies, "KEM: Requires ML-KEM-1024. ");
    }
    
    /* Check DSA */
    report.dsa_compliant = check_dsa_cnsa2(dsa_alg, dsa_level);
    if (!report.dsa_compliant) {
        strcat(report.deficiencies, "DSA: Requires ML-DSA-87 or SLH-DSA. ");
    }
    
    /* Check hash */
    report.hash_compliant = (strcmp(hash_alg, "SHA-384") == 0 ||
                             strcmp(hash_alg, "SHA-512") == 0 ||
                             strcmp(hash_alg, "SHA3-384") == 0 ||
                             strcmp(hash_alg, "SHA3-512") == 0);
    if (!report.hash_compliant) {
        strcat(report.deficiencies, "Hash: Requires SHA-384 or higher. ");
    }
    
    /* Check symmetric */
    report.symmetric_compliant = (strcmp(symmetric_alg, "AES-256") == 0);
    if (!report.symmetric_compliant) {
        strcat(report.deficiencies, "Symmetric: Requires AES-256. ");
    }
    
    /* Determine overall compliance */
    if (report.kem_compliant && report.dsa_compliant && 
        report.hash_compliant && report.symmetric_compliant) {
        report.overall = CNSA_COMPLIANT;
    } else if (strstr(kem_alg, "ML-KEM") || strstr(dsa_alg, "ML-DSA")) {
        report.overall = CNSA_TRANSITIONAL;
    } else {
        report.overall = CNSA_NOT_COMPLIANT;
    }
    
    return report;
}

/* Print compliance report */
void print_compliance_report(const compliance_report_t *report) {
    printf("=== CNSA 2.0 Compliance Report ===\n");
    printf("KEM Algorithm: %s [%s]\n", 
           report->kem_algorithm,
           report->kem_compliant ? "COMPLIANT" : "NON-COMPLIANT");
    printf("DSA Algorithm: %s [%s]\n",
           report->dsa_algorithm,
           report->dsa_compliant ? "COMPLIANT" : "NON-COMPLIANT");
    printf("Hash: [%s]\n",
           report->hash_compliant ? "COMPLIANT" : "NON-COMPLIANT");
    printf("Symmetric: [%s]\n",
           report->symmetric_compliant ? "COMPLIANT" : "NON-COMPLIANT");
    printf("\nOverall Status: ");
    switch (report->overall) {
        case CNSA_COMPLIANT:
            printf("FULLY COMPLIANT\n");
            break;
        case CNSA_TRANSITIONAL:
            printf("TRANSITIONAL (Hybrid acceptable until 2033)\n");
            break;
        default:
            printf("NOT COMPLIANT\n");
            printf("Deficiencies: %s\n", report->deficiencies);
    }
}
\end{lstlisting}

\subsection{NIST Post-Quantum Cryptography Standards}

NIST finalized the first set of PQC standards in August 2024:

\begin{table}[htbp]
\centering
\caption{NIST PQC Standards (August 2024)}
\label{tab:nist-standards}
\begin{tabular}{@{}lllp{5cm}@{}}
\toprule
\textbf{Standard} & \textbf{Algorithm} & \textbf{Type} & \textbf{Status} \\
\midrule
FIPS 203 & ML-KEM (Kyber) & KEM & Final Standard \\
FIPS 204 & ML-DSA (Dilithium) & Signature & Final Standard \\
FIPS 205 & SLH-DSA (SPHINCS+) & Signature & Final Standard \\
-- & FN-DSA (Falcon) & Signature & Draft (expected 2025) \\
-- & HQC & KEM & Round 4 selection \\
-- & BIKE & KEM & Round 4 selection \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Industry-Specific Compliance}

\subsubsection{Healthcare (HIPAA/HITECH)}

\begin{table}[htbp]
\centering
\caption{PQC Considerations for Healthcare IoT}
\label{tab:healthcare-compliance}
\begin{tabular}{@{}lp{5cm}p{5cm}@{}}
\toprule
\textbf{Requirement} & \textbf{HIPAA Mandate} & \textbf{PQC Implementation} \\
\midrule
Data at rest & Encryption required & AES-256 with PQC key wrap \\
Data in transit & Encryption required & TLS 1.3 with ML-KEM-768 \\
Access control & Unique user ID & PQC-signed certificates \\
Audit controls & Activity logging & Signed audit logs (ML-DSA) \\
Integrity & Data integrity verification & HMAC-SHA-256 or PQC signatures \\
PHI retention & 6+ years minimum & HNDL requires PQC now \\
\bottomrule
\end{tabular}
\end{table}

\subsubsection{Financial Services (PCI DSS)}

\begin{lstlisting}[style=pythonstyle, caption={PCI DSS PQC Compliance Assessment}]
#!/usr/bin/env python3
"""
PCI DSS Post-Quantum Compliance Assessment Tool
Evaluates payment card industry compliance for PQC migration
"""

from dataclasses import dataclass
from typing import List, Dict
from enum import Enum

class PCIRequirement(Enum):
    REQ_3 = "Protect stored cardholder data"
    REQ_4 = "Encrypt transmission of cardholder data"
    REQ_6 = "Develop and maintain secure systems"
    REQ_8 = "Identify and authenticate access"
    REQ_10 = "Track and monitor access"
    REQ_12 = "Maintain security policy"

@dataclass
class CryptoAsset:
    name: str
    asset_type: str  # 'key', 'certificate', 'connection'
    algorithm: str
    key_size: int
    quantum_safe: bool
    data_sensitivity: str  # 'CHD', 'SAD', 'other'
    retention_years: int

@dataclass 
class ComplianceGap:
    requirement: PCIRequirement
    description: str
    severity: str  # 'critical', 'high', 'medium', 'low'
    remediation: str
    deadline: str

def assess_pci_pqc_compliance(assets: List[CryptoAsset]) -> List[ComplianceGap]:
    """Assess PCI DSS compliance gaps for PQC migration."""
    gaps = []
    
    for asset in assets:
        # Check cardholder data protection (Req 3)
        if asset.data_sensitivity in ('CHD', 'SAD'):
            if not asset.quantum_safe and asset.retention_years > 5:
                gaps.append(ComplianceGap(
                    requirement=PCIRequirement.REQ_3,
                    description=f"{asset.name}: CHD encrypted with {asset.algorithm} "
                               f"retained {asset.retention_years} years",
                    severity='high',
                    remediation="Migrate to ML-KEM-768 or higher for key encryption",
                    deadline="2026"
                ))
        
        # Check transmission encryption (Req 4)
        if asset.asset_type == 'connection':
            if asset.algorithm in ('RSA', 'ECDHE') and not asset.quantum_safe:
                gaps.append(ComplianceGap(
                    requirement=PCIRequirement.REQ_4,
                    description=f"{asset.name}: Using {asset.algorithm} for "
                               "key exchange",
                    severity='medium',
                    remediation="Deploy hybrid TLS with X25519+ML-KEM-768",
                    deadline="2027"
                ))
        
        # Check authentication (Req 8)
        if asset.asset_type == 'certificate':
            if asset.algorithm in ('RSA', 'ECDSA') and not asset.quantum_safe:
                gaps.append(ComplianceGap(
                    requirement=PCIRequirement.REQ_8,
                    description=f"{asset.name}: Certificate using {asset.algorithm}",
                    severity='medium',
                    remediation="Issue hybrid or pure PQC certificates (ML-DSA)",
                    deadline="2028"
                ))
    
    return gaps

def generate_pci_pqc_roadmap(gaps: List[ComplianceGap]) -> Dict:
    """Generate migration roadmap from compliance gaps."""
    roadmap = {
        'immediate': [],  # < 1 year
        'short_term': [], # 1-2 years
        'medium_term': [], # 2-3 years
        'long_term': []   # 3+ years
    }
    
    for gap in gaps:
        deadline_year = int(gap.deadline)
        current_year = 2025
        years_remaining = deadline_year - current_year
        
        if years_remaining <= 1:
            roadmap['immediate'].append(gap)
        elif years_remaining <= 2:
            roadmap['short_term'].append(gap)
        elif years_remaining <= 3:
            roadmap['medium_term'].append(gap)
        else:
            roadmap['long_term'].append(gap)
    
    return roadmap

# Example usage
if __name__ == '__main__':
    # Define crypto assets in payment system
    assets = [
        CryptoAsset(
            name="Card vault encryption key",
            asset_type="key",
            algorithm="AES-256",
            key_size=256,
            quantum_safe=False,  # Key wrapped with RSA
            data_sensitivity="CHD",
            retention_years=7
        ),
        CryptoAsset(
            name="Payment gateway TLS",
            asset_type="connection",
            algorithm="ECDHE",
            key_size=256,
            quantum_safe=False,
            data_sensitivity="CHD",
            retention_years=0
        ),
        CryptoAsset(
            name="Merchant certificate",
            asset_type="certificate",
            algorithm="RSA",
            key_size=2048,
            quantum_safe=False,
            data_sensitivity="other",
            retention_years=2
        ),
    ]
    
    gaps = assess_pci_pqc_compliance(assets)
    roadmap = generate_pci_pqc_roadmap(gaps)
    
    print("=== PCI DSS PQC Compliance Assessment ===\n")
    for gap in gaps:
        print(f"[{gap.severity.upper()}] {gap.requirement.value}")
        print(f"  Issue: {gap.description}")
        print(f"  Action: {gap.remediation}")
        print(f"  Deadline: {gap.deadline}\n")
\end{lstlisting}

\subsubsection{Automotive (ISO/SAE 21434)}

\begin{table}[htbp]
\centering
\caption{Automotive Cybersecurity PQC Requirements}
\label{tab:automotive-compliance}
\begin{tabular}{@{}lll@{}}
\toprule
\textbf{UN R155 Requirement} & \textbf{PQC Relevance} & \textbf{Recommendation} \\
\midrule
Secure boot & Firmware authentication & ML-DSA-65 or Falcon-512 \\
Secure OTA & Update integrity & Hybrid signatures \\
V2X communication & Message authentication & SLH-DSA-128f (stateless) \\
Key management & Long-term key protection & ML-KEM-768/1024 \\
ECU authentication & Inter-ECU trust & Lightweight PQC (ML-KEM-512) \\
\bottomrule
\end{tabular}
\end{table}

\subsection{FIPS 140-3 Validation}

For IoT devices requiring FIPS 140-3 validation with PQC:

\begin{table}[htbp]
\centering
\caption{FIPS 140-3 PQC Validation Status (December 2024)}
\label{tab:fips140-3}
\begin{tabular}{@{}llll@{}}
\toprule
\textbf{Algorithm} & \textbf{CAVP Testing} & \textbf{CMVP Modules} & \textbf{Availability} \\
\midrule
ML-KEM & Available & In progress & Q1 2025 \\
ML-DSA & Available & In progress & Q1 2025 \\
SLH-DSA & Available & In progress & Q2 2025 \\
Falcon & Pending & Not yet & 2025-2026 \\
\bottomrule
\end{tabular}
\end{table}

\begin{lstlisting}[style=cstyle, caption={FIPS Mode Configuration for PQC}]
/*
 * FIPS 140-3 Mode Configuration for PQC Operations
 * Ensures compliance with validated module requirements
 */

#include <stdint.h>
#include <stdbool.h>

/* FIPS mode status */
typedef struct {
    bool fips_mode_enabled;
    bool self_test_passed;
    bool integrity_verified;
    uint32_t module_version;
    char validation_cert[32];  /* CMVP certificate number */
} fips_status_t;

static fips_status_t g_fips_status = {0};

/* FIPS-approved algorithms in PQC context */
typedef enum {
    FIPS_ALG_MLKEM_512 = 1,
    FIPS_ALG_MLKEM_768 = 2,
    FIPS_ALG_MLKEM_1024 = 3,
    FIPS_ALG_MLDSA_44 = 4,
    FIPS_ALG_MLDSA_65 = 5,
    FIPS_ALG_MLDSA_87 = 6,
    FIPS_ALG_SLHDSA_SHA2_128F = 7,
    FIPS_ALG_SLHDSA_SHA2_128S = 8,
    FIPS_ALG_SLHDSA_SHA2_192F = 9,
    FIPS_ALG_SLHDSA_SHA2_192S = 10,
    FIPS_ALG_SLHDSA_SHA2_256F = 11,
    FIPS_ALG_SLHDSA_SHA2_256S = 12,
    /* Non-FIPS approved (for reference) */
    NON_FIPS_FALCON_512 = 0x80,
    NON_FIPS_FALCON_1024 = 0x81,
} fips_algorithm_t;

/* Check if algorithm is FIPS-approved */
bool is_fips_approved(fips_algorithm_t alg) {
    return (alg >= FIPS_ALG_MLKEM_512 && alg <= FIPS_ALG_SLHDSA_SHA2_256S);
}

/* Power-on self-test for PQC algorithms */
int fips_pqc_self_test(void) {
    int result = 0;
    
    /* ML-KEM Known Answer Test (KAT) */
    result |= mlkem_kat_test();
    
    /* ML-DSA Known Answer Test */
    result |= mldsa_kat_test();
    
    /* SLH-DSA Known Answer Test */
    result |= slhdsa_kat_test();
    
    /* Pairwise consistency test for key generation */
    result |= pqc_pairwise_consistency_test();
    
    /* DRBG health test */
    result |= drbg_health_test();
    
    g_fips_status.self_test_passed = (result == 0);
    
    return result;
}

/* Module integrity check */
int fips_integrity_check(void) {
    /* Compute HMAC-SHA-256 over module code */
    uint8_t computed_mac[32];
    extern const uint8_t __module_start[];
    extern const uint8_t __module_end[];
    extern const uint8_t __expected_mac[32];
    
    size_t module_size = __module_end - __module_start;
    hmac_sha256(computed_mac, FIPS_INTEGRITY_KEY, 32,
                __module_start, module_size);
    
    g_fips_status.integrity_verified = 
        (secure_memcmp(computed_mac, __expected_mac, 32) == 0);
    
    return g_fips_status.integrity_verified ? 0 : -1;
}

/* Initialize FIPS mode */
int fips_init(void) {
    /* Step 1: Integrity check */
    if (fips_integrity_check() != 0) {
        return -1;
    }
    
    /* Step 2: Power-on self-tests */
    if (fips_pqc_self_test() != 0) {
        return -2;
    }
    
    /* Step 3: Enable FIPS mode */
    g_fips_status.fips_mode_enabled = true;
    g_fips_status.module_version = FIPS_MODULE_VERSION;
    strcpy(g_fips_status.validation_cert, "Pending-2025");
    
    return 0;
}

/* FIPS-compliant key generation wrapper */
int fips_keygen(fips_algorithm_t alg, uint8_t *pk, uint8_t *sk) {
    /* Verify FIPS mode is active */
    if (!g_fips_status.fips_mode_enabled) {
        return -1;
    }
    
    /* Verify algorithm is approved */
    if (!is_fips_approved(alg)) {
        return -2;
    }
    
    /* Continuous RNG test */
    if (drbg_continuous_test() != 0) {
        return -3;
    }
    
    /* Generate keys based on algorithm */
    switch (alg) {
        case FIPS_ALG_MLKEM_768:
            return mlkem768_keypair(pk, sk);
        case FIPS_ALG_MLDSA_65:
            return mldsa65_keypair(pk, sk);
        /* Add other algorithms */
        default:
            return -4;
    }
}
\end{lstlisting}

\subsection{European Regulations (eIDAS 2.0, Cyber Resilience Act)}

\begin{table}[htbp]
\centering
\caption{European PQC Regulatory Landscape}
\label{tab:eu-regulations}
\begin{tabular}{@{}lp{4cm}p{5cm}l@{}}
\toprule
\textbf{Regulation} & \textbf{Scope} & \textbf{PQC Requirement} & \textbf{Timeline} \\
\midrule
eIDAS 2.0 & Digital identity, signatures & PQC for long-term signatures & 2027+ \\
Cyber Resilience Act & IoT product security & Security updates for lifecycle & 2027 \\
NIS2 Directive & Critical infrastructure & Risk-based crypto selection & 2024 \\
GDPR & Personal data protection & Encryption best practices & Ongoing \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Compliance Implementation Checklist}

\begin{table}[htbp]
\centering
\caption{PQC Compliance Implementation Checklist}
\label{tab:compliance-checklist}
\begin{tabular}{@{}clp{7cm}@{}}
\toprule
\textbf{\#} & \textbf{Category} & \textbf{Action Item} \\
\midrule
1 & Inventory & Catalog all cryptographic assets and their quantum vulnerability \\
2 & Risk Assessment & Evaluate HNDL risk based on data sensitivity and retention \\
3 & Algorithm Selection & Choose NIST-approved algorithms matching security requirements \\
4 & Compliance Mapping & Map regulatory requirements to PQC implementations \\
5 & Hybrid Strategy & Plan hybrid classical+PQC during transition period \\
6 & Testing & Implement Known Answer Tests for FIPS compliance \\
7 & Key Management & Update key lifecycle procedures for larger PQC keys \\
8 & Certificate Planning & Plan PKI migration timeline and certificate validity \\
9 & Documentation & Maintain cryptographic module documentation \\
10 & Audit Trail & Log all cryptographic operations for compliance audits \\
11 & Training & Train development and operations teams on PQC \\
12 & Vendor Assessment & Evaluate third-party PQC library compliance claims \\
\bottomrule
\end{tabular}
\end{table}

\infobox{Compliance is not just about using the right algorithms---it requires documented processes, audit trails, and evidence of due diligence. Start your compliance journey with a comprehensive cryptographic inventory and risk assessment.}

%----------------------------------------------------------------------
\section{Chapter Summary}
%----------------------------------------------------------------------

This chapter has provided a comprehensive examination of security analysis methodologies and best practices for post-quantum cryptography deployments in IoT environments. The key topics covered include:

\textbf{Threat Modeling and Risk Assessment:}
\begin{itemize}
    \item The STRIDE framework adapted for PQC threat analysis
    \item HNDL (Harvest Now, Decrypt Later) attack scenarios and their implications
    \item Risk quantification methodologies based on data sensitivity and retention periods
    \item Threat modeling specific to IoT deployment scenarios
\end{itemize}

\textbf{Side-Channel Analysis and Countermeasures:}
\begin{itemize}
    \item Timing attacks on lattice-based algorithms and constant-time implementations
    \item Power analysis (SPA/DPA) vulnerabilities in polynomial arithmetic
    \item Electromagnetic emanation analysis and shielding techniques
    \item Implementation-level protections including masking and shuffling
\end{itemize}

\textbf{Security Parameter Selection:}
\begin{itemize}
    \item NIST security levels (I--V) and their classical/quantum equivalencies
    \item Algorithm selection criteria based on security requirements
    \item Parameter choices for different IoT use cases
    \item Long-term security considerations for 15--20 year device lifecycles
\end{itemize}

\textbf{Key Management Best Practices:}
\begin{itemize}
    \item Complete key lifecycle management from generation to destruction
    \item Secure key storage strategies for constrained devices
    \item Key rotation and rekeying considerations for larger PQC keys
    \item Hardware security integration with TEEs and secure elements
\end{itemize}

\textbf{Secure System Design:}
\begin{itemize}
    \item Secure boot chain implementation with PQC signature verification
    \item TrustZone-M integration for cryptographic isolation
    \item OTA firmware update architectures with A/B scheme support
    \item Certificate lifecycle management and PKI considerations
\end{itemize}

\textbf{Compliance and Standards:}
\begin{itemize}
    \item CNSA 2.0 suite requirements and migration timeline
    \item NIST post-quantum cryptography standards (FIPS 203, 204, 205)
    \item FIPS 140-3 validation requirements for cryptographic modules
    \item Industry-specific compliance (automotive, medical, industrial)
    \item European regulatory landscape (eIDAS 2.0, Cyber Resilience Act)
\end{itemize}

The overarching message of this chapter is that security in PQC deployments extends far beyond algorithm selection. A holistic approach encompassing implementation security, key management, system architecture, and regulatory compliance is essential for robust quantum-resistant IoT systems.

% End of Chapter 9 - Security Analysis and Best Practices

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% CHAPTER 10: MIGRATION ROADMAPS AND COST ANALYSIS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Migration Roadmaps and Cost Analysis}
\label{chap:migration}

The transition from classical to post-quantum cryptography represents one of the most significant cryptographic migrations in history. This chapter provides practical roadmaps for IoT deployments, comprehensive cost analysis frameworks, and risk assessment methodologies to guide organizations through this transition.

\section{Migration Timeline Overview}
\label{sec:migration-timeline}

\subsection{Industry Consensus Timeline}

\begin{figure}[htbp]
\centering
\begin{tikzpicture}[scale=0.75, transform shape]
    % Timeline axis
    \draw[thick, ->] (0,0) -- (16,0) node[right] {Year};
    
    % Year markers
    \foreach \x/\year in {0/2024, 2/2025, 4/2026, 6/2027, 8/2028, 10/2030, 12/2033, 14/2035} {
        \draw (\x, 0.15) -- (\x, -0.15);
        \node[below] at (\x, -0.25) {\footnotesize \year};
    }
    
    % Phase bars
    % Phase 1: Preparation
    \fill[green!30] (0, 0.5) rectangle (4, 1.3);
    \draw[green!60!black] (0, 0.5) rectangle (4, 1.3);
    \node at (2, 0.9) {\footnotesize \textbf{Preparation}};
    
    % Phase 2: Hybrid Deployment
    \fill[yellow!40] (2, 1.6) rectangle (10, 2.4);
    \draw[yellow!60!black] (2, 1.6) rectangle (10, 2.4);
    \node at (6, 2.0) {\footnotesize \textbf{Hybrid Deployment}};
    
    % Phase 3: PQC Primary
    \fill[orange!40] (6, 2.7) rectangle (14, 3.5);
    \draw[orange!60!black] (6, 2.7) rectangle (14, 3.5);
    \node at (10, 3.1) {\footnotesize \textbf{PQC Primary}};
    
    % Phase 4: Classical Deprecation
    \fill[red!30] (10, 3.8) rectangle (16, 4.6);
    \draw[red!60!black] (10, 3.8) rectangle (16, 4.6);
    \node at (13, 4.2) {\footnotesize \textbf{Classical Deprecated}};
    
    % Milestones
    \draw[blue, thick, dashed] (0, -0.5) -- (0, 5);
    \node[blue, rotate=90, anchor=south] at (-0.3, 2.5) {\tiny NIST Standards};
    
    \draw[purple, thick, dashed] (2, -0.5) -- (2, 5);
    \node[purple, rotate=90, anchor=south] at (1.7, 2.5) {\tiny CNSA 2.0 Start};
    
    \draw[red, thick, dashed] (10, -0.5) -- (10, 5);
    \node[red, rotate=90, anchor=south] at (9.7, 2.5) {\tiny Est. CRQC};
    
    % Legend
    \node[anchor=west] at (0, 5.5) {\footnotesize CRQC = Cryptographically Relevant Quantum Computer};
\end{tikzpicture}
\caption{Post-Quantum Cryptography Migration Timeline}
\label{fig:migration-timeline}
\end{figure}

\begin{table}[htbp]
\centering
\caption{Migration Phase Definitions}
\label{tab:migration-phases}
\begin{tabular}{@{}llp{7cm}@{}}
\toprule
\textbf{Phase} & \textbf{Period} & \textbf{Objectives} \\
\midrule
Preparation & 2024--2026 & Inventory, risk assessment, pilot projects, training \\
Hybrid Deployment & 2025--2030 & Deploy hybrid classical+PQC, maintain interoperability \\
PQC Primary & 2027--2035 & PQC as default, classical for legacy only \\
Classical Deprecation & 2030--2035+ & Remove classical crypto, full PQC operation \\
\bottomrule
\end{tabular}
\end{table}

\subsection{IoT-Specific Migration Challenges}

\begin{table}[htbp]
\centering
\caption{IoT Migration Challenges vs. Enterprise IT}
\label{tab:iot-challenges}
\begin{tabular}{@{}lp{5cm}p{5cm}@{}}
\toprule
\textbf{Challenge} & \textbf{Enterprise IT} & \textbf{IoT Devices} \\
\midrule
Update capability & Regular patching assumed & Many devices unpatchable \\
Resource constraints & Abundant & Severely limited \\
Deployment scale & Thousands & Millions to billions \\
Physical access & Data centers, offices & Field deployed, remote \\
Lifecycle & 3--5 years & 10--25 years \\
Interoperability & Standard protocols & Proprietary protocols common \\
Cost per unit & \$1000s & \$1--\$100 \\
\bottomrule
\end{tabular}
\end{table}

\section{Migration Strategies}
\label{sec:migration-strategies}

\subsection{Strategy 1: Crypto-Agility First}

Implement cryptographic agility before migrating to PQC:

\begin{lstlisting}[style=cstyle, caption={Crypto-Agile Architecture for IoT}]
/*
 * Crypto-Agile Framework for IoT Devices
 * Enables runtime algorithm selection and future migration
 */

#include <stdint.h>
#include <stdbool.h>
#include <string.h>

/* Algorithm registry */
typedef enum {
    /* Key Exchange Mechanisms */
    ALG_ECDH_P256 = 0x0101,
    ALG_X25519 = 0x0102,
    ALG_MLKEM_512 = 0x0201,
    ALG_MLKEM_768 = 0x0202,
    ALG_MLKEM_1024 = 0x0203,
    ALG_HYBRID_X25519_MLKEM768 = 0x0301,
    
    /* Signature Algorithms */
    ALG_ECDSA_P256 = 0x1101,
    ALG_ED25519 = 0x1102,
    ALG_MLDSA_44 = 0x1201,
    ALG_MLDSA_65 = 0x1202,
    ALG_MLDSA_87 = 0x1203,
    ALG_FALCON_512 = 0x1301,
    ALG_HYBRID_ECDSA_MLDSA = 0x1401,
} crypto_algorithm_t;

/* Algorithm capabilities */
typedef struct {
    crypto_algorithm_t id;
    const char *name;
    uint16_t pk_size;
    uint16_t sk_size;
    uint16_t ct_or_sig_size;
    uint16_t security_level;
    bool quantum_safe;
    bool fips_approved;
    
    /* Function pointers for operations */
    int (*keygen)(uint8_t *pk, uint8_t *sk);
    int (*encaps)(uint8_t *ct, uint8_t *ss, const uint8_t *pk);
    int (*decaps)(uint8_t *ss, const uint8_t *ct, const uint8_t *sk);
    int (*sign)(uint8_t *sig, size_t *sig_len, 
                const uint8_t *msg, size_t msg_len, const uint8_t *sk);
    int (*verify)(const uint8_t *sig, size_t sig_len,
                  const uint8_t *msg, size_t msg_len, const uint8_t *pk);
} algorithm_info_t;

/* Algorithm registry - populated at compile time or runtime */
#define MAX_ALGORITHMS 32
static algorithm_info_t g_algorithm_registry[MAX_ALGORITHMS];
static int g_num_algorithms = 0;

/* Register an algorithm */
int crypto_register_algorithm(const algorithm_info_t *alg) {
    if (g_num_algorithms >= MAX_ALGORITHMS) {
        return -1;
    }
    memcpy(&g_algorithm_registry[g_num_algorithms], alg, 
           sizeof(algorithm_info_t));
    g_num_algorithms++;
    return 0;
}

/* Find algorithm by ID */
const algorithm_info_t *crypto_get_algorithm(crypto_algorithm_t id) {
    for (int i = 0; i < g_num_algorithms; i++) {
        if (g_algorithm_registry[i].id == id) {
            return &g_algorithm_registry[i];
        }
    }
    return NULL;
}

/* Policy-based algorithm selection */
typedef struct {
    bool require_quantum_safe;
    bool require_fips;
    uint16_t min_security_level;
    uint16_t max_pk_size;
    uint16_t max_ct_size;
    crypto_algorithm_t preferred_kem;
    crypto_algorithm_t preferred_sig;
} crypto_policy_t;

/* Select best algorithm matching policy */
crypto_algorithm_t select_kem_algorithm(const crypto_policy_t *policy) {
    /* Try preferred first */
    const algorithm_info_t *pref = crypto_get_algorithm(policy->preferred_kem);
    if (pref && algorithm_matches_policy(pref, policy)) {
        return policy->preferred_kem;
    }
    
    /* Fall back to best available */
    for (int i = 0; i < g_num_algorithms; i++) {
        const algorithm_info_t *alg = &g_algorithm_registry[i];
        
        /* Skip signature algorithms */
        if ((alg->id & 0x1000) != 0) continue;
        
        if (algorithm_matches_policy(alg, policy)) {
            return alg->id;
        }
    }
    
    return 0;  /* No suitable algorithm */
}

/* Crypto-agile key exchange */
typedef struct {
    crypto_algorithm_t algorithm;
    uint8_t public_key[4096];
    uint16_t pk_len;
    uint8_t secret_key[8192];
    uint16_t sk_len;
} agile_keypair_t;

int agile_keygen(agile_keypair_t *kp, crypto_algorithm_t alg) {
    const algorithm_info_t *info = crypto_get_algorithm(alg);
    if (!info || !info->keygen) {
        return -1;
    }
    
    kp->algorithm = alg;
    kp->pk_len = info->pk_size;
    kp->sk_len = info->sk_size;
    
    return info->keygen(kp->public_key, kp->secret_key);
}

int agile_encaps(uint8_t *ct, uint16_t *ct_len,
                 uint8_t *shared_secret,
                 const agile_keypair_t *recipient_pk) {
    const algorithm_info_t *info = crypto_get_algorithm(recipient_pk->algorithm);
    if (!info || !info->encaps) {
        return -1;
    }
    
    *ct_len = info->ct_or_sig_size;
    return info->encaps(ct, shared_secret, recipient_pk->public_key);
}

int agile_decaps(uint8_t *shared_secret,
                 const uint8_t *ct, uint16_t ct_len,
                 const agile_keypair_t *kp) {
    const algorithm_info_t *info = crypto_get_algorithm(kp->algorithm);
    if (!info || !info->decaps) {
        return -1;
    }
    
    return info->decaps(shared_secret, ct, kp->secret_key);
}

/* Algorithm negotiation for protocols */
typedef struct {
    crypto_algorithm_t supported_kems[8];
    uint8_t num_kems;
    crypto_algorithm_t supported_sigs[8];
    uint8_t num_sigs;
} crypto_capabilities_t;

crypto_algorithm_t negotiate_kem(const crypto_capabilities_t *local,
                                  const crypto_capabilities_t *remote,
                                  const crypto_policy_t *policy) {
    /* Find strongest mutually supported algorithm */
    for (int i = 0; i < local->num_kems; i++) {
        crypto_algorithm_t local_alg = local->supported_kems[i];
        
        for (int j = 0; j < remote->num_kems; j++) {
            if (local_alg == remote->supported_kems[j]) {
                const algorithm_info_t *info = crypto_get_algorithm(local_alg);
                if (info && algorithm_matches_policy(info, policy)) {
                    return local_alg;
                }
            }
        }
    }
    
    return 0;  /* No common algorithm */
}
\end{lstlisting}

\subsection{Strategy 2: Phased Hybrid Deployment}

\begin{table}[htbp]
\centering
\caption{Phased Hybrid Deployment Plan}
\label{tab:hybrid-phases}
\begin{tabular}{@{}lllp{5cm}@{}}
\toprule
\textbf{Phase} & \textbf{Timeline} & \textbf{Configuration} & \textbf{Action Items} \\
\midrule
1 & 2024--2025 & Classical only & Inventory, plan, pilot hybrid \\
2 & 2025--2026 & Hybrid optional & Deploy hybrid to new devices \\
3 & 2026--2028 & Hybrid default & Upgrade existing devices to hybrid \\
4 & 2028--2030 & PQC preferred & Classical as fallback only \\
5 & 2030+ & PQC only & Remove classical algorithms \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Strategy 3: Risk-Based Prioritization}

\begin{lstlisting}[style=pythonstyle, caption={Risk-Based Migration Prioritization Tool}]
#!/usr/bin/env python3
"""
Risk-Based PQC Migration Prioritization
Calculates migration priority based on multiple risk factors
"""

from dataclasses import dataclass
from typing import List
from enum import Enum
import math

class DataSensitivity(Enum):
    PUBLIC = 1
    INTERNAL = 2
    CONFIDENTIAL = 3
    SECRET = 4
    TOP_SECRET = 5

class ThreatExposure(Enum):
    INTERNAL_ONLY = 1
    LIMITED_EXTERNAL = 2
    INTERNET_FACING = 3
    CRITICAL_INFRASTRUCTURE = 4

@dataclass
class CryptoSystem:
    name: str
    system_type: str  # 'kem', 'signature', 'both'
    current_algorithm: str
    data_sensitivity: DataSensitivity
    data_retention_years: int
    threat_exposure: ThreatExposure
    device_count: int
    upgrade_difficulty: int  # 1-10
    business_criticality: int  # 1-10
    compliance_requirements: List[str]

@dataclass
class MigrationPriority:
    system: CryptoSystem
    hndl_risk_score: float
    compliance_urgency: float
    operational_risk: float
    overall_priority: float
    recommended_deadline: int  # Year

def calculate_hndl_risk(system: CryptoSystem, crqc_year: int = 2030) -> float:
    """
    Calculate Harvest-Now-Decrypt-Later risk.
    Higher score = higher risk = migrate sooner
    """
    current_year = 2025
    years_until_crqc = crqc_year - current_year
    
    # Data will be decryptable when: retention ends OR CRQC arrives
    years_data_vulnerable = max(0, 
        system.data_retention_years - years_until_crqc)
    
    # Base risk from data sensitivity
    sensitivity_weight = system.data_sensitivity.value / 5.0
    
    # Exposure multiplier
    exposure_multiplier = system.threat_exposure.value / 2.0
    
    # HNDL risk score (0-100)
    risk = (years_data_vulnerable * 10 * sensitivity_weight * 
            exposure_multiplier)
    
    return min(100, risk)

def calculate_compliance_urgency(system: CryptoSystem) -> float:
    """Calculate urgency based on compliance deadlines."""
    urgency = 0
    current_year = 2025
    
    compliance_deadlines = {
        'CNSA_2.0': 2025,
        'CNSA_2.0_FULL': 2033,
        'PCI_DSS_4.0': 2025,
        'HIPAA': 2027,
        'FIPS_140_3': 2026,
        'eIDAS_2.0': 2027,
    }
    
    for req in system.compliance_requirements:
        if req in compliance_deadlines:
            years_until = compliance_deadlines[req] - current_year
            if years_until <= 0:
                urgency += 100  # Already past deadline
            elif years_until <= 1:
                urgency += 80
            elif years_until <= 2:
                urgency += 50
            else:
                urgency += 20
    
    return min(100, urgency)

def calculate_operational_risk(system: CryptoSystem) -> float:
    """Calculate risk of migration disruption."""
    # Higher difficulty and criticality = higher operational risk
    risk = (system.upgrade_difficulty * 5 + 
            system.business_criticality * 5)
    
    # Scale by device count (logarithmic)
    scale_factor = math.log10(max(1, system.device_count)) / 3
    risk *= (1 + scale_factor * 0.5)
    
    return min(100, risk)

def prioritize_migration(systems: List[CryptoSystem]) -> List[MigrationPriority]:
    """
    Calculate migration priority for all systems.
    Returns sorted list, highest priority first.
    """
    priorities = []
    
    for system in systems:
        hndl = calculate_hndl_risk(system)
        compliance = calculate_compliance_urgency(system)
        operational = calculate_operational_risk(system)
        
        # Overall priority: weighted combination
        # HNDL and compliance drive urgency, operational risk is a penalty
        overall = (hndl * 0.4 + compliance * 0.4 - operational * 0.2)
        overall = max(0, min(100, overall))
        
        # Recommended deadline based on priority
        if overall >= 80:
            deadline = 2025
        elif overall >= 60:
            deadline = 2026
        elif overall >= 40:
            deadline = 2027
        elif overall >= 20:
            deadline = 2028
        else:
            deadline = 2030
        
        priorities.append(MigrationPriority(
            system=system,
            hndl_risk_score=hndl,
            compliance_urgency=compliance,
            operational_risk=operational,
            overall_priority=overall,
            recommended_deadline=deadline
        ))
    
    # Sort by priority (highest first)
    priorities.sort(key=lambda x: x.overall_priority, reverse=True)
    
    return priorities

def generate_migration_roadmap(priorities: List[MigrationPriority]) -> dict:
    """Generate year-by-year migration roadmap."""
    roadmap = {}
    
    for p in priorities:
        year = p.recommended_deadline
        if year not in roadmap:
            roadmap[year] = []
        
        roadmap[year].append({
            'system': p.system.name,
            'priority_score': p.overall_priority,
            'hndl_risk': p.hndl_risk_score,
            'device_count': p.system.device_count,
            'current_algo': p.system.current_algorithm
        })
    
    return roadmap

# Example usage
if __name__ == '__main__':
    systems = [
        CryptoSystem(
            name="Medical Device Fleet",
            system_type="both",
            current_algorithm="ECDSA + ECDH",
            data_sensitivity=DataSensitivity.SECRET,
            data_retention_years=25,
            threat_exposure=ThreatExposure.LIMITED_EXTERNAL,
            device_count=50000,
            upgrade_difficulty=8,
            business_criticality=9,
            compliance_requirements=['HIPAA', 'FIPS_140_3']
        ),
        CryptoSystem(
            name="Smart Meter Network",
            system_type="kem",
            current_algorithm="ECDH P-256",
            data_sensitivity=DataSensitivity.CONFIDENTIAL,
            data_retention_years=15,
            threat_exposure=ThreatExposure.CRITICAL_INFRASTRUCTURE,
            device_count=2000000,
            upgrade_difficulty=6,
            business_criticality=8,
            compliance_requirements=['CNSA_2.0']
        ),
        CryptoSystem(
            name="Consumer IoT Hub",
            system_type="both",
            current_algorithm="RSA-2048",
            data_sensitivity=DataSensitivity.INTERNAL,
            data_retention_years=5,
            threat_exposure=ThreatExposure.INTERNET_FACING,
            device_count=500000,
            upgrade_difficulty=4,
            business_criticality=5,
            compliance_requirements=[]
        ),
    ]
    
    priorities = prioritize_migration(systems)
    
    print("=== PQC Migration Priority Analysis ===\n")
    for i, p in enumerate(priorities, 1):
        print(f"{i}. {p.system.name}")
        print(f"   Priority Score: {p.overall_priority:.1f}/100")
        print(f"   HNDL Risk: {p.hndl_risk_score:.1f}")
        print(f"   Compliance Urgency: {p.compliance_urgency:.1f}")
        print(f"   Operational Risk: {p.operational_risk:.1f}")
        print(f"   Recommended Deadline: {p.recommended_deadline}")
        print()
    
    roadmap = generate_migration_roadmap(priorities)
    print("=== Migration Roadmap ===")
    for year in sorted(roadmap.keys()):
        print(f"\n{year}:")
        for item in roadmap[year]:
            print(f"  - {item['system']} ({item['device_count']:,} devices)")
\end{lstlisting}

\section{Cost Analysis Framework}
\label{sec:cost-analysis}

\subsection{Total Cost of Migration}

\begin{table}[htbp]
\centering
\caption{PQC Migration Cost Categories}
\label{tab:cost-categories}
\begin{tabular}{@{}lp{6cm}l@{}}
\toprule
\textbf{Category} & \textbf{Components} & \textbf{Typical Range} \\
\midrule
Assessment & Crypto inventory, risk assessment, gap analysis & \$50K--\$500K \\
Development & Library integration, testing, code changes & \$200K--\$2M \\
Infrastructure & Key management, PKI, HSMs & \$100K--\$1M \\
Deployment & OTA updates, field upgrades, rollout & \$100K--\$5M \\
Certification & FIPS 140-3, CC, industry certs & \$200K--\$1M \\
Training & Developer, operations, security teams & \$50K--\$200K \\
Ongoing & Monitoring, incident response, updates & \$100K--\$500K/yr \\
\bottomrule
\end{tabular}
\end{table}

\begin{lstlisting}[style=pythonstyle, caption={PQC Migration Cost Estimator}]
#!/usr/bin/env python3
"""
PQC Migration Cost Estimation Tool
Provides detailed cost breakdown for IoT PQC migration projects
"""

from dataclasses import dataclass, field
from typing import List, Optional
from enum import Enum

class DeviceCategory(Enum):
    ULTRA_CONSTRAINED = "8-bit MCU, <32KB RAM"
    CONSTRAINED = "Cortex-M0/M3, 32-128KB RAM"
    MODERATE = "Cortex-M4/M7, 128KB-1MB RAM"
    CAPABLE = "Cortex-A class, >1MB RAM"
    GATEWAY = "Linux-based gateway"

class MigrationComplexity(Enum):
    LOW = 1      # Drop-in library replacement
    MEDIUM = 2   # Some protocol changes
    HIGH = 3     # Significant redesign
    VERY_HIGH = 4  # Complete cryptographic overhaul

@dataclass
class DeviceFleet:
    name: str
    category: DeviceCategory
    count: int
    current_crypto: str
    ota_capable: bool
    average_age_years: float
    expected_lifetime_years: float

@dataclass
class CostFactors:
    # Labor rates (USD/hour)
    developer_rate: float = 150
    security_engineer_rate: float = 200
    qa_rate: float = 100
    project_manager_rate: float = 175
    
    # External costs
    fips_validation_cost: float = 350000
    cc_evaluation_cost: float = 250000
    hsm_cost_per_unit: float = 15000
    pki_infrastructure: float = 100000
    
    # Per-device costs
    ota_cost_per_device: float = 0.10
    field_upgrade_cost: float = 150
    device_replacement_cost_factor: float = 1.5

@dataclass
class CostEstimate:
    category: str
    description: str
    low_estimate: float
    high_estimate: float
    confidence: str  # 'high', 'medium', 'low'

@dataclass
class MigrationCostReport:
    project_name: str
    total_low: float = 0
    total_high: float = 0
    cost_breakdown: List[CostEstimate] = field(default_factory=list)
    timeline_months: int = 0
    risk_factors: List[str] = field(default_factory=list)

def estimate_development_cost(
    fleet: DeviceFleet,
    complexity: MigrationComplexity,
    factors: CostFactors
) -> CostEstimate:
    """Estimate software development costs."""
    
    # Base hours by complexity
    base_hours = {
        MigrationComplexity.LOW: 400,
        MigrationComplexity.MEDIUM: 1200,
        MigrationComplexity.HIGH: 3000,
        MigrationComplexity.VERY_HIGH: 6000
    }
    
    # Category multiplier
    category_mult = {
        DeviceCategory.ULTRA_CONSTRAINED: 2.5,  # Very difficult
        DeviceCategory.CONSTRAINED: 1.8,
        DeviceCategory.MODERATE: 1.2,
        DeviceCategory.CAPABLE: 1.0,
        DeviceCategory.GATEWAY: 0.8
    }
    
    hours = base_hours[complexity] * category_mult[fleet.category]
    
    # Calculate costs
    dev_hours = hours * 0.6
    sec_hours = hours * 0.25
    qa_hours = hours * 0.15
    
    cost = (dev_hours * factors.developer_rate +
            sec_hours * factors.security_engineer_rate +
            qa_hours * factors.qa_rate)
    
    return CostEstimate(
        category="Development",
        description=f"Code development for {fleet.name}",
        low_estimate=cost * 0.8,
        high_estimate=cost * 1.4,
        confidence="medium"
    )

def estimate_deployment_cost(
    fleet: DeviceFleet,
    factors: CostFactors
) -> CostEstimate:
    """Estimate deployment and rollout costs."""
    
    if fleet.ota_capable:
        # OTA update costs
        cost_per_device = factors.ota_cost_per_device
        # Account for multiple update attempts, bandwidth
        total = fleet.count * cost_per_device * 1.5
        
        return CostEstimate(
            category="Deployment",
            description=f"OTA deployment to {fleet.count:,} devices",
            low_estimate=total * 0.8,
            high_estimate=total * 1.5,
            confidence="high"
        )
    else:
        # Estimate percentage needing field upgrade vs replacement
        old_devices = fleet.count * min(1.0, fleet.average_age_years / 
                                         fleet.expected_lifetime_years)
        upgradeable = fleet.count - old_devices
        
        upgrade_cost = upgradeable * factors.field_upgrade_cost
        # Old devices may need replacement
        replacement_cost = old_devices * factors.field_upgrade_cost * \
                          factors.device_replacement_cost_factor
        
        total = upgrade_cost + replacement_cost
        
        return CostEstimate(
            category="Deployment",
            description=f"Field deployment ({fleet.count:,} devices, "
                       f"{int(old_devices):,} may need replacement)",
            low_estimate=total * 0.7,
            high_estimate=total * 2.0,
            confidence="low"
        )

def estimate_certification_cost(
    require_fips: bool,
    require_cc: bool,
    num_platforms: int,
    factors: CostFactors
) -> CostEstimate:
    """Estimate certification costs."""
    
    total = 0
    desc_parts = []
    
    if require_fips:
        # FIPS 140-3 validation per platform
        total += factors.fips_validation_cost * num_platforms
        desc_parts.append(f"FIPS 140-3 ({num_platforms} platforms)")
    
    if require_cc:
        total += factors.cc_evaluation_cost * num_platforms
        desc_parts.append(f"Common Criteria ({num_platforms} platforms)")
    
    if not desc_parts:
        return CostEstimate(
            category="Certification",
            description="No certification required",
            low_estimate=0,
            high_estimate=0,
            confidence="high"
        )
    
    return CostEstimate(
        category="Certification",
        description=", ".join(desc_parts),
        low_estimate=total * 0.9,
        high_estimate=total * 1.3,
        confidence="medium"
    )

def estimate_infrastructure_cost(
    num_hsms: int,
    new_pki_required: bool,
    factors: CostFactors
) -> CostEstimate:
    """Estimate infrastructure costs."""
    
    total = 0
    
    if num_hsms > 0:
        total += num_hsms * factors.hsm_cost_per_unit
    
    if new_pki_required:
        total += factors.pki_infrastructure
    
    return CostEstimate(
        category="Infrastructure",
        description=f"{num_hsms} HSMs, {'new' if new_pki_required else 'existing'} PKI",
        low_estimate=total * 0.85,
        high_estimate=total * 1.2,
        confidence="high"
    )

def generate_cost_report(
    project_name: str,
    fleets: List[DeviceFleet],
    complexity: MigrationComplexity,
    require_fips: bool = False,
    require_cc: bool = False,
    num_hsms: int = 0,
    new_pki: bool = False,
    factors: Optional[CostFactors] = None
) -> MigrationCostReport:
    """Generate comprehensive cost report."""
    
    if factors is None:
        factors = CostFactors()
    
    report = MigrationCostReport(project_name=project_name)
    
    # Assessment costs (fixed estimate)
    report.cost_breakdown.append(CostEstimate(
        category="Assessment",
        description="Cryptographic inventory and gap analysis",
        low_estimate=50000,
        high_estimate=150000,
        confidence="medium"
    ))
    
    # Development costs per fleet
    for fleet in fleets:
        dev_cost = estimate_development_cost(fleet, complexity, factors)
        report.cost_breakdown.append(dev_cost)
        
        deploy_cost = estimate_deployment_cost(fleet, factors)
        report.cost_breakdown.append(deploy_cost)
    
    # Certification
    num_platforms = len(set(f.category for f in fleets))
    cert_cost = estimate_certification_cost(
        require_fips, require_cc, num_platforms, factors)
    report.cost_breakdown.append(cert_cost)
    
    # Infrastructure
    infra_cost = estimate_infrastructure_cost(num_hsms, new_pki, factors)
    report.cost_breakdown.append(infra_cost)
    
    # Training
    report.cost_breakdown.append(CostEstimate(
        category="Training",
        description="Developer and operations training",
        low_estimate=50000,
        high_estimate=150000,
        confidence="medium"
    ))
    
    # Calculate totals
    report.total_low = sum(c.low_estimate for c in report.cost_breakdown)
    report.total_high = sum(c.high_estimate for c in report.cost_breakdown)
    
    # Estimate timeline
    total_devices = sum(f.count for f in fleets)
    base_months = 12 + (complexity.value * 6)
    device_scale = min(12, total_devices / 100000)
    report.timeline_months = int(base_months + device_scale)
    
    # Risk factors
    for fleet in fleets:
        if not fleet.ota_capable:
            report.risk_factors.append(
                f"{fleet.name}: No OTA capability increases deployment risk")
        if fleet.category == DeviceCategory.ULTRA_CONSTRAINED:
            report.risk_factors.append(
                f"{fleet.name}: Ultra-constrained devices may not support PQC")
    
    return report

def print_cost_report(report: MigrationCostReport):
    """Print formatted cost report."""
    print(f"{'='*60}")
    print(f"PQC Migration Cost Report: {report.project_name}")
    print(f"{'='*60}\n")
    
    print("Cost Breakdown:")
    print("-" * 60)
    for cost in report.cost_breakdown:
        print(f"\n{cost.category}: {cost.description}")
        print(f"  Estimate: ${cost.low_estimate:,.0f} - ${cost.high_estimate:,.0f}")
        print(f"  Confidence: {cost.confidence}")
    
    print("\n" + "=" * 60)
    print(f"TOTAL ESTIMATE: ${report.total_low:,.0f} - ${report.total_high:,.0f}")
    print(f"Timeline: {report.timeline_months} months")
    print("=" * 60)
    
    if report.risk_factors:
        print("\nRisk Factors:")
        for risk in report.risk_factors:
            print(f"  ! {risk}")

# Example usage
if __name__ == '__main__':
    fleets = [
        DeviceFleet(
            name="Smart Sensors",
            category=DeviceCategory.CONSTRAINED,
            count=100000,
            current_crypto="ECDH + ECDSA",
            ota_capable=True,
            average_age_years=2,
            expected_lifetime_years=10
        ),
        DeviceFleet(
            name="Industrial Controllers",
            category=DeviceCategory.MODERATE,
            count=5000,
            current_crypto="RSA-2048",
            ota_capable=False,
            average_age_years=5,
            expected_lifetime_years=15
        ),
    ]
    
    report = generate_cost_report(
        project_name="Industrial IoT PQC Migration",
        fleets=fleets,
        complexity=MigrationComplexity.MEDIUM,
        require_fips=True,
        num_hsms=2,
        new_pki=True
    )
    
    print_cost_report(report)
\end{lstlisting}

\subsection{Cost-Benefit Analysis}

\begin{table}[htbp]
\centering
\caption{PQC Migration Cost vs. Risk of Inaction}
\label{tab:cost-benefit}
\begin{tabular}{@{}lrr@{}}
\toprule
\textbf{Scenario} & \textbf{Migration Cost} & \textbf{Risk of Inaction} \\
\midrule
Small IoT deployment (1K devices) & \$100K--\$500K & Data breach: \$1M+ \\
Medium fleet (100K devices) & \$500K--\$2M & Regulatory fines: \$5M+ \\
Large deployment (1M+ devices) & \$2M--\$10M & Mass compromise: \$50M+ \\
Critical infrastructure & \$5M--\$20M & National security risk \\
\bottomrule
\end{tabular}
\end{table}

\warningbox{The cost of a post-quantum attack on unprepared systems will far exceed migration costs. Organizations storing data with long sensitivity periods (healthcare, finance, government) face the highest risk-adjusted costs from inaction.}

\section{Implementation Checklist}
\label{sec:implementation-checklist}

\begin{table}[htbp]
\centering
\caption{PQC Migration Implementation Checklist}
\label{tab:impl-checklist}
\begin{tabular}{@{}clp{8cm}@{}}
\toprule
\textbf{Phase} & \textbf{\#} & \textbf{Action Item} \\
\midrule
\multirow{5}{*}{\rotatebox{90}{Prepare}} 
& 1 & Complete cryptographic asset inventory \\
& 2 & Assess quantum risk for each asset (HNDL analysis) \\
& 3 & Identify compliance requirements and deadlines \\
& 4 & Evaluate device upgrade capabilities (OTA, memory, CPU) \\
& 5 & Select target PQC algorithms per use case \\
\midrule
\multirow{5}{*}{\rotatebox{90}{Plan}} 
& 6 & Develop crypto-agility architecture \\
& 7 & Create phased migration roadmap \\
& 8 & Estimate costs and secure budget \\
& 9 & Identify pilot projects for early deployment \\
& 10 & Plan PKI and key management updates \\
\midrule
\multirow{5}{*}{\rotatebox{90}{Execute}} 
& 11 & Integrate PQC libraries (liboqs, wolfSSL, etc.) \\
& 12 & Implement hybrid mode (classical + PQC) \\
& 13 & Update protocols (TLS, DTLS, custom) \\
& 14 & Deploy to pilot devices and validate \\
& 15 & Execute phased rollout to production \\
\midrule
\multirow{5}{*}{\rotatebox{90}{Verify}} 
& 16 & Perform security testing and penetration testing \\
& 17 & Validate interoperability with partners \\
& 18 & Complete required certifications (FIPS, etc.) \\
& 19 & Document all changes for audit \\
& 20 & Establish monitoring and incident response \\
\bottomrule
\end{tabular}
\end{table}

\section{Lessons Learned and Recommendations}
\label{sec:lessons-learned}

\subsection{Key Success Factors}

Based on early PQC migration projects, the following factors contribute to success:

\begin{enumerate}
    \item \textbf{Start Early}: Begin assessment and planning now, even if full deployment is years away
    \item \textbf{Prioritize Crypto-Agility}: Design systems to switch algorithms without major redesign
    \item \textbf{Adopt Hybrid Approach}: Deploy hybrid classical+PQC to maintain security during transition
    \item \textbf{Focus on High-Risk Data}: Prioritize systems handling long-lived sensitive data
    \item \textbf{Test Thoroughly}: PQC algorithms are less battle-tested than classical crypto
    \item \textbf{Plan for Larger Sizes}: Account for increased key, signature, and ciphertext sizes
    \item \textbf{Monitor Standards}: NIST standards are final, but implementation guidance evolves
    \item \textbf{Engage Supply Chain}: Ensure vendors and partners are also preparing for PQC
\end{enumerate}

\subsection{Common Pitfalls to Avoid}

\begin{table}[htbp]
\centering
\caption{Common PQC Migration Pitfalls}
\label{tab:pitfalls}
\begin{tabular}{@{}lp{8cm}@{}}
\toprule
\textbf{Pitfall} & \textbf{Mitigation} \\
\midrule
Waiting for ``perfect'' solution & Deploy hybrid now; pure PQC can come later \\
Underestimating size impact & Test with actual PQC sizes early in design \\
Ignoring legacy devices & Plan for device replacement where upgrade impossible \\
Single algorithm selection & Maintain agility for algorithm updates \\
Skipping interoperability testing & Test with multiple implementations and partners \\
Neglecting key management & Update KMS, HSMs, and PKI for PQC \\
Insufficient testing & PQC implementations may have subtle bugs \\
Forgetting about performance & Benchmark on actual target hardware \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Final Recommendations}

\begin{infobox}
\textbf{Summary Recommendations for IoT PQC Migration:}
\begin{enumerate}
    \item \textbf{2024--2025}: Complete inventory, risk assessment, and pilot hybrid deployments
    \item \textbf{2025--2027}: Deploy hybrid mode to all new devices; begin upgrading existing fleet
    \item \textbf{2027--2030}: Transition to PQC-primary with classical fallback
    \item \textbf{2030+}: Complete transition to pure PQC for all new communications
\end{enumerate}

For IoT devices specifically:
\begin{itemize}
    \item Use \textbf{ML-KEM-768} for key exchange (balance of security and size)
    \item Use \textbf{ML-DSA-65} or \textbf{Falcon-512} for signatures (based on size constraints)
    \item Implement \textbf{hybrid mode} to protect against both classical and quantum attacks
    \item Design for \textbf{crypto-agility} to accommodate future algorithm updates
    \item Plan for devices that \textbf{cannot be upgraded} (replacement or isolation)
\end{itemize}
\end{infobox}

%----------------------------------------------------------------------
\section{Chapter Summary}
%----------------------------------------------------------------------

This chapter has provided comprehensive guidance for planning and executing the migration from classical to post-quantum cryptography in IoT deployments. The key areas covered include:

\textbf{Migration Timeline and Planning:}
\begin{itemize}
    \item Industry consensus timeline from 2024 through 2035+
    \item Phased migration approach: preparation, pilot, production, transition, completion
    \item Critical milestones aligned with regulatory deadlines (CNSA 2.0, FIPS requirements)
    \item Risk-based prioritization for different asset categories
\end{itemize}

\textbf{Migration Strategies:}
\begin{itemize}
    \item Greenfield vs. brownfield deployment considerations
    \item Hybrid cryptography as the recommended transitional approach
    \item Device fleet segmentation and upgrade path determination
    \item Legacy device handling: upgrade, replace, isolate, or accept risk
\end{itemize}

\textbf{Cost Analysis Framework:}
\begin{itemize}
    \item Comprehensive cost categories: development, hardware, infrastructure, operations
    \item TCO (Total Cost of Ownership) modeling for 5--10 year periods
    \item ROI calculation methodologies and risk-adjusted analysis
    \item Hidden costs: bandwidth increases, battery impact, interoperability testing
\end{itemize}

\textbf{Resource Requirements:}
\begin{itemize}
    \item Hardware upgrades: memory expansion, crypto accelerators, secure elements
    \item Network infrastructure: bandwidth provisioning for larger PQC payloads
    \item Personnel: training, hiring specialized cryptographic expertise
    \item Testing and validation: interoperability, performance, security audits
\end{itemize}

\textbf{Risk Assessment:}
\begin{itemize}
    \item Quantum risk timeline estimation (5--15 year window)
    \item HNDL threat assessment based on data sensitivity and retention
    \item Migration risk categories: technical, operational, compliance, business
    \item Risk mitigation strategies and contingency planning
\end{itemize}

\textbf{Implementation Guidance:}
\begin{itemize}
    \item Detailed implementation checklists for each migration phase
    \item Lessons learned from early adopters and pilot deployments
    \item Common pitfalls and their mitigations
    \item Success metrics and progress tracking methodologies
\end{itemize}

The central conclusion of this chapter is that successful PQC migration requires careful planning, adequate resource allocation, and a pragmatic phased approach. Organizations should begin their migration journey immediately, starting with inventory and risk assessment, while using hybrid cryptography to protect against both current and future threats during the transition period.

% End of Chapter 10 - Migration Roadmaps and Cost Analysis

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% CONCLUSION
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter*{Conclusion}
\addcontentsline{toc}{chapter}{Conclusion}

The transition to post-quantum cryptography represents a fundamental shift in how we secure digital communications. For the Internet of Things, this transition presents unique challenges due to resource constraints, long device lifecycles, and the scale of deployments. However, as this document has demonstrated, practical solutions exist for implementing quantum-resistant security even on highly constrained devices.

\textbf{Key Takeaways:}

\begin{enumerate}
    \item \textbf{The quantum threat is real and approaching}. While cryptographically relevant quantum computers may be 5--15 years away, the harvest-now-decrypt-later threat means that sensitive data transmitted today using classical cryptography may be compromised in the future.
    
    \item \textbf{NIST standards are ready}. With FIPS 203 (ML-KEM), FIPS 204 (ML-DSA), and FIPS 205 (SLH-DSA) finalized in August 2024, organizations can begin deploying standardized post-quantum algorithms immediately.
    
    \item \textbf{IoT implementation is feasible}. Benchmarks from pqm4 and real-world deployments demonstrate that ML-KEM and ML-DSA can run on Cortex-M4 class devices with acceptable performance. Even more constrained devices can leverage optimized implementations or offload cryptographic operations.
    
    \item \textbf{Hybrid deployment is the recommended approach}. Combining classical and post-quantum algorithms provides defense against both current and future threats while maintaining interoperability during the transition period.
    
    \item \textbf{Migration planning should begin now}. Organizations should inventory cryptographic assets, assess quantum risk, and develop migration roadmaps. Early planning reduces costs and risks.
\end{enumerate}

\textbf{Future Outlook:}

The post-quantum cryptography landscape continues to evolve. Additional signature schemes (Falcon) and code-based KEMs (HQC, BIKE) are progressing through standardization. Hardware acceleration for lattice operations is emerging in new microcontrollers. Protocol integration (TLS 1.3, DTLS, MQTT, CoAP) is maturing rapidly.

For IoT practitioners, the message is clear: the time to prepare for the post-quantum era is now. By following the guidance in this document---selecting appropriate algorithms, implementing crypto-agile architectures, and executing phased migration plans---organizations can protect their IoT deployments against both current and future cryptographic threats.

\vspace{1cm}

\begin{flushright}
\textit{The future of secure IoT is post-quantum.}
\end{flushright}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% BIBLIOGRAPHY
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter*{References}
\addcontentsline{toc}{chapter}{References}

\begin{thebibliography}{99}

\bibitem{nist-fips203}
National Institute of Standards and Technology, ``FIPS 203: Module-Lattice-Based Key-Encapsulation Mechanism Standard,'' August 2024.

\bibitem{nist-fips204}
National Institute of Standards and Technology, ``FIPS 204: Module-Lattice-Based Digital Signature Standard,'' August 2024.

\bibitem{nist-fips205}
National Institute of Standards and Technology, ``FIPS 205: Stateless Hash-Based Digital Signature Standard,'' August 2024.

\bibitem{pqm4}
M. J. Kannwischer, J. Rijneveld, P. Schwabe, and K. Stoffelen, ``pqm4: Post-quantum crypto library for the ARM Cortex-M4,'' \url{https://github.com/mupq/pqm4}, 2024.

\bibitem{liboqs}
Open Quantum Safe Project, ``liboqs: C library for quantum-safe cryptographic algorithms,'' \url{https://github.com/open-quantum-safe/liboqs}, 2024.

\bibitem{kyber-spec}
R. Avanzi et al., ``CRYSTALS-Kyber Algorithm Specifications and Supporting Documentation,'' NIST PQC Standardization, 2023.

\bibitem{dilithium-spec}
L. Ducas et al., ``CRYSTALS-Dilithium Algorithm Specifications and Supporting Documentation,'' NIST PQC Standardization, 2023.

\bibitem{falcon-spec}
T. Prest et al., ``Falcon: Fast-Fourier Lattice-based Compact Signatures over NTRU,'' NIST PQC Standardization, 2023.

\bibitem{sphincs-spec}
J.-P. Aumasson et al., ``SPHINCS+ Specification,'' NIST PQC Standardization, 2023.

\bibitem{cnsa2}
National Security Agency, ``Commercial National Security Algorithm Suite 2.0,'' September 2022.

\bibitem{wolfssl}
wolfSSL Inc., ``wolfSSL Embedded SSL/TLS Library,'' \url{https://www.wolfssl.com/}, 2024.

\bibitem{cloudflare-pq}
Cloudflare, ``Post-Quantum Cryptography,'' \url{https://blog.cloudflare.com/post-quantum-cryptography/}, 2024.

\bibitem{hqc}
C. Aguilar Melchor et al., ``HQC: Hamming Quasi-Cyclic,'' NIST PQC Round 4, 2023.

\bibitem{bike}
N. Aragon et al., ``BIKE: Bit Flipping Key Encapsulation,'' NIST PQC Round 4, 2023.

\bibitem{mceliece}
D. J. Bernstein et al., ``Classic McEliece,'' NIST PQC Round 4, 2023.

\bibitem{tls13-pq}
D. Stebila and S. Fluhrer, ``Hybrid Key Exchange in TLS 1.3,'' Internet-Draft, IETF, 2024.

\bibitem{nist-sp800-208}
National Institute of Standards and Technology, ``SP 800-208: Recommendation for Stateful Hash-Based Signature Schemes,'' October 2020.

\bibitem{iso-iec-18033}
ISO/IEC, ``ISO/IEC 18033-2: Encryption algorithms --- Part 2: Asymmetric ciphers,'' 2024.

\bibitem{etsi-qsc}
ETSI, ``Quantum-Safe Cryptography (QSC) Technical Committee,'' \url{https://www.etsi.org/committee/qsc}, 2024.

\bibitem{arm-trustzone}
ARM Ltd., ``TrustZone Technology for ARMv8-M Architecture,'' 2024.

\end{thebibliography}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% APPENDICES
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\appendix

\chapter{Algorithm Parameter Reference}
\label{app:parameters}

\section{ML-KEM Parameters}

\begin{table}[htbp]
\centering
\caption{Complete ML-KEM Parameter Sets (FIPS 203)}
\begin{tabular}{@{}lrrr@{}}
\toprule
\textbf{Parameter} & \textbf{ML-KEM-512} & \textbf{ML-KEM-768} & \textbf{ML-KEM-1024} \\
\midrule
Security Level & 1 & 3 & 5 \\
$n$ & 256 & 256 & 256 \\
$k$ & 2 & 3 & 4 \\
$q$ & 3329 & 3329 & 3329 \\
$\eta_1$ & 3 & 2 & 2 \\
$\eta_2$ & 2 & 2 & 2 \\
$d_u$ & 10 & 10 & 11 \\
$d_v$ & 4 & 4 & 5 \\
Public Key (bytes) & 800 & 1,184 & 1,568 \\
Secret Key (bytes) & 1,632 & 2,400 & 3,168 \\
Ciphertext (bytes) & 768 & 1,088 & 1,568 \\
Shared Secret (bytes) & 32 & 32 & 32 \\
\bottomrule
\end{tabular}
\end{table}

\section{ML-DSA Parameters}

\begin{table}[htbp]
\centering
\caption{Complete ML-DSA Parameter Sets (FIPS 204)}
\begin{tabular}{@{}lrrr@{}}
\toprule
\textbf{Parameter} & \textbf{ML-DSA-44} & \textbf{ML-DSA-65} & \textbf{ML-DSA-87} \\
\midrule
Security Level & 2 & 3 & 5 \\
$n$ & 256 & 256 & 256 \\
$q$ & 8,380,417 & 8,380,417 & 8,380,417 \\
$k$ & 4 & 6 & 8 \\
$\ell$ & 4 & 5 & 7 \\
$\eta$ & 2 & 4 & 2 \\
$\tau$ & 39 & 49 & 60 \\
$\beta$ & 78 & 196 & 120 \\
$\gamma_1$ & $2^{17}$ & $2^{19}$ & $2^{19}$ \\
$\gamma_2$ & 95,232 & 261,888 & 261,888 \\
$\omega$ & 80 & 55 & 75 \\
Public Key (bytes) & 1,312 & 1,952 & 2,592 \\
Secret Key (bytes) & 2,560 & 4,032 & 4,896 \\
Signature (bytes) & 2,420 & 3,293 & 4,595 \\
\bottomrule
\end{tabular}
\end{table}

\section{SLH-DSA Parameters}

\begin{table}[htbp]
\centering
\caption{SLH-DSA Parameter Sets (FIPS 205) --- SHA-2 Variants}
\begin{tabular}{@{}lrrrrrr@{}}
\toprule
\textbf{Parameter Set} & \textbf{128s} & \textbf{128f} & \textbf{192s} & \textbf{192f} & \textbf{256s} & \textbf{256f} \\
\midrule
Security Level & 1 & 1 & 3 & 3 & 5 & 5 \\
Public Key (B) & 32 & 32 & 48 & 48 & 64 & 64 \\
Secret Key (B) & 64 & 64 & 96 & 96 & 128 & 128 \\
Signature (B) & 7,856 & 17,088 & 16,224 & 35,664 & 29,792 & 49,856 \\
\bottomrule
\end{tabular}
\end{table}

\chapter{Benchmark Data}
\label{app:benchmarks}

\section{pqm4 Benchmarks (STM32F4 @ 168 MHz)}

\begin{table}[htbp]
\centering
\caption{Complete pqm4 Benchmark Results (CPU Cycles)}
\begin{tabular}{@{}lrrrr@{}}
\toprule
\textbf{Algorithm} & \textbf{KeyGen} & \textbf{Encaps/Sign} & \textbf{Decaps/Verify} & \textbf{Stack (B)} \\
\midrule
\multicolumn{5}{l}{\textit{Key Encapsulation Mechanisms}} \\
ML-KEM-512 & 434,000 & 486,000 & 524,000 & 2,280 \\
ML-KEM-768 & 720,000 & 817,000 & 879,000 & 2,904 \\
ML-KEM-1024 & 1,105,000 & 1,241,000 & 1,337,000 & 3,528 \\
\midrule
\multicolumn{5}{l}{\textit{Digital Signatures}} \\
ML-DSA-44 & 1,428,000 & 4,824,000 & 1,478,000 & 35,000 \\
ML-DSA-65 & 2,355,000 & 6,324,000 & 2,456,000 & 51,000 \\
ML-DSA-87 & 3,412,000 & 8,946,000 & 3,587,000 & 67,000 \\
Falcon-512 & 65,000,000 & 42,000,000 & 430,000 & 39,000 \\
SLH-DSA-128f & 4,200,000 & 91,000,000 & 5,100,000 & 2,500 \\
\bottomrule
\end{tabular}
\end{table}

\chapter{Code Examples Index}
\label{app:code-index}

This appendix provides a quick reference to all code examples in this document:

\begin{table}[htbp]
\centering
\caption{Code Examples by Chapter}
\begin{tabular}{@{}llp{6cm}@{}}
\toprule
\textbf{Chapter} & \textbf{Language} & \textbf{Description} \\
\midrule
3 & C & ML-KEM encapsulation/decapsulation \\
3 & Python & ML-KEM with liboqs bindings \\
4 & C & ML-DSA signing and verification \\
4 & C & Falcon fixed-point sampler \\
5 & C & HQC decoding \\
6 & C & Memory-optimized NTT \\
6 & C & Side-channel resistant implementation \\
7 & C & liboqs integration \\
7 & Rust & pqcrypto usage \\
8 & C & TLS 1.3 hybrid key exchange \\
8 & C & MQTT with PQC \\
9 & C & Constant-time comparison \\
9 & C & Masking countermeasures \\
9 & Python & Security level selection tool \\
9 & C & FIPS mode configuration \\
10 & C & Crypto-agile framework \\
10 & Python & Migration cost estimator \\
\bottomrule
\end{tabular}
\end{table}

\chapter{Glossary of Terms}
\label{app:glossary}

\begin{description}
    \item[CRQC] Cryptographically Relevant Quantum Computer --- A quantum computer capable of breaking current public-key cryptography
    \item[HNDL] Harvest Now, Decrypt Later --- Attack strategy of storing encrypted data for future quantum decryption
    \item[KEM] Key Encapsulation Mechanism --- Asymmetric primitive for establishing shared secrets
    \item[LWE] Learning With Errors --- Mathematical problem underlying lattice-based cryptography
    \item[ML-KEM] Module-Lattice Key Encapsulation Mechanism (formerly Kyber)
    \item[ML-DSA] Module-Lattice Digital Signature Algorithm (formerly Dilithium)
    \item[NTT] Number Theoretic Transform --- Fast polynomial multiplication technique
    \item[OTA] Over-The-Air --- Remote firmware update capability
    \item[PQC] Post-Quantum Cryptography --- Cryptographic algorithms resistant to quantum attacks
    \item[SCA] Side-Channel Attack --- Attack exploiting physical implementation characteristics
    \item[SLH-DSA] Stateless Hash-based Digital Signature Algorithm (formerly SPHINCS+)
\end{description}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% END OF DOCUMENT
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}
