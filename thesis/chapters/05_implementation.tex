% ============================================================================
% CHAPTER 5: IMPLEMENTATION AND BENCHMARKS
% ============================================================================

\chapter{Implementation and Benchmarks}
\label{chap:implementation}

\section{Introduction}

This chapter presents our Python implementation of the combined PQC + LZ4 approach and benchmark results validating the theoretical analysis from Chapter 4.

\section{Technical Environment}

\subsection{Libraries}

\begin{table}[H]
\centering
\caption{Python libraries used}
\label{tab:libraries}
\begin{tabular}{llp{6cm}}
\toprule
\textbf{Library} & \textbf{Version} & \textbf{Purpose} \\
\midrule
liboqs-python & 0.9.0 & Post-quantum cryptography (Kyber) \\
lz4 & 4.3.2 & LZ4 compression (primary) \\
zlib & built-in & ZLIB compression (comparison) \\
zstandard & 0.22.0 & Zstandard compression (comparison) \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Environment}
\begin{itemize}
    \item \textbf{OS}: Linux (Arch Linux)
    \item \textbf{Python}: 3.13 with virtual environment
    \item \textbf{Benchmarks}: Focus on relative comparisons for reproducibility
\end{itemize}

\section{Implementation}

\subsection{Compression Module}

\begin{lstlisting}[language=Python, caption={Compression interface with LZ4 as primary}, label={lst:compress}]
import lz4.frame
import zlib

def compress_lz4(data: bytes) -> bytes:
    """Compress data using LZ4 (primary algorithm)."""
    return lz4.frame.compress(data)

def decompress_lz4(data: bytes) -> bytes:
    """Decompress LZ4 data."""
    return lz4.frame.decompress(data)

def compress_zlib(data: bytes, level: int = 6) -> bytes:
    """Compress using ZLIB (comparison only)."""
    return zlib.compress(data, level)
\end{lstlisting}

\subsection{PQC Module}

\begin{lstlisting}[language=Python, caption={Kyber768 key encapsulation}, label={lst:pqc}]
import oqs

class KyberKEM:
    """Kyber768 Key Encapsulation Mechanism."""
    
    def __init__(self):
        self.kem = oqs.KeyEncapsulation("Kyber768")
    
    def generate_keypair(self) -> tuple:
        public_key = self.kem.generate_keypair()
        return public_key, self.kem.export_secret_key()
    
    def encapsulate(self, public_key: bytes) -> tuple:
        return self.kem.encap_secret(public_key)
    
    def decapsulate(self, secret_key: bytes, 
                    ciphertext: bytes) -> bytes:
        kem = oqs.KeyEncapsulation("Kyber768", secret_key)
        return kem.decap_secret(ciphertext)
\end{lstlisting}

\subsection{Combined Pipeline}

\begin{lstlisting}[language=Python, caption={Combined LZ4 + Kyber768 pipeline}, label={lst:pipeline}]
def process_iot_message(data: bytes, 
                        public_key: bytes) -> dict:
    """Process IoT message: compress with LZ4, encrypt with Kyber768."""
    # Compress with LZ4
    compressed = lz4.frame.compress(data)
    
    # Kyber768 key encapsulation
    kem = KyberKEM()
    ciphertext, shared_secret = kem.encapsulate(public_key)
    
    # Total transmission: ciphertext + compressed payload
    total_size = len(ciphertext) + len(compressed)
    
    return {
        'original_size': len(data),
        'compressed_size': len(compressed),
        'ciphertext_size': len(ciphertext),
        'total_size': total_size,
        'bandwidth_savings': (len(data) - total_size) / len(data) * 100
    }
\end{lstlisting}

\section{Benchmark Methodology}

\subsection{Test Datasets}

\begin{table}[H]
\centering
\caption{Test datasets}
\label{tab:datasets}
\begin{tabular}{llcc}
\toprule
\textbf{Dataset} & \textbf{Description} & \textbf{Size} & \textbf{Compressibility} \\
\midrule
Sensor JSON & Temperature/humidity readings & 500 B & High \\
Sensor Batch & 10 readings batched & 5 KB & High \\
Binary Data & Raw sensor values & 1 KB & Medium \\
Random Data & Pseudo-random bytes & 1 KB & Very Low \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Metrics}
\begin{enumerate}
    \item Compression ratio: Original / Compressed
    \item Total transmission size: Compressed + PQC overhead
    \item Bandwidth savings: Reduction vs uncompressed PQC
    \item Processing time: Compression + encryption operations
\end{enumerate}

\section{Results}

\subsection{Compression Performance}

\begin{table}[H]
\centering
\caption{Compression results by algorithm (IoT JSON sensor data)}
\label{tab:compression_results}
\begin{tabular}{llcccc}
\toprule
\textbf{Dataset} & \textbf{Algorithm} & \textbf{Original} & \textbf{Compressed} & \textbf{Ratio} & \textbf{Speed} \\
\midrule
\multirow{3}{*}{Sensor JSON (6 KB)} 
 & \rowcolor{green!10} LZ4 & 6,150 B & 177 B & 34.7x & 1371 MB/s\footnote{Benchmarks performed on desktop hardware (Section 5.2.2). Actual throughput on Cortex-M4 class microcontrollers is typically 10--20 MB/s.} \\
 & ZLIB & 6,150 B & 147 B & 41.8x & 128 MB/s \\
 & Zstandard & 6,150 B & 118 B & 52.1x & 377 MB/s \\
\bottomrule
\end{tabular}
\end{table}

\textbf{Note}: LZ4 is \textbf{10x faster} than ZLIB with only slightly lower compression ratio. For IoT endpoints with limited RAM (16 KB vs 32+ KB), LZ4 is optimal.

\subsection{Kyber768 Performance}

\begin{table}[H]
\centering
\caption{Kyber768 measurements}
\label{tab:pqc_results}
\begin{tabular}{lcc}
\toprule
\textbf{Metric} & \textbf{Value} \\
\midrule
Public Key & 1,184 B \\
Ciphertext & 1,088 B \\
Key Generation & 0.18 ms \\
Encapsulation & 0.22 ms \\
Decapsulation & 0.25 ms \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Combined Approach Results}

\begin{table}[H]
\centering
\caption{Combined approach: total transmission sizes with LZ4}
\label{tab:combined_results}
\begin{tabular}{lcccc}
\toprule
\textbf{Payload} & \textbf{Original} & \textbf{PQC+LZ4} & \textbf{Savings} \\
\midrule
6 KB JSON & 6,150 B & 1,293 B & 79.0\% \\
\bottomrule
\end{tabular}
\end{table}

\textbf{Key result}: With LZ4 compression, the total transmission (compressed data + Kyber768 ciphertext) is significantly smaller than the original uncompressed data.

\begin{figure}[H]
\centering
\includegraphics[width=1\textwidth]{figures/compression_comparison.png}
\caption{Compression ratio comparison across algorithms}
\label{fig:compression_comparison}
\end{figure}

\subsection{Bandwidth Savings Analysis}

\begin{figure}[H]
\centering
\begin{tabular}{|p{12cm}|}
\hline
\\
\textbf{Bandwidth Savings by Payload Size (with LZ4)} \\[0.3cm]
\begin{tabular}{l|cccc}
Payload Size & 500 B & 1 KB & 5 KB & 10 KB \\
\hline
Savings vs PQC Only & 17.6\% & 16.3\% & 60.7\% & 65.2\% \\
\end{tabular}
\\[0.5cm]
\textit{Key insight: Larger payloads benefit more from compression} \\
\textit{as fixed PQC overhead is amortized.} \\
\\
\hline
\end{tabular}
\caption{Bandwidth savings by payload size}
\label{fig:bandwidth_chart}
\end{figure}

\subsection{Speed Comparison}

\begin{table}[H]
\centering
\caption{Processing speed comparison}
\label{tab:speed_comparison}
\begin{tabular}{lccc}
\toprule
\textbf{Algorithm} & \textbf{Compress (MB/s)} & \textbf{Decompress (MB/s)} & \textbf{Memory} \\
\midrule
\rowcolor{green!10}
LZ4 & 500+ & 2000+ & 16 KB \\
ZLIB & 50-100 & 200-400 & 32 KB \\
Zstandard & 200-400 & 600-1000 & 64 KB+ \\
\bottomrule
\end{tabular}
\end{table}

\begin{figure}[H]
\centering
\includegraphics[width=0.85\textwidth]{figures/combined_comparison.png}
\caption{Bandwidth savings with PQC + compression}
\label{fig:bandwidth_savings}
\end{figure}

\section{Analysis}

\subsection{Key Findings}

\begin{enumerate}
    \item \textbf{LZ4 is practical}: Achieves 50-75\% compression on JSON sensor data with minimal CPU/memory overhead
    \item \textbf{PQC overhead is manageable}: With LZ4, Kyber768 adds acceptable overhead for larger payloads
    \item \textbf{Batching is powerful}: Combining readings dramatically improves efficiency
    \item \textbf{Speed advantage}: LZ4 is 5-10x faster than ZLIB with lower memory footprint
\end{enumerate}

\subsection{Trade-off: Compression Ratio vs Speed}

LZ4 achieves lower compression ratios than ZLIB/Zstd (2.3x vs 2.7-2.9x on 500 B JSON). However, for IoT endpoints:
\begin{itemize}
    \item Speed difference matters more than marginal compression gains
    \item 16 KB memory fits alongside Kyber's stack requirements
    \item Energy savings from faster processing outweigh extra transmitted bytes
\end{itemize}

\subsection{Recommendations}

\begin{enumerate}
    \item \textbf{Use LZ4} for IoT endpoints
    \item \textbf{Batch messages} when latency permits
    \item \textbf{Use session keys} for frequently communicating devices
    \item \textbf{Use ZLIB/Zstd at gateways} where resources are abundant
\end{enumerate}

\section{Chapter Conclusion}

Our implementation validates the combined PQC + LZ4 approach. LZ4 achieves 50-75\% compression on IoT sensor data with sub-millisecond processing times. For batched payloads (5+ KB), bandwidth savings exceed 60\%. The approach makes quantum-resistant security practical for resource-constrained IoT devices.
