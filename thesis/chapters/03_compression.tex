% ============================================================================
% CHAPTER 3: COMPRESSION ALGORITHMS
% ============================================================================

\chapter{Compression Algorithms}
\label{chap:compression}

\section{Introduction}

PQC produces larger keys and ciphertexts than classical cryptography (see Chapter 2). Data compression can offset this overhead by reducing payload size before transmission. This chapter examines compression fundamentals and justifies LZ4 as the optimal algorithm for resource-constrained IoT devices.

\section{Fundamentals of Data Compression}

\subsection{Lossless vs Lossy Compression}

\textbf{Lossless compression} perfectly reconstructs original data (ZIP, GZIP, PNG). \textbf{Lossy compression} permanently removes information for higher ratios (JPEG, MP3). For cryptographic data, we \textbf{must use lossless compression}---losing even one bit causes decryption failure.

\subsection{Compression Metrics}

\begin{itemize}
    \item \textbf{Compression ratio}: $\frac{\text{Original Size}}{\text{Compressed Size}}$ (ratio of 2.0 = 50\% reduction)
    \item \textbf{Speed}: Compression/decompression throughput (MB/s)
    \item \textbf{Memory usage}: RAM required during operation
\end{itemize}

For IoT, all metrics matter. We prioritize speed and low memory over maximum compression ratio.

\subsection{Information Theory}

Entropy $H = -\sum_{i} p_i \log_2(p_i)$ sets the theoretical compression limit \cite{huffman1952method}. No lossless algorithm can compress below entropy on average.

\section{Compression Algorithm Families}

\subsection{Classical Algorithms}

\textbf{Run-Length Encoding (RLE)} replaces repeated values with count-value pairs. Simple and fast but only effective for data with many repetitions.

\textbf{Huffman Coding} \cite{huffman1952method} assigns shorter codes to frequent symbols. Optimal prefix-free codes, used in JPEG/MP3/ZIP.

\textbf{Lempel-Ziv (LZ77/LZ78)} \cite{ziv1977universal, ziv1978compression} encode references to previously seen data. Foundation of modern compression.

\subsection{Modern Algorithms}

\textbf{ZLIB/DEFLATE} \cite{deutsch1996zlib} combines LZ77 with Huffman coding. Universally supported but requires 32KB RAM and offers moderate speed.

\textbf{Zstandard (Zstd)} \cite{collet2016zstandard} achieves excellent compression with configurable levels. Requires significant RAM (64KB+) and uses complex entropy coding.

\textbf{Brotli} optimizes for web content with excellent text compression but slow compression speed.

\section{LZ4: Our Chosen Algorithm}

LZ4 \cite{collet2013lz4} is designed for extreme speed with acceptable compression ratios. We select LZ4 for IoT because it minimizes total system cost (compression energy + transmission energy + memory pressure).

\subsection{How LZ4 Works}

LZ4 is based on LZ77 with simplifications for speed:
\begin{itemize}
    \item Simple hash table instead of extensive searching
    \item Fixed match length encoding
    \item No entropy coding (no Huffman overhead)
    \item Designed for modern CPU caches
\end{itemize}

\begin{algorithm}[H]
\caption{LZ4 Compression (Simplified)}
\label{alg:lz4}
\begin{algorithmic}[1]
\Require Input data $D$
\Ensure Compressed data $C$
\State $hashTable \gets$ empty hash table (maps 4-byte sequences to positions)
\State $pos \gets 0$, $anchor \gets 0$
\While{$pos < length(D) - 4$}
    \State $hash \gets$ hash of $D[pos:pos+4]$
    \State $matchPos \gets hashTable[hash]$
    \State $hashTable[hash] \gets pos$
    \If{$matchPos$ exists \textbf{and} $D[matchPos:matchPos+4] = D[pos:pos+4]$}
        \State Output literals from $anchor$ to $pos$
        \State $matchLength \gets$ extend match forward
        \State Output match token: $(length, offset)$
        \State $pos \gets pos + matchLength$, $anchor \gets pos$
    \Else
        \State $pos \gets pos + 1$
    \EndIf
\EndWhile
\State Output remaining literals from $anchor$ to end
\State \Return $C$
\end{algorithmic}
\end{algorithm}

\subsection{LZ4 Advantages for IoT}

\begin{table}[H]
\centering
\caption{LZ4 characteristics for IoT applications}
\label{tab:lz4_characteristics}
\begin{tabular}{ll}
\toprule
\textbf{Property} & \textbf{Value} \\
\midrule
Compression speed & 500+ MB/s \\
Decompression speed & 2000+ MB/s \\
Memory (compression) & 16 KB \\
Memory (decompression) & Minimal (buffer only) \\
Compression ratio & 40-60\% reduction typical \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Why LZ4 over ZLIB/Zstd for IoT Endpoints}

For resource-constrained IoT devices, LZ4 is superior:

\begin{enumerate}
    \item \textbf{Energy efficiency}: Below ~500-1000 byte payloads, stronger compression does not amortize CPU cost. Most IoT telemetry falls below this threshold.
    
    \item \textbf{Total system cost}: The relevant metric is \textit{compression energy + transmission energy + memory pressure}. ZLIB/Zstd reduce bytes more but consume more total energy on MCUs.
    
    \item \textbf{Memory footprint}: LZ4 needs 16 KB; ZLIB needs 32 KB sliding window plus Huffman tables; Zstd needs 64 KB+ with FSE tables. This conflicts with Kyber's 8-10 KB stack usage on constrained devices.
    
    \item \textbf{Predictable execution}: LZ4 has simple, regular execution patterns. ZLIB/Zstd have data-dependent entropy coding, increasing side-channel risk in secure systems.
    
    \item \textbf{Radio overhead}: PHY/MAC overhead dominates for small packets. 20-30\% extra compression often yields negligible airtime savings.
\end{enumerate}

\textbf{Note}: ZLIB/Zstd remain appropriate for \textit{gateways} where resources are abundant and data can be batched.

\section{Algorithm Comparison}

\begin{table}[H]
\centering
\caption{Compression algorithm comparison for IoT}
\label{tab:compression_comparison}
\begin{tabular}{lccccc}
\toprule
\textbf{Algorithm} & \textbf{Ratio} & \textbf{Speed} & \textbf{RAM} & \textbf{IoT Suitability} \\
\midrule
RLE & Poor* & Very Fast & Very Low & Limited use \\
ZLIB & Very Good & Moderate & 32 KB & Gateway only \\
\rowcolor{green!10}
LZ4 & Good & Very Fast & 16 KB & \textbf{Optimal for endpoints} \\
Zstd & Excellent & Fast & 64 KB+ & Gateway only \\
\bottomrule
\end{tabular}
\end{table}

*RLE can be excellent for specific data with many repetitions.

\begin{figure}[H]
\centering
\includegraphics[width=0.85\textwidth]{figures/compression_tradeoff.png}
\caption{Compression trade-offs: ratio vs speed. LZ4 offers the best balance for IoT endpoints.}
\label{fig:compression_tradeoff}
\end{figure}

\section{IoT Data Characteristics}

IoT sensor data has specific properties affecting compression:
\begin{itemize}
    \item \textbf{Small payloads}: 10-1000 bytes typical
    \item \textbf{Structured data}: JSON sensor readings with repeated field names
    \item \textbf{Real-time requirements}: Cannot wait for slow compression
\end{itemize}

PQC data (Kyber keys/ciphertexts) contains polynomial coefficients with some structure, achieving moderate compression.

\section{Chapter Conclusion}

For PQC-enabled IoT \textit{endpoints}, LZ4 minimizes total system cost and risk. Its 16 KB memory footprint coexists with Kyber's stack requirements, and its extreme speed ensures compression energy stays below transmission savings. ZLIB/Zstd are appropriate for gateways where resources are abundant. Chapter 4 presents our combined architecture using Kyber768 with LZ4.
