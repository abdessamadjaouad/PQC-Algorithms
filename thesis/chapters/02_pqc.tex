% ============================================================================
% CHAPTER 2: POST-QUANTUM CRYPTOGRAPHY
% ============================================================================

\chapter{Post-Quantum Cryptography}
\label{chap:pqc}

\section{Introduction}

Quantum computers will break RSA and ECC using Shor's algorithm (see Chapter 1). Post-Quantum Cryptography (PQC) uses mathematical problems that remain hard for both classical and quantum computers. This chapter examines PQC families and focuses on Kyber, the NIST-selected key encapsulation mechanism we implement.

\section{History and NIST Standardization}

The NIST standardization process began in 2016, evaluating 69 initial submissions through multiple rounds of cryptanalysis. In 2024, NIST published the final standards \cite{nist2024pqc}:
\begin{itemize}
    \item \textbf{FIPS 203}: ML-KEM (based on Kyber)---Key Encapsulation Mechanism
    \item \textbf{FIPS 204}: ML-DSA (based on Dilithium)---Digital Signature Algorithm
    \item \textbf{FIPS 205}: SLH-DSA (based on SPHINCS+)---Stateless Hash-based Signatures
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[width=1\textwidth]{figures/quantum_timeline.png}
\caption{Timeline from Shor's algorithm (1994) to expected cryptographically relevant quantum computers (2030)}
\label{fig:quantum_timeline}
\end{figure}

\section{PQC Algorithm Families Overview}

Post-quantum algorithms are based on different mathematical problems. Each family has distinct trade-offs:

\begin{table}[H]
\centering
\caption{Overview of post-quantum cryptography families}
\label{tab:pqc_families}
\begin{tabular}{p{2.5cm}p{3cm}p{3cm}p{4cm}}
\toprule
\textbf{Family} & \textbf{Hard Problem} & \textbf{Examples} & \textbf{Characteristics} \\
\midrule
Lattice-based & Learning With Errors & Kyber, Dilithium & Small keys, fast, NIST selected \\
Hash-based & Hash function security & SPHINCS+ & Conservative, large signatures \\
Code-based & Decoding random codes & McEliece, BIKE & Large keys, fast encryption \\
Multivariate & Polynomial equations & Rainbow (broken) & Small signatures, large keys \\
\bottomrule
\end{tabular}
\end{table}

\begin{figure}[H]
\centering
\includegraphics[width=0.95\textwidth]{figures/pqc_families_comparison.png}
\caption{Comparison of PQC families. Lattice-based algorithms were selected by NIST for their excellent balance of properties.}
\label{fig:pqc_families}
\end{figure}

Lattice-based cryptography emerged as the most practical option, forming the basis of NIST's primary standards. We focus on this family.

\section{Lattice-Based Cryptography}

\subsection{Learning With Errors (LWE)}

Lattice-based cryptography uses problems on high-dimensional lattices. The Learning With Errors problem, introduced by Regev \cite{regev2005lattices}, is fundamental: given equations $b = A \cdot s + e$ where $s$ is secret and $e$ is small error, find $s$. This is provably as hard as worst-case lattice problems.

Kyber uses Module-LWE (MLWE), working with polynomials in the ring $R_q = \mathbb{Z}_q[X]/(X^n + 1)$ where $n = 256$ and $q = 3329$. This provides efficiency without compromising security.

\subsection{Number Theoretic Transform (NTT)}

For efficiency, Kyber uses NTT (similar to FFT but over finite fields), reducing polynomial multiplication from $O(n^2)$ to $O(n \log n)$---crucial for $n = 256$.

\section{Kyber: Our Chosen Algorithm}

Kyber \cite{avanzi2022crystals} is a Key Encapsulation Mechanism (KEM) that securely establishes a shared secret between two parties, which is then used for symmetric encryption.

\subsection{Kyber Operations}

\begin{enumerate}
    \item \textbf{Key Generation}: Generate public/private key pair
    \item \textbf{Encapsulation}: Use public key to create ciphertext and shared secret
    \item \textbf{Decapsulation}: Use private key to recover shared secret from ciphertext
\end{enumerate}

\begin{algorithm}[H]
\caption{Kyber Key Generation (Simplified)}
\label{alg:kyber_keygen}
\begin{algorithmic}[1]
\State Generate random seed $\rho$
\State Generate matrix $A$ from $\rho$ (public)
\State Sample secret vector $s$ and error vector $e$ with small coefficients
\State Compute $t = A \cdot s + e$
\State \Return Public key $pk = (\rho, t)$, Secret key $sk = s$
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\caption{Kyber Encapsulation (Simplified)}
\label{alg:kyber_encap}
\begin{algorithmic}[1]
\State Parse public key: $(\rho, t)$, regenerate $A$ from $\rho$
\State Sample random vectors $r$, $e_1$, $e_2$ with small coefficients
\State Compute $u = A^T \cdot r + e_1$
\State Compute $v = t^T \cdot r + e_2 + \lfloor q/2 \rfloor \cdot m$
\State \Return Ciphertext $ct = (u, v)$, Shared secret $K = Hash(m, ct)$
\end{algorithmic}
\end{algorithm}

\subsection{Why Kyber768}

We select \textbf{Kyber768} (NIST Security Level 3) for this thesis:

\begin{table}[H]
\centering
\caption{Kyber variants---Kyber768 provides optimal balance for IoT}
\label{tab:kyber_params}
\begin{tabular}{lccccc}
\toprule
\textbf{Variant} & \textbf{Security} & \textbf{Public Key} & \textbf{Ciphertext} & \textbf{Recommendation} \\
\midrule
Kyber512 & Level 1 (AES-128) & 800 B & 768 B & Short-term only \\
\rowcolor{green!10}
Kyber768 & Level 3 (AES-192) & 1,184 B & 1,088 B & \textbf{Best for IoT} \\
Kyber1024 & Level 5 (AES-256) & 1,568 B & 1,568 B & High-security only \\
\bottomrule
\end{tabular}
\end{table}

\textbf{Justification}: Level 3 security is appropriate for data needing 10--20 year protection. Kyber768 balances security with reasonable overhead for IoT.

\section{PQC Size Overhead}

The main challenge is larger key and ciphertext sizes compared to classical cryptography:

\begin{table}[H]
\centering
\caption{Size comparison: Classical vs Post-Quantum Cryptography}
\label{tab:size_comparison}
\begin{tabular}{lcccc}
\toprule
\textbf{Algorithm} & \textbf{Type} & \textbf{Public Key} & \textbf{Ciphertext/Sig} & \textbf{Overhead vs ECC} \\
\midrule
ECDH P-256 & KEM & 64 B & 64 B & --- \\
Kyber768 & KEM & 1,184 B & 1,088 B & \textbf{18x / 17x} \\
\midrule
ECDSA P-256 & Signature & 64 B & 64 B & --- \\
Dilithium3 & Signature & 1,952 B & 3,293 B & 31x / 51x \\
\bottomrule
\end{tabular}
\end{table}

This size increase motivates combining PQC with compression, addressed in Chapter 3.

\section{PQC Performance on IoT}

Despite larger sizes, Kyber operations are fast:

\begin{table}[H]
\centering
\caption{Kyber768 operation times on ARM Cortex-M4}
\label{tab:pqc_speed}
\begin{tabular}{lccc}
\toprule
\textbf{Operation} & \textbf{Time} & \textbf{Note} \\
\midrule
Key Generation & 0.8 ms & Once per session \\
Encapsulation & 0.9 ms & Per key exchange \\
Decapsulation & 0.9 ms & Per key exchange \\
\bottomrule
\end{tabular}
\end{table}

The main bottleneck is \textbf{bandwidth, not computation}. Optimized implementations run in under 10 KB RAM, feasible for most IoT devices.

\section{Chapter Conclusion}

Lattice-based cryptography, specifically Kyber, offers the best PQC solution for IoT: NIST-standardized, efficient operations, and reasonable key sizes. However, Kyber768's 1,184-byte public key and 1,088-byte ciphertext are 17--18 times larger than ECC equivalents. Chapter 3 addresses this overhead through compression.
